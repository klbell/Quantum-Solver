<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ILNumerics</name>
    </assembly>
    <members>
        <member name="M:ILNumerics.Algorithms.Graphic.Triangularize(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Int32},System.Int32,ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Int32})">
            <summary>
            Increase the number of triangles by doubling existing triangles
            </summary>
            <param name="vertices">Vertices</param>
            <param name="indices">Triangle index definitions</param>
            <param name="iterations">Number of iterations, each iteration will make 4 triangles out of each triangle</param>
            <param name="outVertices">[Output] Vertices.</param>
            <param name="outTriangles">[Output] Triangles</param>
            <remarks><para>Incoming triangles are expected to not be degenerated. This means:
            Every edge is used only twice at most. No triangle shares more than two
            corners with some other triangle. </para></remarks>
        </member>
        <member name="T:ILNumerics.ILMath">
            <summary>
            Main math class, exposes all static math functions. Users should write algorithms in a class derived from <c>ILMath</c>. 
            </summary>
        </member>
        <member name="M:ILNumerics.ILMath.em(ILNumerics.ILInArray{System.Double},System.Int32,ILNumerics.ILOutArray{System.Double},ILNumerics.ILMath.EMInitializationMethod,ILNumerics.ILInArray{System.Double},System.Int32,System.Double)">
            <summary>
            Expectation maximization algorithm
            </summary>
            <param name="Samples">Input data, data points in columns</param>
            <param name="k">Number of clusters</param>
            <param name="method">[Optional] Method used for initializing the cluster centers, default: kmeans_random</param>
            <param name="UserCenters">[Optional] For method 'user': initial cluster centers, size samples.D[0] x k, for other methods ignored</param>
            <param name="maxiterexit">[Optional] Break after that number of iterations, if no convergence was reached</param>
            <param name="Sigma">[Output] Covariance estimation for all clusters, size d x d x k, d = samples.D[0]</param>
            <param name="centerconverg_exit">[Optional] Exit iteration if norm(L) falls below that value, default: 0.001</param>
            <returns>Estimated centers for all clusters, size samples.D[0] x k</returns>
            <remarks><para>The EM algorithm expects the data samples to be drawn from <paramref name="k"/> multivariate normal distributions. 
            It estimates the parameters 'center' and 'sigma (covariance)' of every distribution. Therefore, the position and 'shape' 
            of each distribution is calculated in such a way, that the likelyhood of generating the given sample points is maximized.</para>
            <para>The parameter k must be determined by the user. This reflects the a priori knowledge of the number of distributions 
            or clusters in the data.</para>
            <para>The algorithm exits, if one of the exit criteria is reached: 
            <list type="bullet"><item>norm(L) &lt; 'centerconverg_exit' - where L is the difference between 
            the centers from the last step and the centers just computed in the current step</item>
            <item>the number of iteration steps exceeds the limit of 'maxiterexit' iterations.</item></list></para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.em(ILNumerics.ILInArray{System.Single},System.Int32,ILNumerics.ILOutArray{System.Single},ILNumerics.ILMath.EMInitializationMethod,ILNumerics.ILInArray{System.Single},System.Int32,System.Double)">
            <summary>
            Expectation maximization algorithm
            </summary>
            <param name="Samples">Input data, data points in columns</param>
            <param name="k">Number of clusters</param>
            <param name="method">[Optional] Method used for initializing the cluster centers, default: kmeans_random</param>
            <param name="UserCenters">[Optional] For method 'user': initial cluster centers, size samples.D[0] x k, for other methods ignored</param>
            <param name="maxiterexit">[Optional] Break after that number of iterations, if no convergence was reached</param>
            <param name="Sigma">[Output] Covariance estimation for all clusters, size d x d x k, d = samples.D[0]</param>
            <param name="centerconverg_exit">[Optional] Exit iteration if norm(L) falls below that value, default: 0.001</param>
            <returns>Estimated centers for all clusters, size samples.D[0] x k</returns>
            <remarks><para>The EM algorithm expects the data samples to be drawn from <paramref name="k"/> multivariate normal distributions. 
            It estimates the parameters 'center' and 'sigma (covariance)' of every distribution. Therefore, the position and 'shape' 
            of each distribution is calculated in such a way, that the likelyhood of generating the given sample points is maximized.</para>
            <para>The parameter k must be determined by the user. This reflects the a priori knowledge of the number of distributions 
            or clusters in the data.</para>
            <para>The algorithm exits, if one of the exit criteria is reached: 
            <list type="bullet"><item>norm(L) &lt; 'centerconverg_exit' - where L is the difference between 
            the centers from the last step and the centers just computed in the current step</item>
            <item>the number of iteration steps exceeds the limit of 'maxiterexit' iterations.</item></list></para>
            </remarks>
        </member>
        <!-- Ung端ltiger XML-Kommentar wurde f端r den Member "M:ILNumerics.ILMath.knn(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Int32,ILNumerics.ILMath.DistanceMetrics,System.Double,System.Boolean)" ignoriert -->
        <member name="M:ILNumerics.ILMath.testStable(ILNumerics.ILInArray{System.Double})">
            <summary>
            Test for numerical instability, expects positive data only!
            </summary>
            <param name="samples_normalized">Input data</param>
            <returns>true: no instability detected, false, possible instablility</returns>
        </member>
        <!-- Ung端ltiger XML-Kommentar wurde f端r den Member "M:ILNumerics.ILMath.knn(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Int32,ILNumerics.ILMath.DistanceMetrics,System.Double,System.Boolean)" ignoriert -->
        <member name="M:ILNumerics.ILMath.testStable(ILNumerics.ILInArray{System.Single})">
            <summary>
            Test for numerical instability, expects positive data only!
            </summary>
            <param name="samples_normalized">Input data</param>
            <returns>true: no instability detected, false, possible instablility</returns>
        </member>
        <member name="M:ILNumerics.ILMath.krr(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Calculate the kernel ridge regression (KRR) of X to Y
            </summary>
            <param name="X">Input data X, observations in columns</param>
            <param name="Y">Input data Y (regression target)</param>
            <returns>Kernel ridge regression model with linear kernel and no regularization</returns>
        </member>
        <member name="M:ILNumerics.ILMath.krr(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILMath.KRRTypes,ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Calculate the kernel ridge regression (KRR) of X to Y
            </summary>
            <param name="X">Input data X, observations in columns</param>
            <param name="Y">Input data Y (regression target)</param>
            <param name="kernel">Kernel type to use</param>
            <param name="Kernelparam">Kernel parameters, scalar constant, if invalid: defaults to 1</param>
            <param name="Regularization">Regularization constant (set to -1 to have no regularization)</param>
            <returns>The kernel ridge regression model</returns>
        </member>
        <member name="M:ILNumerics.ILMath.ridge_regression(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Ordinary least squares regression/ ridge regression
            </summary>
            <param name="X">Data matrix, data points in columns</param>
            <param name="Y">Training targets (or 'labels') corresponding to <paramref name="X"/></param>
            <param name="Degree">Highest degree of polynomials for the design matrix</param> 
            <param name="Regularization">Regularization constant (usually some "small" summand for stabilizing the matrix inversion).</param>
            <returns>Train result used for applying the model to new data.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.pca(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Principal Component Analysis (PCA)
            </summary>
            <param name="A">Data matrix, size (m,n); each of n observations is expected in a column of m variables</param>
            <param name="outWeights">[Output] Weights for scaling the components according to the original data</param>
            <param name="outCenter">[Output] Vector pointing to the center of the input data A</param>
            <param name="outScores">[Output] Scaling factors for the component to recreate original data</param>
            <returns>PCA components; weights, center and scores are returned at optional output parameters</returns>
            <remarks>Principal Component Analysis (PCA) is commonly used as method for dimension reduction. It computes 
            a number of 'principal components' which span a space of orthogonal directions. The nice property is, these 
            directions are choosen such, as to maximize the variance of original data, once they are projected onto them. 
            We can simply pick only a subset of components, having associated a high variance and leave out other components, which do
            not contribute much to the distribution of the original data. The resulting subspace is constructed of fewer
            dimensions as the original space - with a smaller reconstrution error. Therefore, PCA is commonly used 
            for visualizing higher dimensional data in only two or three dimensional plots. It helps analyzing datasets which 
            otherwise could only be visualized by picking individual dimensions. By help of PCA, 'interesting' directions 
            in the data are identified.
            <para>Any output parameter are optional and may be ommited ore provided as null parameter: 
            <list type="bullet">
            <item><b>components</b> (return value) prinicipal components. Matrix of size m x m, m components are provided in columns. The first 
            component marks the direction in the data A, which corresponds to the largest variance (i.e. by projecting the data onto 
            that direction, the largest variance would be created). Adjacent components are all orthogonal to each other. 
            The components are ordered in columns of decreasing variance.</item>
            <item><b>weights</b> vectors. While the components returned are normalized to length 1, the 'weights' vector 
            contains the factors needed, to scale the components in order to reflect the real spacial distances in the 
            original data.</item>
            <item><b>center</b> of the original data. The vector points to the weight middle of A.</item>
            <item><b>scores</b> is a matrix of size m by n. For each datapoint given in A, it contains factors for each component 
            needed to reproduce the original data point in terms of the components.</item>
            </list></para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.pca(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Principal Component Analysis (PCA)
            </summary>
            <param name="A">Data matrix, size (m,n); each of n observations is expected in a column of m variables</param>
            <param name="outWeights">[Output] Weights for scaling the components according to the original data</param>
            <param name="outCenter">[Output] Vector pointing to the center of the input data A</param>
            <param name="outScores">[Output] Scaling factors for the component to recreate original data</param>
            <returns>PCA components; weights, center and scores are returned at optional output parameters</returns>
            <remarks>Principal Component Analysis (PCA) is commonly used as method for dimension reduction. It computes 
            a number of 'principal components' which span a space of orthogonal directions. The nice property is, these 
            directions are choosen such, as to maximize the variance of original data, once they are projected onto them. 
            We can simply pick only a subset of components, having associated a high variance and leave out other components, which do
            not contribute much to the distribution of the original data. The resulting subspace is constructed of fewer
            dimensions as the original space - with a smaller reconstrution error. Therefore, PCA is commonly used 
            for visualizing higher dimensional data in only two or three dimensional plots. It helps analyzing datasets which 
            otherwise could only be visualized by picking individual dimensions. By help of PCA, 'interesting' directions 
            in the data are identified.
            <para>Any output parameter are optional and may be ommited ore provided as null parameter: 
            <list type="bullet">
            <item><b>components</b> (return value) prinicipal components. Matrix of size m x m, m components ar provided in columns. The first 
            component marks the direction in the data A, which corresponds to the largest variance (i.e. by projecting the data onto 
            that direction, the largest variance would be created). Adjacent components are all orthogonal to each other. 
            The components are ordered in columns of decreasing variance.</item>
            <item><b>weights</b> vectors. While the components returned are normalized to length 1, the 'weights' vector 
            contains the factors needed, to scale the components in order to reflect the real spacial distances in the 
            original data.</item>
            <item><b>center</b> of the original data. The vector points to the weight middle of A.</item>
            <item><b>scores</b> is a matrix of size m by n. For each datapoint given in A, it contains factors for each component 
            needed to reproduce the original data point in terms of the components.</item>
            </list></para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.kMeansClust(ILNumerics.ILInArray{System.Double},ILNumerics.ILBaseArray,System.Int32,System.Boolean,ILNumerics.ILOutArray{System.Double})">
            <summary>
            k-means clustering: find clusters in data matrix X
            </summary>
            <param name="X">Data matrix, data points are given as columns</param>
            <param name="k">Initial number of clusters</param>
            <param name="centerInitRandom">[Optional] false: pick the first k data points as initial centers, true: pick random datapoints (default)</param>
            <param name="maxIterations">[Optional] Maximum number of iterations, the computation will exit after that many iterations, default: 10.000</param>
            <param name="outCenters">[Input/Output/Optional] If not null on entry, outCenters will contain the centers of the clusters found, default: null</param>
            <returns>Vector of length n with indices of the clusters which were assigned to each datapoint</returns>
            <remarks><para>If <paramref name="outCenters"/> is given not null on input, the algorithm returns the computed centers in that parameter. A 
            matrix may be given on input, in order to give a hint of the initial center positions. This may help to find correct cluster centers - even if 
            the initial hint is not exact. In order to do so, the matrix given must be of the correct size (X.D[0] by k) and <paramref name="centerInitRandom"/>
            must be set to <c>false</c>.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.kMeansClust(ILNumerics.ILInArray{System.Single},ILNumerics.ILBaseArray,System.Int32,System.Boolean,ILNumerics.ILOutArray{System.Single})">
            <summary>
            k-means clustering: find clusters in data matrix X
            </summary>
            <param name="X">Data matrix, data points are given as columns</param>
            <param name="k">Initial number of clusters</param>
            <param name="centerInitRandom">[Optional] false: pick the first k data points as initial centers, true: pick random datapoints (default)</param>
            <param name="maxIterations">[Optional] Maximum number of iterations, the computation will exit after that many iterations, default: 10.000</param>
            <param name="outCenters">[Input/Output/Optional] If not null on entry, outCenters will contain the centers of the clusters found, default: null</param>
            <returns>Vector of length n with indices of the clusters which were assigned to each datapoint</returns>
            <remarks><para>If <paramref name="outCenters"/> is given not null on input, the algorithm returns the computed centers in that parameter. A 
            matrix may be given on input, in order to give a hint of the initial center positions. This may help to find correct cluster centers - even if 
            the initial hint is not exact. In order to do so, the matrix given must be of the correct size (X.D[0] by k) and <paramref name="centerInitRandom"/>
            must be set to <c>false</c>.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{System.Byte})">
            <summary>Absolute values of array elements</summary>
            <param name="A">Input Array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the Input Array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{System.Double})">
            <summary>Absolute values of array elements</summary>
            <param name="A">Input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{System.Single})">
            <summary>Absolute values of array elements</summary>
            <param name="A">Input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Magnitude of array elements</summary>
            <param name="A">Input array</param>
            <returns>Magnitude of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Magnitude of array elements</summary>
            <param name="A">Input array</param>
            <returns>Magnitude of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{System.Int64})">
            <summary>Absolute values of array elements</summary>
            <param name="A">Input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{System.Int32})">
            <summary>Absolute values of array elements</summary>
            <param name="A">Input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.acosc(ILNumerics.ILInArray{System.Double})">
            <summary>Arccosine of array elements - complex output</summary>
            <param name="A">Input array</param>
            <returns>Arccosine of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.acosc(ILNumerics.ILInArray{System.Single})">
            <summary>Arccosine of array elements - complex output</summary>
            <param name="A">Input array</param>
            <returns>Arccosine of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.acos(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Arccosine values of array elements</summary>
            <param name="A">Input array</param>
            <returns>Arccosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.acos(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Arccosine values of array elements</summary>
            <param name="A">Input array</param>
            <returns>Arccosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.acos(ILNumerics.ILInArray{System.Single})">
            <summary>Arccosine of array elements - real output</summary>
            <param name="A">Input array</param>
            <returns>Arccosine of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.acos(ILNumerics.ILInArray{System.Double})">
            <summary>Arccosine of array elements - real output</summary>
            <param name="A">Input array</param>
            <returns>Arccosine of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Add arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise sum of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Add arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise sum of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Add arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise sum of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Add arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise sum of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Add arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise sum of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Add arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise sum of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Add arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise sum of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>Determine, if all elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Int64},System.Int32)">
            <summary>Determine, if all elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Int32},System.Int32)">
            <summary>Determine, if all elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Byte},System.Int32)">
            <summary>Determine, if all elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>Determine, if all elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>Determine, if all elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>Determine, if all elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{System.Double})">
            <summary>Determine if array has nonzero elements in all dimensions</summary>
            <param name="A">Input Array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned. </para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{System.Int64})">
            <summary>Determine if array has nonzero elements in all dimensions</summary>
            <param name="A">Input Array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned. </para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{System.Int32})">
            <summary>Determine if array has nonzero elements in all dimensions</summary>
            <param name="A">Input Array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned. </para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{System.Byte})">
            <summary>Determine if array has nonzero elements in all dimensions</summary>
            <param name="A">Input Array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned. </para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Determine if array has nonzero elements in all dimensions</summary>
            <param name="A">Input Array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned. </para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{System.Single})">
            <summary>Determine if array has nonzero elements in all dimensions</summary>
            <param name="A">Input Array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned. </para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Determine if array has nonzero elements in all dimensions</summary>
            <param name="A">Input Array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned. </para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'and' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'and' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'and' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'and' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'and' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'and' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'and' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>Determine, if any elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Int64},System.Int32)">
            <summary>Determine, if any elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Int32},System.Int32)">
            <summary>Determine, if any elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Byte},System.Int32)">
            <summary>Determine, if any elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>Determine, if any elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>Determine, if any elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>Determine, if any elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{System.Double})">
            <summary>
            Determine if array has any nonzero elements
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Determine if array has any nonzero elements
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Determine if array has any nonzero elements
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Determine if array has any nonzero elements
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Determine if array has any nonzero elements
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{System.Single})">
            <summary>
            Determine if array has any nonzero elements
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Determine if array has any nonzero elements
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.apply(System.Func{System.Double,System.Double,System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Apply an arbitrary function to two arrays</summary>
            <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>The combination of A and B. The result and size depends on the inputs:<list type="table">
            <item>
                <term>size(A) == size(B)</term>
                <description>Same size as A/B, elementwise combination of A and B.</description>
            </item>
            <item>
                <term>isscalar(A) || isscalar(B)</term>
                <description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description>
            </item>
            <item>
                <term>All other cases</term>
                <description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description>
            </item>
            </list></returns>
        </member>
        <member name="M:ILNumerics.ILMath.apply(System.Func{System.Single,System.Single,System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Apply an arbitrary function to two arrays</summary>
            <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>The combination of A and B. The result and size depends on the inputs:<list type="table">
            <item>
                <term>size(A) == size(B)</term>
                <description>Same size as A/B, elementwise combination of A and B.</description>
            </item>
            <item>
                <term>isscalar(A) || isscalar(B)</term>
                <description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description>
            </item>
            <item>
                <term>All other cases</term>
                <description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description>
            </item>
            </list></returns>
        </member>
        <member name="M:ILNumerics.ILMath.apply(System.Func{ILNumerics.fcomplex,ILNumerics.fcomplex,ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Apply an arbitrary function to two arrays</summary>
            <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>The combination of A and B. The result and size depends on the inputs:<list type="table">
            <item>
                <term>size(A) == size(B)</term>
                <description>Same size as A/B, elementwise combination of A and B.</description>
            </item>
            <item>
                <term>isscalar(A) || isscalar(B)</term>
                <description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description>
            </item>
            <item>
                <term>All other cases</term>
                <description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description>
            </item>
            </list></returns>
        </member>
        <member name="M:ILNumerics.ILMath.apply(System.Func{ILNumerics.complex,ILNumerics.complex,ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Apply an arbitrary function to two arrays</summary>
            <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>The combination of A and B. The result and size depends on the inputs:<list type="table">
            <item>
                <term>size(A) == size(B)</term>
                <description>Same size as A/B, elementwise combination of A and B.</description>
            </item>
            <item>
                <term>isscalar(A) || isscalar(B)</term>
                <description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description>
            </item>
            <item>
                <term>All other cases</term>
                <description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description>
            </item>
            </list></returns>
        </member>
        <member name="M:ILNumerics.ILMath.apply(System.Func{System.Int64,System.Int64,System.Int64},ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Apply an arbitrary function to two arrays</summary>
            <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>The combination of A and B. The result and size depends on the inputs:<list type="table">
            <item>
                <term>size(A) == size(B)</term>
                <description>Same size as A/B, elementwise combination of A and B.</description>
            </item>
            <item>
                <term>isscalar(A) || isscalar(B)</term>
                <description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description>
            </item>
            <item>
                <term>All other cases</term>
                <description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description>
            </item>
            </list></returns>
        </member>
        <member name="M:ILNumerics.ILMath.apply(System.Func{System.Int32,System.Int32,System.Int32},ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Apply an arbitrary function to two arrays</summary>
            <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>The combination of A and B. The result and size depends on the inputs:<list type="table">
            <item>
                <term>size(A) == size(B)</term>
                <description>Same size as A/B, elementwise combination of A and B.</description>
            </item>
            <item>
                <term>isscalar(A) || isscalar(B)</term>
                <description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description>
            </item>
            <item>
                <term>All other cases</term>
                <description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description>
            </item>
            </list></returns>
        </member>
        <member name="M:ILNumerics.ILMath.apply(System.Func{System.Byte,System.Byte,System.Byte},ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Apply an arbitrary function to two arrays</summary>
            <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>The combination of A and B. The result and size depends on the inputs:<list type="table">
            <item>
                <term>size(A) == size(B)</term>
                <description>Same size as A/B, elementwise combination of A and B.</description>
            </item>
            <item>
                <term>isscalar(A) || isscalar(B)</term>
                <description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description>
            </item>
            <item>
                <term>All other cases</term>
                <description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description>
            </item>
            </list></returns>
        </member>
        <member name="M:ILNumerics.ILMath.array``1(``0,ILNumerics.ILSize)">
            <summary>
            Create new array, fill elements with constant value
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="value">Constant value for all elements</param>
            <param name="size">Size of new array</param>
            <returns>New array according to size with all elements set to 'value'</returns>
        </member>
        <member name="M:ILNumerics.ILMath.array``1(``0,System.Int32[])">
            <summary>
            Create new array, fill element with constant value
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="value">Constant value for all elements</param>
            <param name="size">Size of new array</param>
            <returns>New array according to size with all elements set to 'value'</returns>
        </member>
        <member name="M:ILNumerics.ILMath.array``1(``0[],System.Int32[])">
            <summary>
            Create array, given elements and size
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="elements">System.Array of predefined elements</param>
            <param name="size">Size of every dimension for the new array, must correspond to the number of elements in <paramref name="elements"/>.</param>
            <returns>Newly created array</returns>
            <remarks><para>The System.Array given as <paramref name="elements"/>is taken 
            as storage for the new array without copy. Make sure not to reference that 
            System.Array directly afterwards.</para>
            <para>In order to prevent for memory leaks on long runnning algorithms, <c>System.Array</c>s should 
            not get created via the 'new' keyword - but fetched from the ILMemoryPool. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.array``1(``0[],ILNumerics.ILSize)">
            <summary>
            Create array, given elements and size
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="elements">System.Array of predefined elements</param>
            <param name="size">Size of the new array, must correspond to the number of elements in <paramref name="elements"/>.</param>
            <returns>Newly created array</returns>
            <remarks><para>The System.Array given as <paramref name="elements"/>is taken 
            as storage for the new array without copy. Make sure not to reference that 
            System.Array directly afterwards.</para>
            <para>In order to prevent for memory leaks on long runnning algorithms, <c>System.Array</c>s should 
            not get created via the 'new' keyword - but fetched from the ILMemoryPool. 
            </para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.array``1(ILNumerics.ILSize,``0[])">
            <summary>
            Create array, given elements and size
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="elements">Variable argument list with elements</param>
            <param name="size">Size of the new array, must correspond to the number of elements in <paramref name="elements"/>.</param>
            <returns>Newly created array</returns>
            <remarks><para>The elements given as <paramref name="elements"/> are used 
            for the new array without copy. For <typeparamref name="T"/> being a reference type, make sure not to reference any  
            elements directly afterwards.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.array``1(``0[])">
            <summary>
            Create column vector from given elements 
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="elements">List of elements</param>
            <returns>Newly created vector with elements given</returns>
            <remarks><para>If an System.Array was given as params argument, the array is directly taken 
            as storage for the new array without copy. Make sure not to reference the 
            System.Array directly afterwards!</para>
            <para>In order to prevent for memory leaks on long runnning algorithms, <c>System.Array</c>s should 
            not get created via the 'new' keyword - but fetched from the ILMemoryPool.</para>
            <para>The shape of the vector created is controlled by the setting switch <see cref="P:ILNumerics.Settings.CreateRowVectorsByDefault"/>.
            This switch defaults to <c>false</c> which will cause the creation of a column vector. </para></remarks>
            <see cref="M:ILNumerics.ILMath.row``1(``0[])"/>
            <see cref="M:ILNumerics.ILMath.column``1(``0[])"/>
        </member>
        <member name="M:ILNumerics.ILMath.row``1(``0[])">
            <summary>
            Create row vector
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="elements">Elements of the row vector</param>
            <returns>New row vector</returns>
        </member>
        <member name="M:ILNumerics.ILMath.column``1(``0[])">
            <summary>
            Create column vector
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="elements">Elements of the column vector</param>
            <returns>New column vector</returns>
        </member>
        <member name="M:ILNumerics.ILMath.asinc(ILNumerics.ILInArray{System.Single})">
            <summary>Arcsine of array elements - complex output</summary>
            <param name="A">Input array</param>
            <returns>Arcsine of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.asinc(ILNumerics.ILInArray{System.Double})">
            <summary>Arcsine of array elements - complex output</summary>
            <param name="A">Input array</param>
            <returns>Arcsine of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.asin(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Arcsine values of array elements</summary>
            <param name="A">Input array</param>
            <returns>Arcsine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.asin(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Arcsine values of array elements</summary>
            <param name="A">Input array</param>
            <returns>Arcsine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.asin(ILNumerics.ILInArray{System.Single})">
            <summary>Arcsine of array elements - real output</summary>
            <param name="A">Input array</param>
            <returns>Arcsine of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.asin(ILNumerics.ILInArray{System.Double})">
            <summary>Arcsine of array elements - real output</summary>
            <param name="A">Input array</param>
            <returns>Arcsine of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.atan(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Arctangent of array elements</summary>
            <param name="A">Input array</param>
            <returns>Arctangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.atan(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Arctangent of array elements</summary>
            <param name="A">Input array</param>
            <returns>Arctangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.atan(ILNumerics.ILInArray{System.Single})">
            <summary>Arctangent of array elements</summary>
            <param name="A">Input array</param>
            <returns>Arctangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.atan(ILNumerics.ILInArray{System.Double})">
            <summary>Arctangent of array elements </summary>
            <param name="A">Input array</param>
            <returns>Arctangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.atan2(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Arcus tangens of elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise arcus tangens of both inputs</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.atan2(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Arcus tangens of elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise arcus tangens of both inputs</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.cart2pol(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Transform scalar coordinates into polar (cylindrical) coordinates
            </summary>
            <param name="X">X coordinates</param>
            <param name="Y">Y coordinates</param>
            <param name="Z">Z coordinates (height)</param>
            <param name="outRadius">[Output] Radius if not null on entry</param>
            <param name="outZ">[Output] Z if not null on entry</param>
            <returns>Angles; radius and Z are returned as output parameters, if on entry not null</returns>
            <remarks>Theta, radius and Z must be the same size or either one may be scalar. 
            Polar coordinate arrays returned are of the same size then the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cart2pol(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Transform scalar coordinates into polar (cylindrical) coordinates
            </summary>
            <param name="X">X coordinates</param>
            <param name="Y">Y coordinates</param>
            <param name="Z">Z coordinates (height)</param>
            <param name="outRadius">[Output] Radius if not null on entry</param>
            <param name="outZ">[Output] Z if not null on entry</param>
            <returns>Angles; radius and Z are returned as output parameters, if on entry not null</returns>
            <remarks>Theta, radius and Z must be the same size or either one may be scalar. 
            Polar coordinate arrays returned are of the same size then the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ccomplex(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Create complex array from real and imaginary parts 
            </summary>
            <param name="real">Array with real part elements</param>
            <param name="imag">Array with imaginary part elements</param>
            <returns>Complex array constructed out of real and imaginary parts</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arguments is not the same and neither of 
            the input is scalar.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ccomplex(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Create complex array from real and imaginary parts
            </summary>
            <param name="real">Array with real part elements</param>
            <param name="imag">Array with imaginary part elements</param>
            <returns>Complex array constructed out of real and imaginary parts</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arguments is not the same and neither of 
            the input is scalar.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ceil(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Round towards positive infinity</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded up to next integer value</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ceil(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Round towards positive infinity</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded up to next integer value</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ceil(ILNumerics.ILInArray{System.Single})">
            <summary>Round towards positive infinity</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded up to next integer value</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ceil(ILNumerics.ILInArray{System.Double})">
            <summary>Round towards positive infinity</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded up to next integer value</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cell(ILNumerics.ILBaseArray[])">
            <summary>
            Create a cell row vector from given arrays 
            </summary>
            <param name="arrays">Arrays to be copied inside the cell</param>
            <returns>Cell vector</returns>
            <remarks><para>The new cell will be created as vector, having the array 'values' given as parameter as cell elements. Those elements will 
            be protected by changes from outside the cell.</para>
            <para>Visit the <a href="http://ilnumerics.net/$Cells.html" target="ILMain">online documentation</a> for cell.</para></remarks>
            <example>
            <para>A common use of the <c>cell</c> function is the concatenation of arrays and constants for subarray definitions, as shown in the following example:</para>
            <code>
            ILArray&lt;double&gt; A = counter(4,3,2); 
            A
            //&lt;Double&gt; [4,3]
            // 1          5          9 
            // 2          6         10 
            // 3          7         11 
            // 4          8         12 
            
            // extract 1st, 2nd and last row:
            ILArray&lt;double&gt; B = A[cell(0,1,end),full]; 
            B
            //&lt;Double&gt; [3,3]
            // 1          5          9 
            // 2          6         10 
            // 4          8         12 
            </code>
            <para>Here, <c>cell</c> is used to concatenate individual indices determining the rows to select for the subarray. Using a cell here is convenient, because arbitrary types 
            can be stored in cells - integer, floating point types or special placeholders, like expressions (<see cref="P:ILNumerics.ILMath.end"/> and <see cref="P:ILNumerics.ILMath.full"/>).</para>
            </example>
        </member>
        <member name="M:ILNumerics.ILMath.cell(ILNumerics.ILSize,ILNumerics.ILBaseArray[])">
            <summary>
            Create cell, initialize with arrays and size
            </summary>
            <param name="size">Size of the new cell</param>
            <param name="arrays">List of arrays for the cell elements, column major order</param>
            <returns>Cell of specified size, initialized with arrays</returns>
            <remarks>If number of arrays given is smaller than the number of elements given by <paramref name="size"/>, trailing 
            elements in the cell returned will be set to null.
            <para>The <see cref="M:ILNumerics_ILMath_size(params int[])"/> function is convenient for the specification of size descriptors.</para>
            <para>Visit the <a href="http://ilnumerics.net/$Cells.html" target="ILMain">online documentation</a> for cell.</para></remarks>
            <example>
            <code>
            ILArray&lt;double> A = rand(10,20,30); 
            ILCell C = cell(size(3,2),A, A+1, zeros(2,3)); 
            C
            //Cell [3,2]
            // &lt;Double> [10,20,30]          &lt;String>        4th element  
            // &lt;Double> [10,20,30]                                 (null)
            // &lt;Double> [2,3]                                      (null)
            </code>
            </example>
        </member>
        <member name="M:ILNumerics.ILMath.cell(ILNumerics.ILBaseArray[],System.Int32[])">
            <summary>
            Create cell, initialize with arrays and size
            </summary>
            <param name="arrays">Predefined array with arrays, directly be used as new cell element storage</param>
            <param name="size">Size of newly created cell</param>
            <returns>Cell with size of <paramref name="size"/> and elements from <paramref name="arrays"/></returns>
            <remarks>The array given in <paramref name="arrays"/> is directly be used for the newly created cell. Make sure, not 
            to reference the system array afterwards. However, arrays  referenced from within the parameter <paramref name="arrays"/> 
            are stored as clone into the new cell. Therefore, those arrays are properly protected from changes by altering any array outside the cell.
            <para>Visit the <a href="http://ilnumerics.net/$Cells.html" target="ILMain">online documentation</a> for cell.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.cell(ILNumerics.ILBaseArray[])"/>
        </member>
        <member name="M:ILNumerics.ILMath.check``1(ILNumerics.ILInArray{``0},System.Func{ILNumerics.ILInArray{``0},ILNumerics.ILRetArray{``0}},System.Boolean,System.String,ILNumerics.ILInArray{``0})">
            <summary>
            Check if A is a valid parameter
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="A">Input parameter</param>
            <param name="ErrorMessage">[optional] Exception message</param>
            <param name="evaluation">[optional] Evaluation function, checks input parameter and transforms it into result, gets only called for A other than null</param>
            <param name="allowNullInput">[optional] Only if A is null -&gt; for true: returns null, false: throws exception. If <paramref name="Default"/> was defined, this parameter is ignored.</param>
            <param name="Default">[optional] If <paramref name="A"/> is null on input, this value is returned. If no default is given (i.e: null), <paramref name="allowNullInput"/> is evaluated.</param>
            <returns>Result of evaluation(A) or A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null on entry and <paramref name="allowNullInput"/> is false</exception>
        </member>
        <member name="M:ILNumerics.ILMath.check(ILNumerics.ILInLogical,System.Func{ILNumerics.ILInLogical,ILNumerics.ILRetLogical},System.Boolean,System.String)">
            <summary>
            Check if A is a valid parameter
            </summary>
            <param name="A">Input parameter</param>
            <param name="ErrorMessage">[optional] Exception message</param>
            <param name="evaluation">[optional] Evaluation function, checks input parameter and transforms it into result, gets only called for A other than null</param>
            <param name="allowNullInput">[optional] Only if A is null -&gt; for true: returns null, false: throws exception</param>
            <returns>Result of evaluation(A) or A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null on entry and <paramref name="allowNullInput"/> is false</exception>
        </member>
        <member name="M:ILNumerics.ILMath.check(ILNumerics.ILInCell,System.Func{ILNumerics.ILInCell,ILNumerics.ILRetCell},System.Boolean,System.String)">
            <summary>
            Check if A is a valid parameter
            </summary>
            <param name="A">Input parameter</param>
            <param name="ErrorMessage">[Optional] Exception message</param>
            <param name="evaluation">[Optional] Evaluation function, checks input parameter and transforms it into result, gets only called for A other than null</param>
            <param name="allowNullInput">[Optional] Only if A is null -&gt; true: returns null, false: throws exception</param>
            <returns>Result of evaluation(A) or A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null on entry and <paramref name="allowNullInput"/> is false</exception>
        </member>
        <member name="M:ILNumerics.ILMath.chol(ILNumerics.ILInArray{System.Double},System.Boolean)">
            <summary>Cholesky factorization</summary>
            <param name="A">Input array A. A must be a symmetric/hermitian matrix. 
            Therefore the upper triangular part of A must be the transpose (complex conjugate for complex input) of the lower triangular part. No check 
            is made for that! <br/> 
            The elements of A will not be altered.</param>
            <param name="throwException">Throw an ILArgumentException if A 
            is found not to be positive definite.</param>
            <returns>Cholesky factorization</returns>
            <remarks><para>If <paramref name="throwException"/> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
            <para>If <paramref name="throwException"/> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not to be positive definite the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A at which A was found to be not positive definite.</para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.chol(ILNumerics.ILInArray{System.Single},System.Boolean)">
            <summary>Cholesky factorization</summary>
            <param name="A">Input array A. A must be a symmetric/hermitian matrix. 
            Therefore the upper triangular part of A must be the transpose (complex conjugate for complex input) of the lower triangular part. No check 
            is made for that! <br/> 
            The elements of A will not be altered.</param>
            <param name="throwException">Throw an ILArgumentException if A 
            is found not to be positive definite.</param>
            <returns>Cholesky factorization</returns>
            <remarks><para>If <paramref name="throwException"/> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
            <para>If <paramref name="throwException"/> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not to be positive definite the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A at which A was found to be not positive definite.</para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.chol(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Boolean)">
            <summary>Cholesky factorization</summary>
            <param name="A">Input array A. A must be a symmetric/hermitian matrix. 
            Therefore the upper triangular part of A must be the transpose (complex conjugate for complex input) of the lower triangular part. No check 
            is made for that! <br/> 
            The elements of A will not be altered.</param>
            <param name="throwException">Throw an ILArgumentException if A 
            is found not to be positive definite.</param>
            <returns>Cholesky factorization</returns>
            <remarks><para>If <paramref name="throwException"/> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
            <para>If <paramref name="throwException"/> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not to be positive definite the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A at which A was found to be not positive definite.</para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.chol(ILNumerics.ILInArray{ILNumerics.complex},System.Boolean)">
            <summary>Cholesky factorization</summary>
            <param name="A">Input array A. A must be a symmetric/hermitian matrix. 
            Therefore the upper triangular part of A must be the transpose (complex conjugate for complex input) of the lower triangular part. No check 
            is made for that! <br/> 
            The elements of A will not be altered.</param>
            <param name="throwException">Throw an ILArgumentException if A 
            is found not to be positive definite.</param>
            <returns>Cholesky factorization</returns>
            <remarks><para>If <paramref name="throwException"/> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
            <para>If <paramref name="throwException"/> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not to be positive definite the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A at which A was found to be not positive definite.</para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.conj(ILNumerics.ILInArray{System.Double})">
            <summary>
            Complex conjugate of A
            </summary>
            <param name="A">Input array</param>
            <returns>The array itself</returns>
            <remarks>This overload is provided for convenience only. It eases the implementation of complex functions, where complex conjugate transposes are needed.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.conj(ILNumerics.ILInArray{System.Single})">
            <summary>
            Complex conjugate of A
            </summary>
            <param name="A">Input array</param>
            <returns>The array itself</returns>
            <remarks>This overload is provided for convenience only. It eases the implementation of complex functions, where complex conjugate transposes are needed.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.conj(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Complex conjugate of array A</summary>
            <param name="A">Input array</param>
            <returns>Complex conjugate of array A</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.conj(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Complex conjugate of array A</summary>
            <param name="A">Input array</param>
            <returns>Complex conjugate of array A</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.convert``2(ILNumerics.ILInArray{``0})">
            <summary>
            Convert a numeric array to another numeric type
            </summary>
            <param name="X">Input array</param>
            <typeparam name="inT">Type of array to convert</typeparam>
            <typeparam name="outT">Type of array to return</typeparam>
            <returns>Converted array</returns>
            <remarks> The newly created array will be converted to the required type. 
            <para>The array returned will always use new memory! Even if the type requested 
            matches the incoming type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to double array
            </summary>
            <param name="X">Input array</param>
            <returns>double array</returns>
            <remarks><para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to float array
            </summary>
            <param name="X">Input array</param>
            <returns>float array</returns>
            <remarks><para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to complex array
            </summary>
            <param name="X">Input array </param>
            <returns>complex array</returns>
            <remarks><para>Real input arrays will be converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to fcomplex array
            </summary>
            <param name="X">Input array </param>
            <returns>fcomplex array</returns>
            <remarks>
            <para>Real input arrays are converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to byte array
            </summary>
            <param name="X">Input array </param>
            <returns>byte array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to logical array
            </summary>
            <param name="X">Input array </param>
            <returns>Logical array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to Int64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to UInt64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.UInt64})">
            <summary>
            Convert numeric array to double array
            </summary>
            <param name="X">Input array</param>
            <returns>double array</returns>
            <remarks><para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.UInt64})">
            <summary>
            Convert numeric array to float array
            </summary>
            <param name="X">Input array</param>
            <returns>float array</returns>
            <remarks><para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.UInt64})">
            <summary>
            Convert numeric array to complex array
            </summary>
            <param name="X">Input array </param>
            <returns>complex array</returns>
            <remarks><para>Real input arrays will be converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.UInt64})">
            <summary>
            Convert numeric array to fcomplex array
            </summary>
            <param name="X">Input array </param>
            <returns>fcomplex array</returns>
            <remarks>
            <para>Real input arrays are converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.UInt64})">
            <summary>
            Convert numeric array to byte array
            </summary>
            <param name="X">Input array </param>
            <returns>byte array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.UInt64})">
            <summary>
            Convert numeric array to logical array
            </summary>
            <param name="X">Input array </param>
            <returns>Logical array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{System.UInt64})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.UInt64})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.UInt64})">
            <summary>
            Convert numeric array to Int64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{System.UInt64})">
            <summary>
            Convert numeric array to UInt64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to double array
            </summary>
            <param name="X">Input array</param>
            <returns>double array</returns>
            <remarks><para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to float array
            </summary>
            <param name="X">Input array</param>
            <returns>float array</returns>
            <remarks><para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to complex array
            </summary>
            <param name="X">Input array </param>
            <returns>complex array</returns>
            <remarks><para>Real input arrays will be converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to fcomplex array
            </summary>
            <param name="X">Input array </param>
            <returns>fcomplex array</returns>
            <remarks>
            <para>Real input arrays are converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to byte array
            </summary>
            <param name="X">Input array </param>
            <returns>byte array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to logical array
            </summary>
            <param name="X">Input array </param>
            <returns>Logical array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to Int64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to UInt64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to double array
            </summary>
            <param name="X">Input array</param>
            <returns>double array</returns>
            <remarks><para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to float array
            </summary>
            <param name="X">Input array</param>
            <returns>float array</returns>
            <remarks><para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to complex array
            </summary>
            <param name="X">Input array </param>
            <returns>complex array</returns>
            <remarks><para>Real input arrays will be converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to fcomplex array
            </summary>
            <param name="X">Input array </param>
            <returns>fcomplex array</returns>
            <remarks>
            <para>Real input arrays are converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to byte array
            </summary>
            <param name="X">Input array </param>
            <returns>byte array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to logical array
            </summary>
            <param name="X">Input array </param>
            <returns>Logical array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to Int64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to UInt64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Int16})">
            <summary>
            Convert numeric array to double array
            </summary>
            <param name="X">Input array</param>
            <returns>double array</returns>
            <remarks><para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Int16})">
            <summary>
            Convert numeric array to float array
            </summary>
            <param name="X">Input array</param>
            <returns>float array</returns>
            <remarks><para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Int16})">
            <summary>
            Convert numeric array to complex array
            </summary>
            <param name="X">Input array </param>
            <returns>complex array</returns>
            <remarks><para>Real input arrays will be converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Int16})">
            <summary>
            Convert numeric array to fcomplex array
            </summary>
            <param name="X">Input array </param>
            <returns>fcomplex array</returns>
            <remarks>
            <para>Real input arrays are converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Int16})">
            <summary>
            Convert numeric array to byte array
            </summary>
            <param name="X">Input array </param>
            <returns>byte array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Int16})">
            <summary>
            Convert numeric array to logical array
            </summary>
            <param name="X">Input array </param>
            <returns>Logical array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{System.Int16})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Int16})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Int16})">
            <summary>
            Convert numeric array to Int64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{System.Int16})">
            <summary>
            Convert numeric array to UInt64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to double array
            </summary>
            <param name="X">Input array</param>
            <returns>double array</returns>
            <remarks><para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to float array
            </summary>
            <param name="X">Input array</param>
            <returns>float array</returns>
            <remarks><para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to complex array
            </summary>
            <param name="X">Input array </param>
            <returns>complex array</returns>
            <remarks><para>Real input arrays will be converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to fcomplex array
            </summary>
            <param name="X">Input array </param>
            <returns>fcomplex array</returns>
            <remarks>
            <para>Real input arrays are converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to byte array
            </summary>
            <param name="X">Input array </param>
            <returns>byte array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to logical array
            </summary>
            <param name="X">Input array </param>
            <returns>Logical array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to Int64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to UInt64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to double array
            </summary>
            <param name="X">Input array</param>
            <returns>double array</returns>
            <remarks><para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to float array
            </summary>
            <param name="X">Input array</param>
            <returns>float array</returns>
            <remarks><para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to complex array
            </summary>
            <param name="X">Input array </param>
            <returns>complex array</returns>
            <remarks><para>Real input arrays will be converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to fcomplex array
            </summary>
            <param name="X">Input array </param>
            <returns>fcomplex array</returns>
            <remarks>
            <para>Real input arrays are converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to byte array
            </summary>
            <param name="X">Input array </param>
            <returns>byte array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to logical array
            </summary>
            <param name="X">Input array </param>
            <returns>Logical array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to Int64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to UInt64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to double array
            </summary>
            <param name="X">Input array</param>
            <returns>double array</returns>
            <remarks><para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to float array
            </summary>
            <param name="X">Input array</param>
            <returns>float array</returns>
            <remarks><para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to complex array
            </summary>
            <param name="X">Input array </param>
            <returns>complex array</returns>
            <remarks><para>Real input arrays will be converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to fcomplex array
            </summary>
            <param name="X">Input array </param>
            <returns>fcomplex array</returns>
            <remarks>
            <para>Real input arrays are converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to byte array
            </summary>
            <param name="X">Input array </param>
            <returns>byte array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to logical array
            </summary>
            <param name="X">Input array </param>
            <returns>Logical array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to Int64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to UInt64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to double array
            </summary>
            <param name="X">Input array</param>
            <returns>double array</returns>
            <remarks><para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to float array
            </summary>
            <param name="X">Input array</param>
            <returns>float array</returns>
            <remarks><para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to complex array
            </summary>
            <param name="X">Input array </param>
            <returns>complex array</returns>
            <remarks><para>Real input arrays will be converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to fcomplex array
            </summary>
            <param name="X">Input array </param>
            <returns>fcomplex array</returns>
            <remarks>
            <para>Real input arrays are converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to byte array
            </summary>
            <param name="X">Input array </param>
            <returns>byte array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to logical array
            </summary>
            <param name="X">Input array </param>
            <returns>Logical array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to Int64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to UInt64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILBaseArray)">
            <summary>
            convert arbitrary numeric array to double array
            </summary>
            <param name="X">numeric array, one of supported numeric type</param>
            <returns>double array</returns>
            <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
        </member>
        <member name="M:ILNumerics.ILMath.touint64(ILNumerics.ILBaseArray)">
            <summary>convert arbitrary numeric array to UInt64 array</summary>
            <param name="X">numeric array, one of supported numeric type</param>
            <returns>UInt64 (ulong) array</returns>
            <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILBaseArray)">
            <summary>convert arbitrary numeric array to Int64 array</summary>
            <param name="X">numeric array, one of supported numeric type</param>
            <returns>Int64 (long) array</returns>
            <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILBaseArray)">
            <summary>convert arbitrary numeric array to Int32 array</summary>
            <param name="X">numeric array, one of supported numeric type</param>
            <returns>Int32 (int) array</returns>
            <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
        </member>
        <member name="M:ILNumerics.ILMath.toint16(ILNumerics.ILBaseArray)">
            <summary>convert arbitrary numeric array to Int16 array</summary>
            <param name="X">numeric array, one of supported numeric type</param>
            <returns>Int16 (short) array</returns>
            <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILBaseArray)">
            <summary>convert arbitrary numeric array to byte array</summary>
            <param name="X">numeric array, one of supported numeric type</param>
            <returns>byte array</returns>
            <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILBaseArray)">
            <summary>convert arbitrary numeric array to fcomplex array</summary>
            <param name="X">numeric array, one of supported numeric type</param>
            <returns>fcomplex array</returns>
            <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILBaseArray)">
            <summary>convert arbitrary numeric array to complex array</summary>
            <param name="X">numeric array, one of supported numeric type</param>
            <returns>complex array</returns>
            <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILBaseArray)">
            <summary>convert arbitrary numeric array to float array</summary>
            <param name="X">numeric array, one of supported numeric type</param>
            <returns>Single (float) array</returns>
            <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
        </member>
        <member name="M:ILNumerics.ILMath.cos(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Cosine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cos(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Cosine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cos(ILNumerics.ILInArray{System.Single})">
            <summary>Cosine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cos(ILNumerics.ILInArray{System.Double})">
            <summary>Cosine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cosh(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Hyperbolic cosine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cosh(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Hyperbolic cosine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cosh(ILNumerics.ILInArray{System.Single})">
            <summary>Hyperbolic cosine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cosh(ILNumerics.ILInArray{System.Double})">
            <summary>Hyperbolic cosine of array elements </summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.counter(ILNumerics.ILBaseArray[])">
            <summary>
            Create n-dimensional array with elements counting from 1, double precision
            </summary>
            <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
            <returns>Double array with elements counting from 1 to dimensions.NumberOfElements</returns>
            <remarks>This function may be used for the convenient creation of arrays for testing purposes.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.counter(System.Int32[])">
            <summary>
            Create n-dimensional array with elements counting from 1, double precision
            </summary>
            <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
            <returns>Double array with elements counting from 1 ... dimensions.NumberOfElements</returns>
            <remarks>This function may be used for the convenient creation of arrays for testing purposes.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.counter(System.Double,System.Double,ILNumerics.ILBaseArray[])">
            <summary>
            Create n-dimensional array with elements counting from 1, double precision
            </summary>
            <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
            <param name="start">Starting number</param>
            <param name="inc">Incrementing step</param>
            <returns>Double array with elements counting from start to start + (dimensions.NumberOfElements * inc)</returns>
            <remarks>This function may be used for the convenient creation of arrays for testing purposes.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.counter(System.Double,System.Double,ILNumerics.ILSize)">
            <summary>
            Create n-dimensional array with elements counting from 1, double precision
            </summary>
            <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
            <param name="start">Starting number</param>
            <param name="inc">Incrementing step</param>
            <returns>Double array with elements counting from start to start + (dimensions.NumberOfElements * inc)</returns>
            <remarks>This function may be used for the convenient creation of arrays for testing purposes.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.counter(ILNumerics.ILSize)">
            <summary>
            Create n-dimensional array with elements counting from 1, double precision
            </summary>
            <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
            <returns>Double array with elements counting from 1 ... dimensions.NumberOfElements</returns>
            <remarks>This function may be used for the convenient creation of arrays for testing purposes.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.counter``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray[])">
            <summary>
            Create n-dimensional array with counting elements 
            </summary>
            <param name="start">Initial value</param>
            <param name="increment">Increment for each element</param>
            <param name="dimensions">Variable number of numeric, scalar arrays with dimension specification</param>
            <returns>Array with elements counting from <paramref name="start"/> along the first dimension with steps of <paramref name="increment"/>.</returns>
            <remarks>
            <example><code>
            // This will create elements counting from 1...24: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(4,3,2); 
            // This will create elements counting from 1...48 with intervals of 2.0: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(1.0,2.0,4,3,2); 
            // This will create an array with all elements having contant value of -4f:
            // (note: start, increment and dimension specifier do not need to be of the same type)
            <![CDATA[ILArray<float> A = ILMath.counter<float>(4.0,0,4,3,2);]]> 
            </code></example>  </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.counter``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILSize)">
            <summary>
            Create n-dimensional array with counting elements 
            </summary>
            <param name="start">Initial value</param>
            <param name="increment">Increment for each element</param>
            <param name="dimensions">Variable int array with dimension specification</param>
            <returns>Array with elements counting from <paramref name="start"/> to dimensions.NumberOfElements - <paramref name="start"/>.</returns>
            <remarks>
            <example><code>
            // This will create elements counting from 1...24: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(4,3,2); 
            // This will create elements counting from 1...48 with intervals of 2.0: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(1.0,2.0,4,3,2); 
            // This will create an array with all elements having contant value of -4f:
            // (note: start, increment and dimension specifier do not need to be of the same type)
            <![CDATA[ILArray<float> A = ILMath.counter<float>(4.0,0,4,3,2);]]> 
            </code></example>  </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cov(ILNumerics.ILInArray{System.Double},System.Boolean)">
            <summary>
            Covariance matrix of A
            </summary>
            <param name="A">Input vector or data matrix, samples in columns, variables in rows</param>
            <param name="unbiased">[Optional] If true, calculate the best unbiased variance estimate if the observations are from a normal distribution. This normalizes by n-1 if n>1 (n = number of samples). If n == 1 normalization is always 1. If false always normalize by n.</param>
            <returns>Variance of vector A/Covariance matrix of A</returns>
            <remarks><para>If A is a vector <c>cov(A)</c> returns the variance of A</para>
            <para>If A is a m x n matrix, where each of the n columns is an m-dimensional observation, <c>cov(A)</c> is the n x n covariance matrix.</para>
            <para>The mean is removed from each column before calculating the result.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cov(ILNumerics.ILInArray{System.Single},System.Boolean)">
            <summary>
            Covariance matrix of A
            </summary>
            <param name="A">Input vector or data matrix, samples in columns, variables in rows</param>
            <param name="unbiased">[Optional] If true, calculate the best unbiased variance estimate if the observations are from a normal distribution. This normalizes by n-1 if n>1 (n = number of samples). If n == 1 normalization is always 1. If false always normalize by n.</param>
            <returns>Variance of vector A/Covariance matrix of A</returns>
            <remarks><para>If A is a vector <c>cov(A)</c> returns the variance of A</para>
            <para>If A is a m x n matrix, where each of the n columns is an m-dimensional observation, <c>cov(A)</c> is the n x n covariance matrix.</para>
            <para>The mean is removed from each column before calculating the result.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cross(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Boolean)">
            <summary>
            Cross products of columns of two arrays 
            </summary>
            <param name="A">First array with vectors in columns</param>
            <param name="B">Second array with vectors in columns</param>
            <returns>Array with cross products of vectors from A and B</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arguments is not the same.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.cross(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Boolean)">
            <summary>
            Cross products of columns of two arrays 
            </summary>
            <param name="A">First array with vectors in columns</param>
            <param name="B">Second array with vectors in columns</param>
            <returns>Array with cross products of vectors from A and B</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arguments is not the same.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.csvread``1(System.String,System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Read comma seperated values from lines in a string
            </summary>
            <typeparam name="T">Element type to return</typeparam>
            <param name="csvData">string with CSV in lines</param>
            <param name="startRow">[optional] start reading the values from that lines, default: 0</param>
            <param name="startCol">[optional] start reading values from that column, default: 0</param>
            <param name="endRow">[optional] index of the last row to take into account, default: last row in <paramref name="csvData"/></param>
            <param name="endCol">[optional] index of the last column to take into account, default: last column in <paramref name="csvData"/></param>
            <returns>matrix with elements read from <paramref name="csvData"/></returns>
        </member>
        <member name="M:ILNumerics.ILMath.csvwrite``1(ILNumerics.ILInArray{``0},System.IO.Stream)">
            <summary>
            Write ILNumerics array as comma separated values to stream
            </summary>
            <typeparam name="T">Element type of input array A</typeparam>
            <param name="A">ILNumerics array to write as CSV</param>
            <param name="stream">stream to write comma separated values into</param>
        </member>
        <member name="M:ILNumerics.ILMath.csvwrite``1(ILNumerics.ILInArray{``0},System.String)">
            <summary>
            Write ILNumerics array as comma separated values to stream
            </summary>
            <typeparam name="T">Element type of input array A</typeparam>
            <param name="A">ILNumerics array to write as CSV</param>
            <param name="filename">name of the file to write values into</param>
        </member>
        <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            Cumulative product along elements
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length > 1).</param>
            <returns>Array of the same size as A with cumulative products of elements in A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.ILInArray{System.Int64},System.Int32)">
            <summary>
            Cumulative product along elements
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length > 1).</param>
            <returns>Array of the same size as A with cumulative products of elements in A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.ILInArray{System.Int32},System.Int32)">
            <summary>
            Cumulative product along elements
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length > 1).</param>
            <returns>Array of the same size as A with cumulative products of elements in A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.ILInArray{System.Byte},System.Int32)">
            <summary>
            Cumulative product along elements
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length > 1).</param>
            <returns>Array of the same size as A with cumulative products of elements in A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Cumulative product along elements
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length > 1).</param>
            <returns>Array of the same size as A with cumulative products of elements in A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            Cumulative product along elements
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length > 1).</param>
            <returns>Array of the same size as A with cumulative products of elements in A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.cumprod(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Cumulative product along elements
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumprod operates along the first non singleton dimension (i.e. length > 1).</param>
            <returns>Array of the same size as A with cumulative products of elements in A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            Cumulative sum along elements
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length > 1).</param>
            <returns>Array of the same size as A with cumulative sums of elements in A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.ILInArray{System.Int64},System.Int32)">
            <summary>
            Cumulative sum along elements
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length > 1).</param>
            <returns>Array of the same size as A with cumulative sums of elements in A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.ILInArray{System.Int32},System.Int32)">
            <summary>
            Cumulative sum along elements
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length > 1).</param>
            <returns>Array of the same size as A with cumulative sums of elements in A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.ILInArray{System.Byte},System.Int32)">
            <summary>
            Cumulative sum along elements
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length > 1).</param>
            <returns>Array of the same size as A with cumulative sums of elements in A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Cumulative sum along elements
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length > 1).</param>
            <returns>Array of the same size as A with cumulative sums of elements in A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            Cumulative sum along elements
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length > 1).</param>
            <returns>Array of the same size as A with cumulative sums of elements in A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.cumsum(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Cumulative sum along elements
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If ommited cumsum operates along the first non singleton dimension (i.e. length > 1).</param>
            <returns>Array of the same size as A with cumulative sums of elements in A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.det(ILNumerics.ILInArray{System.Double})">
             <summary>
             Determinant of square matrix
             </summary>
             <param name="A">Input matrix (square)</param>
             <returns>Determinant of A</returns>
             <remarks><para>The determinant is computed by decomposing A into upper and lower triangular part (using the LAPACK function ?getrf).<br/>
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U being an upper triangular matrix - equals the product of the diagonal elements.</para>
             <para>For scalar A, a plain copy of A is returned.</para></remarks>
             <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
        </member>
        <member name="M:ILNumerics.ILMath.det(ILNumerics.ILInArray{System.Single})">
             <summary>
             Determinant of square matrix
             </summary>
             <param name="A">Input matrix (square)</param>
             <returns>Determinant of A</returns>
             <remarks><para>The determinant is computed by decomposing A into upper and lower triangular part (using the LAPACK function ?getrf).<br/>
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U being an upper triangular matrix - equals the product of the diagonal elements.</para>
             <para>For scalar A, a plain copy of A is returned.</para></remarks>
             <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
        </member>
        <member name="M:ILNumerics.ILMath.det(ILNumerics.ILInArray{ILNumerics.fcomplex})">
             <summary>
             Determinant of square matrix
             </summary>
             <param name="A">Input matrix (square)</param>
             <returns>Determinant of A</returns>
             <remarks><para>The determinant is computed by decomposing A into upper and lower triangular part (using the LAPACK function ?getrf).<br/>
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U being an upper triangular matrix - equals the product of the diagonal elements.</para>
             <para>For scalar A, a plain copy of A is returned.</para></remarks>
             <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
        </member>
        <member name="M:ILNumerics.ILMath.det(ILNumerics.ILInArray{ILNumerics.complex})">
             <summary>
             Determinant of square matrix
             </summary>
             <param name="A">Input matrix (square)</param>
             <returns>Determinant of A</returns>
             <remarks><para>The determinant is computed by decomposing A into upper and lower triangular part (using the LAPACK function ?getrf).<br/>
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U being an upper triangular matrix - equals the product of the diagonal elements.</para>
             <para>For scalar A, a plain copy of A is returned.</para></remarks>
             <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
        </member>
        <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            Diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
            <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
            <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
            <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{System.Byte},System.Int32)">
            <summary>
            Diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
            <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{System.Int64},System.Int32)">
            <summary>
            Diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
            <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{System.Int32},System.Int32)">
            <summary>
            Diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
            <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            Diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
            <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diag``1(ILNumerics.ILInArray{``0},System.Int32)">
            <summary>
            Diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
            <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>Depending on 'X' a matrix or a vector with the elements on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{System.Double},System.Int32,System.Int32)">
            <summary>
            Take n-th derivative
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
            <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diff(System.Int32,ILNumerics.ILInArray{System.Double})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <c>dim</c></returns>
        </member>
        <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{System.Int64},System.Int32,System.Int32)">
            <summary>
            Take n-th derivative
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
            <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diff(System.Int32,ILNumerics.ILInArray{System.Int64})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <c>dim</c></returns>
        </member>
        <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{System.Int32},System.Int32,System.Int32)">
            <summary>
            Take n-th derivative
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
            <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diff(System.Int32,ILNumerics.ILInArray{System.Int32})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <c>dim</c></returns>
        </member>
        <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{System.Byte},System.Int32,System.Int32)">
            <summary>
            Take n-th derivative
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
            <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diff(System.Int32,ILNumerics.ILInArray{System.Byte})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <c>dim</c></returns>
        </member>
        <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
            <summary>
            Take n-th derivative
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
            <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diff(System.Int32,ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <c>dim</c></returns>
        </member>
        <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{System.Single},System.Int32,System.Int32)">
            <summary>
            Take n-th derivative
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
            <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diff(System.Int32,ILNumerics.ILInArray{System.Single})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <c>dim</c></returns>
        </member>
        <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            Take n-th derivative
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
            <returns>Array with first derivative of A along dimension <c>dim</c> or of first non singleton dimension respectively</returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diff(System.Int32,ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <c>dim</c></returns>
        </member>
        <member name="M:ILNumerics.ILMath.size(ILNumerics.ILBaseArray)">
            <summary>
            Size of dimensions of A 
            </summary>
            <param name="A">Input array</param>
            <returns>Double array with the length of each dimension of A</returns>
            <remarks>If A is null, an empty array will be returned. Otherwise the array returned will always be a row vector of length s. s &gt;= 2</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.size(ILNumerics.ILBaseArray,System.Int32)">
            <summary>
            Length of one specific dimension of A
            </summary>
            <param name="A">Input array</param>
            <param name="dim">Number of dimension to query the length for</param>
            <returns>Length of dimension 'dim'</returns>
        </member>
        <member name="M:ILNumerics.ILMath.size(System.Int32[])">
            <summary>
            Create a size descriptor
            </summary>
            <param name="dimensions">Arbitrary number of dimension length</param>
            <returns>Size descriptor</returns>
        </member>
        <member name="M:ILNumerics.ILMath.length(ILNumerics.ILBaseArray)">
            <summary>
            Longest dimension of A
            </summary>
            <param name="A">Input array</param>
            <returns>If A is null:0 - length of longest dimension of A</returns>
            <remarks>This is an alias/abreviation for A.Dimensions.Longest</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ndims(ILNumerics.ILBaseArray)">
            <summary>
            Number of dimensions of A
            </summary>
            <param name="A">Input array</param>
            <returns>If A is null: 0 - else number of dimensions of A</returns>
            <remarks>This is an alias/abreviation for A.Dimensions.NumberOfDimensions</remarks>
            
        </member>
        <member name="M:ILNumerics.ILMath.numel(ILNumerics.ILBaseArray)">
            <summary>
            Number of elements of A
            </summary>
            <param name="A">Input array</param>
            <returns>Number of elements of A</returns>
            <remarks>This is an alias/abreviation for A.Dimensions.NumberOfElements</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            pairwise L1 distance 
            </summary>
            <param name="A">input points (matrix)</param>
            <param name="B">input point (vector)</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is cummulative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>
            pairwise L1 distance 
            </summary>
            <param name="A">input points (matrix)</param>
            <param name="B">input point (vector)</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is cummulative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>
            pairwise L1 distance 
            </summary>
            <param name="A">input points (matrix)</param>
            <param name="B">input point (vector)</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is cummulative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            pairwise L1 distance 
            </summary>
            <param name="A">input points (matrix)</param>
            <param name="B">input point (vector)</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is cummulative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            pairwise L1 distance 
            </summary>
            <param name="A">input points (matrix)</param>
            <param name="B">input point (vector)</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is cummulative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            pairwise L1 distance 
            </summary>
            <param name="A">input points (matrix)</param>
            <param name="B">input point (vector)</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is cummulative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Divide elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Divide elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Divide elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Divide elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Divide elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Divide elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Divide elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})">
            <summary>
            Compute eigenvalues of general square matrix A
            </summary>
            <param name="A">Input matrix A. Size [n x n]</param>
            <returns>Vector of eigenvalues of A. Size [n x 1]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            Compute eigenvalues and eigenvectors of general square matrix A
            </summary>
            <param name="A">Input matrix A. Size [n x n]</param>
            <param name="V">Output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
            <returns>Diagonal matrix with eigenvalues of A. Size [n x n]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The matrices returned will be of complex inner type, since no further constrains are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)">
            <summary>
            Find eigenvalues  and eigenvectors 
            </summary>
            <param name="A">Input: square matrix, size [n x n]</param>
            <param name="V">Output (optional): eigenvectors</param>   
            <param name="propsA">Matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
            <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
            <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not null).</returns>
            <remarks><para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> 
            or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
            <para>Depending on the parameter <paramref name="balance"/>, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})">
            <summary>
            Find all eigenvalues of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <returns>Array of size [n,1] with eigenvalues of A.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Find all eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors 
            will not be computed and V is not changed. In order to make the function return the vectors, V should be initialized with any non null value (e.g.'1') before calling eigSymm.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32,System.Int32)">
            <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">Specify the lowest limit for the range of eigenvalues to be queried.</param>
            <param name="rangeEnd">Specify the upper limit for the range of eigenvalues to be queried.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/></exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Double,System.Double)">
            <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
            <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/> or if either one is &lt;= 0.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Single})">
            <summary>
            Compute eigenvalues of general square matrix A
            </summary>
            <param name="A">Input matrix A. Size [n x n]</param>
            <returns>Vector of eigenvalues of A. Size [n x 1]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            Compute eigenvalues and eigenvectors of general square matrix A
            </summary>
            <param name="A">Input matrix A. Size [n x n]</param>
            <param name="V">Output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
            <returns>Diagonal matrix with eigenvalues of A. Size [n x n]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The matrices returned will be of complex inner type, since no further constrains are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)">
            <summary>
            Find eigenvalues  and eigenvectors 
            </summary>
            <param name="A">Input: square matrix, size [n x n]</param>
            <param name="V">Output (optional): eigenvectors</param>   
            <param name="propsA">Matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
            <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
            <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not null).</returns>
            <remarks><para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> 
            or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
            <para>Depending on the parameter <paramref name="balance"/>, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single})">
            <summary>
            Find all eigenvalues of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <returns>Array of size [n,1] with eigenvalues of A.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Find all eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors 
            will not be computed and V is not changed. In order to make the function return the vectors, V should be initialized with any non null value (e.g.'1') before calling eigSymm.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Int32,System.Int32)">
            <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">Specify the lowest limit for the range of eigenvalues to be queried.</param>
            <param name="rangeEnd">Specify the upper limit for the range of eigenvalues to be queried.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/></exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Single,System.Single)">
            <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
            <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/> or if either one is &lt;= 0.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Compute eigenvalues of general square matrix A
            </summary>
            <param name="A">Input matrix A. Size [n x n]</param>
            <returns>Vector of eigenvalues of A. Size [n x 1]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            Compute eigenvalues and eigenvectors of general square matrix A
            </summary>
            <param name="A">Input matrix A. Size [n x n]</param>
            <param name="V">Output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
            <returns>Diagonal matrix with eigenvalues of A. Size [n x n]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The matrices returned will be of complex inner type, since no further constrains are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)">
            <summary>
            Find eigenvalues  and eigenvectors 
            </summary>
            <param name="A">Input: square matrix, size [n x n]</param>
            <param name="V">Output (optional): eigenvectors</param>   
            <param name="propsA">Matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
            <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
            <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not null).</returns>
            <remarks><para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> 
            or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
            <para>Depending on the parameter <paramref name="balance"/>, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Find all eigenvalues of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <returns>Array of size [n,1] with eigenvalues of A.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            Find all eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors 
            will not be computed and V is not changed. In order to make the function return the vectors, V should be initialized with any non null value (e.g.'1') before calling eigSymm.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
            <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">Specify the lowest limit for the range of eigenvalues to be queried.</param>
            <param name="rangeEnd">Specify the upper limit for the range of eigenvalues to be queried.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/></exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Single,System.Single)">
            <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
            <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/> or if either one is &lt;= 0.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Compute eigenvalues of general square matrix A
            </summary>
            <param name="A">Input matrix A. Size [n x n]</param>
            <returns>Vector of eigenvalues of A. Size [n x 1]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            Compute eigenvalues and eigenvectors of general square matrix A
            </summary>
            <param name="A">Input matrix A. Size [n x n]</param>
            <param name="V">Output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
            <returns>Diagonal matrix with eigenvalues of A. Size [n x n]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The matrices returned will be of complex inner type, since no further constrains are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)">
            <summary>
            Find eigenvalues  and eigenvectors 
            </summary>
            <param name="A">Input: square matrix, size [n x n]</param>
            <param name="V">Output (optional): eigenvectors</param>   
            <param name="propsA">Matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
            <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
            <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not null).</returns>
            <remarks><para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> 
            or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
            <para>Depending on the parameter <paramref name="balance"/>, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Find all eigenvalues of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <returns>Array of size [n,1] with eigenvalues of A.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            Find all eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors 
            will not be computed and V is not changed. In order to make the function return the vectors, V should be initialized with any non null value (e.g.'1') before calling eigSymm.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">Specify the lowest limit for the range of eigenvalues to be queried.</param>
            <param name="rangeEnd">Specify the upper limit for the range of eigenvalues to be queried.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/></exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Double,System.Double)">
            <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
            <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/> or if either one is &lt;= 0.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <returns>Vector of eigenvalues. size [n x 1]</returns>
            <remarks>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)">
            <summary>
            Compute eigenvalues and eigenvectors of symmetric/hermitian input
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="outV">[Output] Returns eigenvectors in columns (size [n x n]). </param>
            <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
            <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILMath.GenEigenType,System.Boolean)">
            <summary>
            Compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="outV">[Output] If on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
            <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
            <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
            <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <returns>Vector of eigenvalues. size [n x 1]</returns>
            <remarks>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean)">
            <summary>
            Compute eigenvalues and eigenvectors of symmetric/hermitian input
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="outV">[Output] Returns eigenvectors in columns (size [n x n]). </param>
            <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
            <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILMath.GenEigenType,System.Boolean)">
            <summary>
            Compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="outV">[Output] If on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
            <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
            <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
            <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <returns>Vector of eigenvalues. size [n x 1]</returns>
            <remarks>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean)">
            <summary>
            Compute eigenvalues and eigenvectors of symmetric/hermitian input
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="outV">[Output] Returns eigenvectors in columns (size [n x n]). </param>
            <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
            <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILMath.GenEigenType,System.Boolean)">
            <summary>
            Compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="outV">[Output] If on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
            <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
            <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
            <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <returns>Vector of eigenvalues. size [n x 1]</returns>
            <remarks>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean)">
            <summary>
            Compute eigenvalues and eigenvectors of symmetric/hermitian input
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="outV">[Output] Returns eigenvectors in columns (size [n x n]). </param>
            <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
            <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILMath.GenEigenType,System.Boolean)">
            <summary>
            Compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="outV">[Output] If on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
            <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
            <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
            <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.empty">
            <summary>
            Create empty double array of size [0,0].
            </summary>
            <returns>Empty array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.empty``1(ILNumerics.ILSize)">
            <summary>
            Create empty double array of specific size
            </summary>
            <param name="size">(Empty-) size of new empty array</param>
            <returns>Empty array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.empty``1(System.Int32[])">
            <summary>
            Create empty double array of specific size
            </summary>
            <param name="size">(Empty-) size of new empty array</param>
            <returns>Empty array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.empty``1">
            <summary>
            Create empty array of size [0,0] and arbitrary element type
            </summary>
            <returns>Empty array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.empty(ILNumerics.ILSize)">
            <summary>
            Create empty double array of specific size
            </summary>
            <param name="size">(Empty-) size of new empty array</param>
            <returns>Empty array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.empty(System.Int32[])">
            <summary>
            Create empty double array of specific size
            </summary>
            <param name="size">(Empty-) size of new empty array</param>
            <returns>Empty array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.localMember``1">
            <summary>
            Create new empty array, used for array class members
            </summary>
            <typeparam name="T">Element type</typeparam>
            <returns>Empty array which can afterwards be used for arbitrary assignements (Assign(), or 'array.A = ..' assignements)</returns>
            <remarks>The array returned will be an empty array initially. Its main purpose is to provide 
            a persistant array initialization. The array will not be disposed after leaving the current scope
            and can therefore be utilized for initializing class attributes. After initialization, use the 'ILArray.A = ...' property (C#) 
            or the ILArray.Assign() function to assign new values to the array.</remarks>
        </member>
        <member name="F:ILNumerics.ILMath.pi">
            <summary>
            Definition of pi
            </summary>
            <remarks>This is an convenience alias for Math.PI</remarks>
        </member>
        <member name="F:ILNumerics.ILMath.pif">
            <summary>
            Definition of pi, single precision
            </summary>
            <remarks>This is an convenience alias for Math.PI</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.macharF(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Determine machine specific parameter
            </summary>
            <remarks>Source: Numerical Recipes in C, p.892</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.macharD(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Determine machine specific parameter (double precision)
            </summary>
            <remarks>Source: Numerical Recipes in C, p.892</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.String},ILNumerics.ILInArray{System.String})">
            <summary>
            Elementwise logical 'equal' operator
            </summary>
            <param name="A">Input array 1</param>
            <param name="B">Input array 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the size of both arrays does not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.exp(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Exponential of array elements</summary>
            <param name="A">Input array</param>
            <returns>Exponential of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.exp(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Exponential of array elements</summary>
            <param name="A">Input array</param>
            <returns>Exponential of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.exp(ILNumerics.ILInArray{System.Single})">
            <summary>Exponential of array elements</summary>
            <param name="A">Input array</param>
            <returns>Exponential of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.exp(ILNumerics.ILInArray{System.Double})">
            <summary>Exponential of array elements</summary>
            <param name="A">Input array</param>
            <returns>Exponential of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.eye(System.Int32,System.Int32)">
            <summary>
            Create double matrix having unity diagonal values  
            </summary>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <returns>Unity matrix (diagonal matrix) of type double</returns>
        </member>
        <member name="M:ILNumerics.ILMath.eye``1(System.Int32,System.Int32)">
            <summary>
            Create unity matrix, arbitrary numeric type
            </summary>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <returns>Unity matrix (diagonal matrix) of element type T</returns>
            <typeparam name="T">Element type</typeparam>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the type specified is not supported. Supported types are: double, float, complex, fcomplex, int, long, short, byte</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{System.Double})">
            <summary>
            Fast fourier transform (1D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformed output array</returns>
            <remarks><para>The transformation is computed along the first 
            non singleton dimension.</para>
            <para>The output array returned will be complex hermitian. I.e. the real 
            part being even and the imaginary part being odd symmetrical.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Fast fourier transform (1D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformed output array</returns>
            <remarks>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifft(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Fast inverse fourier transform (1D)
            </summary>
            <param name="A">Input (frequency domain)</param>
            <returns>Inverse transformed output array</returns>
            <remarks>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifftsym(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Inverse fast fourier transform, complex hermitian input
            </summary>
            <param name="A">Complex hermitian input array</param>
            <returns>Real output array, same size as A</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in 
            the output having all imaginary part equal zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            Fast fourier transform along specific dimension
            </summary>
            <param name="A">Real input array</param>
            <param name="dim">Dimension to compute FFT along. This parameter must be non-negative. </param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The output array returned will be complex hermitian. I.e. the real 
            part being even and the imaginary part being odd symmetrical.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Fast fourier transform along specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifft(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Inverse fast fourier transform along specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifftsym(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Inverse fast fourier transform, complex hermitian input
            </summary>
            <param name="A">Complex hermitian input array (frequency domain)</param>
            <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>Real output array, same size as A</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{System.Double})">
            <summary>
            Fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The 2D transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The output array returned will be complex hermitian.</para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifft2(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Inverse fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifft2sym(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Inverse fast fourier transform (2D, hermitian input)
            </summary>
            <param name="A">Complex hermitian input array (frequency domain)</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{System.Double},System.Int32,System.Int32)">
            <summary>
            Fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <param name="m">Transformation column length</param>
            <param name="n">Transformation row length</param>
            <returns>Transformation result, complex hermitian</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            Fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <param name="m">Transformation column length</param>
            <param name="n">Transformation row length</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifft2(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            Inverse fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <param name="m">Transformation column length</param>
            <param name="n">Transformation row length</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifft2sym(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            Inverse fast fourier transform (2D)
            </summary>
            <param name="A">Complex hermitian input array, symmetric in first 2 dimensions</param>
            <param name="m">Transformation column length</param>
            <param name="n">Transformation row length</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. The 
            lengths of those trailing dimensions are not altered.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{System.Double})">
            <summary>
            Fast fourier transform (n-D)
            </summary>
            <param name="A">Input array, n-D</param>
            <returns>Transformation result, complex hermitian</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Fast fourier transform (n-D)
            </summary>
            <param name="A">Input array, n-D</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Inverse fast fourier transform (n-D)
            </summary>
            <param name="A">Input array, n-D (frequency domain)</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Inverse fast fourier transform (n-D)
            </summary>
            <param name="A">Input array, n-D, complex hermitian (frequency domain)</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{System.Double},System.Int32[])">
            <summary>
            Fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">Input array, n-D</param>
            <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>Transformation result of size specified by 'dims' parameter, complex hermitian</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
            <summary>
            Fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">Tnput array, n-D</param>
            <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>Transformation result of size specified by 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
            <summary>
            Inverse fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">Input array, n-D</param>
            <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>Transformation result of size specified by 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
            <summary>
            Inverse fast fourier transform (n-D, complex hermitian, specific size)
            </summary>
            <param name="A">Complex hermitian input array, n-D</param>
            <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>Transformation result, real array of the size specified by the 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{System.Single})">
            <summary>
            Fast fourier transform (1D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformed output array</returns>
            <remarks><para>The transformation is computed along the first 
            non singleton dimension.</para>
            <para>The output array returned will be complex hermitian. I.e. the real 
            part being even and the imaginary part being odd symmetrical.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Fast fourier transform (1D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformed output array</returns>
            <remarks>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifft(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Fast inverse fourier transform (1D)
            </summary>
            <param name="A">Input (frequency domain)</param>
            <returns>Inverse transformed output array</returns>
            <remarks>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifftsym(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Inverse fast fourier transform, complex hermitian input
            </summary>
            <param name="A">Complex hermitian input array</param>
            <returns>Real output array, same size as A</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in 
            the output having all imaginary part equal zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            Fast fourier transform along specific dimension
            </summary>
            <param name="A">Real input array</param>
            <param name="dim">Dimension to compute FFT along. This parameter must be non-negative. </param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The output array returned will be complex hermitian. I.e. the real 
            part being even and the imaginary part being odd symmetrical.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Fast fourier transform along specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifft(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Inverse fast fourier transform along specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifftsym(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Inverse fast fourier transform, complex hermitian input
            </summary>
            <param name="A">Complex hermitian input array (frequency domain)</param>
            <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>Real output array, same size as A</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{System.Single})">
            <summary>
            Fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The 2D transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The output array returned will be complex hermitian.</para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifft2(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Inverse fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifft2sym(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Inverse fast fourier transform (2D, hermitian input)
            </summary>
            <param name="A">Complex hermitian input array (frequency domain)</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{System.Single},System.Int32,System.Int32)">
            <summary>
            Fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <param name="m">Transformation column length</param>
            <param name="n">Transformation row length</param>
            <returns>Transformation result, complex hermitian</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
            <summary>
            Fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <param name="m">Transformation column length</param>
            <param name="n">Transformation row length</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifft2(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
            <summary>
            Inverse fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <param name="m">Transformation column length</param>
            <param name="n">Transformation row length</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifft2sym(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
            <summary>
            Inverse fast fourier transform (2D)
            </summary>
            <param name="A">Complex hermitian input array, symmetric in first 2 dimensions</param>
            <param name="m">Transformation column length</param>
            <param name="n">Transformation row length</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. The 
            lengths of those trailing dimensions are not altered.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{System.Single})">
            <summary>
            Fast fourier transform (n-D)
            </summary>
            <param name="A">Input array, n-D</param>
            <returns>Transformation result, complex hermitian</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Fast fourier transform (n-D)
            </summary>
            <param name="A">Input array, n-D</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Inverse fast fourier transform (n-D)
            </summary>
            <param name="A">Input array, n-D (frequency domain)</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Inverse fast fourier transform (n-D)
            </summary>
            <param name="A">Input array, n-D, complex hermitian (frequency domain)</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{System.Single},System.Int32[])">
            <summary>
            Fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">Input array, n-D</param>
            <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>Transformation result of size specified by 'dims' parameter, complex hermitian</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
            <summary>
            Fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">Tnput array, n-D</param>
            <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>Transformation result of size specified by 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
            <summary>
            Inverse fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">Input array, n-D</param>
            <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>Transformation result of size specified by 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
            <summary>
            Inverse fast fourier transform (n-D, complex hermitian, specific size)
            </summary>
            <param name="A">Complex hermitian input array, n-D</param>
            <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>Transformation result, real array of the size specified by the 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{System.Double},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Find nonzero elements in A
            </summary>
            <param name="A">Input array</param>
            <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
            <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{System.Int64},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Int64})">
            <summary>
            Find nonzero elements in A
            </summary>
            <param name="A">Input array</param>
            <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
            <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{System.Int32},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Int32})">
            <summary>
            Find nonzero elements in A
            </summary>
            <param name="A">Input array</param>
            <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
            <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{System.Single},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Find nonzero elements in A
            </summary>
            <param name="A">Input array</param>
            <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
            <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            Find nonzero elements in A
            </summary>
            <param name="A">Input array</param>
            <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
            <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            Find nonzero elements in A
            </summary>
            <param name="A">Input array</param>
            <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
            <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{System.Byte},System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Byte})">
            <summary>
            Find nonzero elements in A
            </summary>
            <param name="A">Input array</param>
            <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
            <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInLogical,System.Int32,ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutLogical)">
            <summary>
            Find nonzero elements in A
            </summary>
            <param name="A">Input array</param>
            <param name="limit">Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fix(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Round towards zero</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded towards zero</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fix(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Round towards zero</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded towards zero</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fix(ILNumerics.ILInArray{System.Single})">
            <summary>Round towards zero</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded towards zero</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fix(ILNumerics.ILInArray{System.Double})">
            <summary>Round towards zero</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded towards zero</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fliplr``1(ILNumerics.ILInArray{``0})">
            <summary>
            Reverse order of columns of matrix
            </summary>
            <typeparam name="T">Inner element type</typeparam>
            <param name="A">Input matrix</param>
            <returns>Matrix of same size as A, having the order of its columns reversed</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fliplr(ILNumerics.ILInArray{System.Double})">
            <summary>
            Reverse order of columns of matrix
            </summary>
            <param name="A">Input matrix</param>
            <returns>Matrix of same size as A, having the order of its columns reversed</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions</exception>
        </member>
        <member name="M:ILNumerics.ILMath.flipud``1(ILNumerics.ILInArray{``0})">
            <summary>
            Reverse order of rows of a matrix
            </summary>
            <typeparam name="T">Inner element type</typeparam>
            <param name="A">Input matrix</param>
            <returns>Matrix of same size as A, having the order of its rows reversed</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions</exception>
        </member>
        <member name="M:ILNumerics.ILMath.flipud(ILNumerics.ILInArray{System.Double})">
            <summary>
            Reverse order of rows of a matrix
            </summary>
            <param name="A">Input matrix</param>
            <returns>Matrix of same size as A, having the order of its rows reversed</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions</exception>
        </member>
        <member name="M:ILNumerics.ILMath.floor(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Round towards negative infinity</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded downwards to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.floor(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Round towards negative infinity</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded downwards to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.floor(ILNumerics.ILInArray{System.Single})">
            <summary>Round towards negative infinity</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded downwards to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.floor(ILNumerics.ILInArray{System.Double})">
            <summary>Round towards negative infinity</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded downwards to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.free``1(``0[])">
            <summary>
            Return a System.Array to the memory pool 
            </summary>
            <typeparam name="T">the element type</typeparam>
            <param name="obj4Dispose">the System.Array to be returned to the pool.</param>
            <remarks>Thes function allows the manual regristration of System.Arrays to the ILNumerics memory pool. See <see cref="M:ILNumerics.ILMath.New``1(System.Int32)"/> for a usage example.</remarks>
            <seealso cref="M:ILNumerics.ILMath.New``1(System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{System.Double}[])">
            <summary>
            Horizontal array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
            <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{ILNumerics.fcomplex}[])">
            <summary>
            Horizontal array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
            <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{ILNumerics.complex}[])">
            <summary>
            Horizontal array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
            <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{System.Byte}[])">
            <summary>
            Horizontal array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
            <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{System.Int64}[])">
            <summary>
            Horizontal array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
            <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{System.Int32}[])">
            <summary>
            Horizontal array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
            <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{System.Single}[])">
            <summary>
            Horizontal array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
            <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.horzcat``1(ILNumerics.ILInArray{``0}[])">
            <summary>
            Horizontal array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
            <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.logical(System.Byte[],System.Int32[])">
            <summary>
            Create logical array explicitely
            </summary>
            <param name="data">system array of 0/1 valued byte elements</param>
            <param name="size">the size of the new logical array</param>
            <returns>a new logical with the elements from data and the given size</returns>
        </member>
        <member name="M:ILNumerics.ILMath.mvnpdf(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Probability density function for a multivariate normal random distribution
            </summary>
            <param name="A">Matrix of points in columns, where the probability density function is to be evaluated</param>
            <param name="mu">[Optional] Centers, size d x 1, if 'null': zeros are attempted, default: null</param>
            <param name="sigma">Covariance matrix, must be positive definite, size d x d or vector of lenght d</param>
            <returns>Random numbers as taken from the multivariate random probability distribution given by mu and sigma</returns>
        </member>
        <member name="M:ILNumerics.ILMath.mvnpdf(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Probability density function for a multivariate normal random distribution
            </summary>
            <param name="A">Matrix of points in columns, where the probability density function is to be evaluated</param>
            <param name="mu">[Optional] Centers, size d x 1, if 'null': zeros are attempted, default: null</param>
            <param name="sigma">Covariance matrix, must be positive definite, size d x d or vector of lenght d</param>
            <returns>Random numbers as taken from the multivariate random probability distribution given by mu and sigma</returns>
        </member>
        <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.imag(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Imaginary part of complex array elements
            </summary>
            <param name="X">Complex input array</param>
            <returns>Imaginary part of complex array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.imag(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Imaginary part of complex array elements
            </summary>
            <param name="X">Complex input array</param>
            <returns>Imaginary part of complex array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.ind2sub(ILNumerics.ILBaseArray,System.Int32)">
            <summary>
            Convert sequential index into subscript indices
            </summary>
            <param name="A">Input array</param>
            <param name="seqindex">Sequential index</param>
            <returns>Subscript indices</returns>
            <remarks><para>The index array returned will have the length of number of dimensions of A</para>
            <para>If A is a null or an empty array, the return value will be also be empty</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">If seqindex is &lt; 0 or &gt;= numel(A)</exception>
        </member>
        <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Invert elements of A, return result into predefined output array
            </summary>
            <param name="A">Input array</param>
            <param name="outArray">Predefined array for results</param>
        </member>
        <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{System.Byte},ILNumerics.ILOutArray{System.Byte})">
            <summary>
            Invert elements of A, return result into predefined output array
            </summary>
            <param name="A">Input array</param>
            <param name="outArray">Predefined array for results</param>
        </member>
        <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int64})">
            <summary>
            Invert elements of A, return result into predefined output array
            </summary>
            <param name="A">Input array</param>
            <param name="outArray">Predefined array for results</param>
        </member>
        <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32})">
            <summary>
            Invert elements of A, return result into predefined output array
            </summary>
            <param name="A">Input array</param>
            <param name="outArray">Predefined array for results</param>
        </member>
        <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Invert elements of A, return result into predefined output array
            </summary>
            <param name="A">Input array</param>
            <param name="outArray">Predefined array for results</param>
        </member>
        <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            Invert elements of A, return result into predefined output array
            </summary>
            <param name="A">Input array</param>
            <param name="outArray">Predefined array for results</param>
        </member>
        <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            Invert elements of A, return result into predefined output array
            </summary>
            <param name="A">Input array</param>
            <param name="outArray">Predefined array for results</param>
        </member>
        <member name="M:ILNumerics.ILMath.isempty(ILNumerics.ILBaseArray)">
            <summary>
            Test if array is empty
            </summary>
            <param name="A">Input array</param>
            <returns>True if at least one dimension of A has length 0, false otherwise</returns>
            <remarks>
            <para>This function is an alias for A.IsEmpty. Consider using the matrix property directly for improved performance.</para>
            </remarks>
            <seealso cref="P:ILNumerics.ILBaseArray.IsEmpty"/>
        </member>
        <member name="M:ILNumerics.ILMath.isequal(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Compares two arrays, return System.bool as result
            </summary>
            <param name="A">Input array</param>
            <param name="B">Input array</param>
            <returns>True, if all elements and sizes of both arrays match; false otherwise</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Compares elements of two arrays, assume NaN and +/- infinity values are comparable and equal
            </summary>
            <param name="A">Input array</param>
            <param name="B">Input array</param>
            <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Compares elements of two arrays, assume NaN and +/- infinity values are comparable and equal
            </summary>
            <param name="A">Input array</param>
            <param name="B">Input array</param>
            <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Compares elements of two arrays, assume NaN and +/- infinity values are comparable and equal
            </summary>
            <param name="A">Input array</param>
            <param name="B">Input array</param>
            <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Compares elements of two arrays, assume NaN and +/- infinity values are comparable and equal
            </summary>
            <param name="A">Input array</param>
            <param name="B">Input array</param>
            <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Compare two arrays, assume NaN and +/- infinity values are comparable and equal
            </summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>True if all non-NaN elements in A and B equal, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isfinite(System.Double)">
            <summary>
            Find out, if value is finite
            </summary>
            <param name="input">Input value</param>
            <returns>True for finite values</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.complex)">
            <summary>
            Find out, if value is finite
            </summary>
            <param name="input">Input value</param>
            <returns>True for finite values</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isfinite(System.Single)">
            <summary>
            Find out, if value is finite
            </summary>
            <param name="input">Input value</param>
            <returns>True for finite values</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.fcomplex)">
            <summary>
            Find out, if value is finite
            </summary>
            <param name="input">Input value</param>
            <returns>True for finite values</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.ILInArray{System.Double})">
            <summary>Finds finite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.ILInArray{System.Single})">
            <summary>Finds finite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Finds finite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Finds finite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isinf(ILNumerics.ILInArray{System.Double})">
            <summary>Locate infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isinf(ILNumerics.ILInArray{System.Single})">
            <summary>Locate infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isinf(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Locate infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isinf(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Locate infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isnan(ILNumerics.ILInArray{System.Double})">
            <summary>Finds invalid value elements (not-a-number)</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isnan(ILNumerics.ILInArray{System.Single})">
            <summary>Finds invalid value elements (not-a-number)</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isnan(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Finds invalid value elements (not-a-number)</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isnan(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Finds invalid value elements (not-a-number)</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isneginf(ILNumerics.ILInArray{System.Double})">
            <summary>Finds negative infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isneginf(ILNumerics.ILInArray{System.Single})">
            <summary>Finds negative infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isneginf(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Finds negative infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isneginf(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Finds negative infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isnull(ILNumerics.ILBaseArray)">
            <summary>
            Determine, if the array A is null (NULL, not assigned)
            </summary>
            <param name="A">Input array</param>
            <returns>True, if the array is null, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isnullorempty(ILNumerics.ILBaseArray)">
            <summary>
            Determine, if the array A is null (NULL or not assigned) or empty
            </summary>
            <param name="A">Input array</param>
            <returns>True, if the array is null or empty, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isposinf(ILNumerics.ILInArray{System.Double})">
            <summary>Finds positive infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isposinf(ILNumerics.ILInArray{System.Single})">
            <summary>Finds positive infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isposinf(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Finds positive infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isposinf(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Finds positive infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.linspace(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Create linearly spaced row vector of 100 elements 
            </summary>
            <param name="start">First value</param>
            <param name="end">Last value</param>
            <returns>Row vector with 100 elements linearly spaced between start and end</returns>
        </member>
        <member name="M:ILNumerics.ILMath.linspace``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Create linearly spaced row vector, generic output type
            </summary>
            <param name="start">First value, scalar, numeric</param>
            <param name="end">Last value, scalar, numeric</param>
            <param name="length">Number of elements to create, scalar, numeric</param>
            <returns>Row vector with 'length' elements linearly spaced between start and end</returns>
        </member>
        <member name="M:ILNumerics.ILMath.linspace(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Create linearly spaced row vector, double precision
            </summary>
            <param name="start">First value</param>
            <param name="end">Last value</param>
            <param name="length">Number of elements to create</param>
            <returns>Row vector with 'length' elements linearly spaced between start and end</returns>
        </member>
        <member name="M:ILNumerics.ILMath.loadArray``1(System.String,System.String)">
            <summary>
            Load single array from matfile file
            </summary>
            <typeparam name="T">Element type of the array to return</typeparam>
            <param name="filename">Path of the matfile on disk</param>
            <param name="arrayname">[Optional] name of the requested array in the matfile (default: empty string)</param>
            <returns>The array requested</returns>
            <remarks><para>If <paramref name="arrayname"/> is ommited, the first array is returned. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.logc(ILNumerics.ILInArray{System.Single})">
            <summary>Logarithm of array elements - complex output</summary>
            <param name="A">Input array</param>
            <returns>Complex logarithm of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.logc(ILNumerics.ILInArray{System.Double})">
            <summary>Logarithm of array elements - complex output</summary>
            <param name="A">Input array</param>
            <returns>Complex logarithm of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Logarithm of array elements</summary>
            <param name="A">Input array</param>
            <returns>Complex logarithm of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Logarithm of array elements</summary>
            <param name="A">Input array</param>
            <returns>Complex logarithm of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log(ILNumerics.ILInArray{System.Single})">
            <summary>Logarithm of array elements - real output</summary>
            <param name="A">Input array</param>
            <returns>Logarithm of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log(ILNumerics.ILInArray{System.Double})">
            <summary>Logarithm of array elements - real output</summary>
            <param name="A">Input array</param>
            <returns>Logarithm of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log10c(ILNumerics.ILInArray{System.Single})">
            <summary>Logarithm of base 10 of array elements - complex output</summary>
            <param name="A">Input array</param>
            <returns>Complex logarithm of base 10 of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log10c(ILNumerics.ILInArray{System.Double})">
            <summary>Logarithm of base 10 of array elements - complex output</summary>
            <param name="A">Input array</param>
            <returns>Complex logarithm of base 10 of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log10(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Logarithm of base 10 of array elements</summary>
            <param name="A">Input array</param>
            <returns>Complex logarithm of base 10 of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log10(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Logarithm of base 10 of array elements</summary>
            <param name="A">Input array</param>
            <returns>Complex logarithm of base 10 of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log10(ILNumerics.ILInArray{System.Single})">
            <summary>Logarithm of base 10 of array elements - real output</summary>
            <param name="A">Input array</param>
            <returns>Logarithm of base 10 of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log10(ILNumerics.ILInArray{System.Double})">
            <summary>Logarithm of base 10 of array elements - real output</summary>
            <param name="A">Input array</param>
            <returns>Logarithm of base 10 of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.logspace(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Create logarithmically spaced row vector of 30 elements 
            </summary>
            <param name="start">First exponent value</param>
            <param name="end">Last exponent value</param>
            <returns>Row vector with 30 elements logathmically spaced between 10^start and 10^end</returns>
        </member>
        <member name="M:ILNumerics.ILMath.logspace(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Create logarithmically spaced row vector
            </summary>
            <param name="start">First exponent value</param>
            <param name="end">Last exponent value</param>
            <param name="length">Number of elements to create</param>
            <returns>Row vector with 'length' elements logarithmically spaced between 10^start and 10^end</returns>
        </member>
        <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'smaller than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'smaller than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'smaller than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'smaller than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'smaller than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'smaller than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'smaller than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part. 
            </summary>
            <param name="A">Input matrix. Size [m x n]</param>
            <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
            <remarks><para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
            <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
            <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
             or <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> instead.</para>
            <para>The matrix L will be a solid ILArray.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            </summary>
            <param name="A">Input matrix to be decomposed. Size [m x n]</param>
            <param name="U">[Output] Reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
            <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <c>ILMath.multiply(L,U) == A</c></para>
            <example> <code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example>
            <para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> which returns the permuation matrix P also.</para>
            <para>All of the matrices U and L returned will be solid ILArrays.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also. 
            </summary>
            <param name="A">Input matrix. Size [m x n]</param>
            <param name="U">[Output] Reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
            <param name="P">[Output] Reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
            <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that the equation 
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para>
            <example> <code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            </example>
            <para>lu uses the Lapack function ?getrf.</para>
            <para>All of the matrices U,L,P returned will be solid ILArrays.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Single})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part. 
            </summary>
            <param name="A">Input matrix. Size [m x n]</param>
            <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
            <remarks><para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
            <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
            <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
             or <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> instead.</para>
            <para>The matrix L will be a solid ILArray.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            </summary>
            <param name="A">Input matrix to be decomposed. Size [m x n]</param>
            <param name="U">[Output] Reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
            <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <c>ILMath.multiply(L,U) == A</c></para>
            <example> <code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example>
            <para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> which returns the permuation matrix P also.</para>
            <para>All of the matrices U and L returned will be solid ILArrays.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also. 
            </summary>
            <param name="A">Input matrix. Size [m x n]</param>
            <param name="U">[Output] Reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
            <param name="P">[Output] Reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
            <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that the equation 
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para>
            <example> <code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            </example>
            <para>lu uses the Lapack function ?getrf.</para>
            <para>All of the matrices U,L,P returned will be solid ILArrays.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part. 
            </summary>
            <param name="A">Input matrix. Size [m x n]</param>
            <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
            <remarks><para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
            <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
            <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
             or <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> instead.</para>
            <para>The matrix L will be a solid ILArray.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            </summary>
            <param name="A">Input matrix to be decomposed. Size [m x n]</param>
            <param name="U">[Output] Reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
            <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <c>ILMath.multiply(L,U) == A</c></para>
            <example> <code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example>
            <para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> which returns the permuation matrix P also.</para>
            <para>All of the matrices U and L returned will be solid ILArrays.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also. 
            </summary>
            <param name="A">Input matrix. Size [m x n]</param>
            <param name="U">[Output] Reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
            <param name="P">[Output] Reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
            <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that the equation 
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para>
            <example> <code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            </example>
            <para>lu uses the Lapack function ?getrf.</para>
            <para>All of the matrices U,L,P returned will be solid ILArrays.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part. 
            </summary>
            <param name="A">Input matrix. Size [m x n]</param>
            <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
            <remarks><para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
            <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
            <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
             or <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> instead.</para>
            <para>The matrix L will be a solid ILArray.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            </summary>
            <param name="A">Input matrix to be decomposed. Size [m x n]</param>
            <param name="U">[Output] Reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
            <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <c>ILMath.multiply(L,U) == A</c></para>
            <example> <code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example>
            <para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> which returns the permuation matrix P also.</para>
            <para>All of the matrices U and L returned will be solid ILArrays.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also. 
            </summary>
            <param name="A">Input matrix. Size [m x n]</param>
            <param name="U">[Output] Reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
            <param name="P">[Output] Reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
            <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that the equation 
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para>
            <example> <code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            </example>
            <para>lu uses the Lapack function ?getrf.</para>
            <para>All of the matrices U,L,P returned will be solid ILArrays.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.copyUpperTriangle``1(ILNumerics.ILInArray{``0},System.Int32,System.Int32)">
            <summary>
            Copy upper triangle from PHYSICAL array A
            </summary>
            <typeparam name="T">Arbitrary inner type </typeparam>
            <param name="A">PHYSICAL ILArray</param>
            <param name="m">Number of rows</param>
            <param name="n">Number of columns</param>
            <returns>Newly created physical array with the upper triangle of A</returns>
            <remarks>No checks are made for m,n fit inside A!</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.copyUpperTriangle``1(``0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copy upper triangle from system array A
            </summary>
            <typeparam name="T">Arbitrary inner type </typeparam>
            <param name="arrIn">System array, size (m x n), column wise ordered</param>
            <param name="arrInM">Number of rows</param>
            <param name="arrInN">Number of columns</param>
            <param name="outM">Number of rows in output matrix</param>
            <returns>Newly created physical array with the upper triangle of A</returns>
            <remarks>No checks are made for m,n fit inside A! copies the main diagonal also.
            the array returned will be of size (min(m,n) x n)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.copyLowerTriangle``1(ILNumerics.ILInArray{``0},System.Int32,System.Int32,``0)">
            <summary>
            Copy lower triangle from PHYSICAL array A, set diagonal to val
            </summary>
            <typeparam name="T">Arbitrary inner type </typeparam>
            <param name="A">PHYSICAL ILArray</param>
            <param name="m">Number of rows</param>
            <param name="n">Number of columns</param>
            <param name="val">Value for diagonal entries</param>
            <returns>Newly created physical array with the lower triangle of A</returns>
            <remarks>No checks are made for m,n fit inside A!</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.copyLowerTrianglePerm``1(ILNumerics.ILInArray{``0},System.Int32,System.Int32,``0,System.Int32[])">
            <summary>
            Copy lower triangle from PHYSICAL array A, set diagonal to val, permuted version
            </summary>
            <typeparam name="T">Arbitrary inner type </typeparam>
            <param name="A">PHYSICAL ILArray</param>
            <param name="m">Number of rows</param>
            <param name="n">Number of columns</param>
            <param name="perm">Mapping for rows, must be converted fom LAPACK version to single indices </param>
            <param name="val">Value for diagonal entries</param>
            <returns>Newly created physical array with the lower triangle of A</returns>
            <remarks>No checks are made for m,n fit inside A!</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.perm2indicesForward(System.Int32[])">
            <summary>
            Relabel permutation indices from LAPACK ?getrf
            </summary>
            <param name="perm">Lapack pivoting permutation array</param>
            <returns>Index mapping for direct addressing the rows </returns>
            <remarks>Exchange the row labels in the same manner as LAPACK did for pivoting</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.perm2indicesBackward(System.Int32[])">
            <summary>
            Relabel permutation indices from LAPACK ?getrf - backward version
            </summary>
            <param name="perm">Lapack pivoting permutation array</param>
            <returns>Index mapping for direct addressing the rows </returns>
            <remarks>Exchange the row labels in the same manner as LAPACK did for pivoting, but backwards</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{System.Double})">
            <summary>
            Determine if matrix A is a lower triangular matrix
            </summary>
            <param name="A">Matrix of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{System.Double})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{System.Double})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{System.Double})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{System.Double})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Determine if matrix A is a lower triangular matrix
            </summary>
            <param name="A">Matrix of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is a lower triangular matrix
            </summary>
            <param name="A">Matrix of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Determine if matrix A is a lower triangular matrix
            </summary>
            <param name="A">Matrix of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Determine if matrix A is a lower triangular matrix
            </summary>
            <param name="A">Matrix of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Determine if matrix A is a lower triangular matrix
            </summary>
            <param name="A">Matrix of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{System.Single})">
            <summary>
            Determine if matrix A is a lower triangular matrix
            </summary>
            <param name="A">Matrix of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{System.Single})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{System.Single})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{System.Single})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{System.Single})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)">
            <summary>
            Maximum values along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int32},System.Int32)">
            <summary>
            Maximum values along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32},System.Int32)">
            <summary>
            Maximum values along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Byte},ILNumerics.ILOutArray{System.Int32},System.Int32)">
            <summary>
            Maximum values along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{System.Int32},System.Int32)">
            <summary>
            Maximum values along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Int32},System.Int32)">
            <summary>
            Maximum values along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{System.Int32},System.Int32)">
            <summary>
            Maximum values along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Maximum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the maximum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Maximum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the maximum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Maximum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the maximum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Maximum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the maximum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Maximum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the maximum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Maximum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the maximum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Maximum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the maximum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.maxall(ILNumerics.ILInArray{System.Double})">
            <summary>
            Maximum for all elements of A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar maximum of all elements for A</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.maxall(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Maximum for all elements of A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar maximum of all elements for A</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.maxall(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Maximum for all elements of A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar maximum of all elements for A</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.maxall(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Maximum for all elements of A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar maximum of all elements for A</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.maxall(ILNumerics.ILInArray{System.Single})">
            <summary>
            Maximum for all elements of A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar maximum of all elements for A</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            Mean of array along specified dimension
            </summary>
            <param name="A">Input Array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of elements along specified or first non singleton dimension</returns>
            <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{System.Int64},System.Int32)">
            <summary>
            Mean of array along specified dimension
            </summary>
            <param name="A">Input Array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of elements along specified or first non singleton dimension</returns>
            <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{System.Int32},System.Int32)">
            <summary>
            Mean of array along specified dimension
            </summary>
            <param name="A">Input Array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of elements along specified or first non singleton dimension</returns>
            <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{System.Byte},System.Int32)">
            <summary>
            Mean of array along specified dimension
            </summary>
            <param name="A">Input Array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of elements along specified or first non singleton dimension</returns>
            <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Mean of array along specified dimension
            </summary>
            <param name="A">Input Array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of elements along specified or first non singleton dimension</returns>
            <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            Mean of array along specified dimension
            </summary>
            <param name="A">Input Array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of elements along specified or first non singleton dimension</returns>
            <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Mean of array along specified dimension
            </summary>
            <param name="A">Input Array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of elements along specified or first non singleton dimension</returns>
            <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions
            </summary>
            <param name="X">Vector of x values</param>
            <param name="Y">Vector of y values</param>
            <param name="outY">[Output, Optional]: if on entry outY is not null, on return it will hold the values for the Y dimension</param>
            <returns>X values matrix along the values of the X input array. Corresponding values for Y are returned in outY</returns>
            <remarks>The matrices returned can be utilize to evaluate and visualize functions of 2 variables X and Y.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions
            </summary>
            <param name="X">Vector of x values</param>
            <param name="Y">Vector of y values</param>
            <param name="Z">Vector of z values</param>
            <param name="outY">[Output, Optional] If on entry outY is not null, on return it will hold the values for the y dimension</param>
            <param name="outZ">[Output, Optional] If on entry outZ is not null, on return it will hold the values for the z dimension</param>
            <returns>X value array along the values of the X input vector, arrays for y and z dimensions are returned in outY and outZ respectively</returns>
            <remarks>The arrays returned can be used to evaluate and visualize functions of 3 variables X, Y and Z.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int64})">
            <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions
            </summary>
            <param name="X">Vector of x values</param>
            <param name="Y">Vector of y values</param>
            <param name="outY">[Output, Optional]: if on entry outY is not null, on return it will hold the values for the Y dimension</param>
            <returns>X values matrix along the values of the X input array. Corresponding values for Y are returned in outY</returns>
            <remarks>The matrices returned can be utilize to evaluate and visualize functions of 2 variables X and Y.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int64},ILNumerics.ILOutArray{System.Int64})">
            <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions
            </summary>
            <param name="X">Vector of x values</param>
            <param name="Y">Vector of y values</param>
            <param name="Z">Vector of z values</param>
            <param name="outY">[Output, Optional] If on entry outY is not null, on return it will hold the values for the y dimension</param>
            <param name="outZ">[Output, Optional] If on entry outZ is not null, on return it will hold the values for the z dimension</param>
            <returns>X value array along the values of the X input vector, arrays for y and z dimensions are returned in outY and outZ respectively</returns>
            <remarks>The arrays returned can be used to evaluate and visualize functions of 3 variables X, Y and Z.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32})">
            <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions
            </summary>
            <param name="X">Vector of x values</param>
            <param name="Y">Vector of y values</param>
            <param name="outY">[Output, Optional]: if on entry outY is not null, on return it will hold the values for the Y dimension</param>
            <returns>X values matrix along the values of the X input array. Corresponding values for Y are returned in outY</returns>
            <remarks>The matrices returned can be utilize to evaluate and visualize functions of 2 variables X and Y.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Int32})">
            <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions
            </summary>
            <param name="X">Vector of x values</param>
            <param name="Y">Vector of y values</param>
            <param name="Z">Vector of z values</param>
            <param name="outY">[Output, Optional] If on entry outY is not null, on return it will hold the values for the y dimension</param>
            <param name="outZ">[Output, Optional] If on entry outZ is not null, on return it will hold the values for the z dimension</param>
            <returns>X value array along the values of the X input vector, arrays for y and z dimensions are returned in outY and outZ respectively</returns>
            <remarks>The arrays returned can be used to evaluate and visualize functions of 3 variables X, Y and Z.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions
            </summary>
            <param name="X">Vector of x values</param>
            <param name="Y">Vector of y values</param>
            <param name="outY">[Output, Optional]: if on entry outY is not null, on return it will hold the values for the Y dimension</param>
            <returns>X values matrix along the values of the X input array. Corresponding values for Y are returned in outY</returns>
            <remarks>The matrices returned can be utilize to evaluate and visualize functions of 2 variables X and Y.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions
            </summary>
            <param name="X">Vector of x values</param>
            <param name="Y">Vector of y values</param>
            <param name="Z">Vector of z values</param>
            <param name="outY">[Output, Optional] If on entry outY is not null, on return it will hold the values for the y dimension</param>
            <param name="outZ">[Output, Optional] If on entry outZ is not null, on return it will hold the values for the z dimension</param>
            <returns>X value array along the values of the X input vector, arrays for y and z dimensions are returned in outY and outZ respectively</returns>
            <remarks>The arrays returned can be used to evaluate and visualize functions of 3 variables X, Y and Z.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32)">
            <summary>Minimum value along specified dimension</summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int32},System.Int32)">
            <summary>Minimum value along specified dimension</summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32},System.Int32)">
            <summary>Minimum value along specified dimension</summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Byte},ILNumerics.ILOutArray{System.Int32},System.Int32)">
            <summary>Minimum value along specified dimension</summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{System.Int32},System.Int32)">
            <summary>Minimum value along specified dimension</summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Int32},System.Int32)">
            <summary>Minimum value along specified dimension</summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{System.Int32},System.Int32)">
            <summary>Minimum value along specified dimension</summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If I is null those indices will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Minimum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the minimum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Minimum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the minimum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Minimum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the minimum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Minimum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the minimum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Minimum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the minimum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Minimum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the minimum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Minimum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the minimum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.Double})">
            <summary>
            Minimum of all elements of array A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="!:ILNumerics.ILMath.min(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;,int)"/>
        </member>
        <member name="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Minimum of all elements of array A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="!:ILNumerics.ILMath.min(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;,int)"/>
        </member>
        <member name="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Minimum of all elements of array A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="!:ILNumerics.ILMath.min(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;,int)"/>
        </member>
        <member name="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Minimum of all elements of array A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="!:ILNumerics.ILMath.min(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;,int)"/>
        </member>
        <member name="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.Single})">
            <summary>
            Minimum of all elements of array A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="!:ILNumerics.ILMath.min(ILInArray&lt;double&gt;,ILOutArray&lt;double&gt;,int)"/>
        </member>
        <member name="M:ILNumerics.ILMath.mod(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Modulus of array elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of elementwise modulus operation</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.mod(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Modulus of array elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of elementwise modulus operation</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.mod(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Modulus of array elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of elementwise modulus operation</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.mod(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Modulus of array elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of elementwise modulus operation</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.mod(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Modulus of array elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of elementwise modulus operation</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{System.Double}[])">
            <summary>
            Multiplicate an arbitrary number of matrices from left to right
            </summary>
            <param name="matrices">Input matrices </param>
            <returns>Result of matrix multiplication for all matrices</returns>
        </member>
        <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            General matrix multiply this array
            </summary>
            <param name="A">Input matrix A</param>
            <param name="B">Input matrix B</param>
            <returns>Matrix with result of matrix multiplication</returns>
            <remarks>Both arrays must be matrices with matching dimension length. Therefore the number of rows 
            of B must equal the number of columns of A. An ILArgumentSizeException will be thrown otherwise. 
            The multiplication will be carried out inside optimized BLAS libraries if availiable. If not it 
            will be done in managed code. 
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">If at least one arrays is not a matrix</exception>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If the size of both matrices do not match</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{System.Single}[])">
            <summary>
            Multiplicate an arbitrary number of matrices from left to right
            </summary>
            <param name="matrices">Input matrices </param>
            <returns>Result of matrix multiplication for all matrices</returns>
        </member>
        <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            General matrix multiply this array
            </summary>
            <param name="A">Input matrix A</param>
            <param name="B">Input matrix B</param>
            <returns>Matrix with result of matrix multiplication</returns>
            <remarks>Both arrays must be matrices with matching dimension length. Therefore the number of rows 
            of B must equal the number of columns of A. An ILArgumentSizeException will be thrown otherwise. 
            The multiplication will be carried out inside optimized BLAS libraries if availiable. If not it 
            will be done in managed code. 
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">If at least one arrays is not a matrix</exception>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If the size of both matrices do not match</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{ILNumerics.fcomplex}[])">
            <summary>
            Multiplicate an arbitrary number of matrices from left to right
            </summary>
            <param name="matrices">Input matrices </param>
            <returns>Result of matrix multiplication for all matrices</returns>
        </member>
        <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            General matrix multiply this array
            </summary>
            <param name="A">Input matrix A</param>
            <param name="B">Input matrix B</param>
            <returns>Matrix with result of matrix multiplication</returns>
            <remarks>Both arrays must be matrices with matching dimension length. Therefore the number of rows 
            of B must equal the number of columns of A. An ILArgumentSizeException will be thrown otherwise. 
            The multiplication will be carried out inside optimized BLAS libraries if availiable. If not it 
            will be done in managed code. 
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">If at least one arrays is not a matrix</exception>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If the size of both matrices do not match</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{ILNumerics.complex}[])">
            <summary>
            Multiplicate an arbitrary number of matrices from left to right
            </summary>
            <param name="matrices">Input matrices </param>
            <returns>Result of matrix multiplication for all matrices</returns>
        </member>
        <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            General matrix multiply this array
            </summary>
            <param name="A">Input matrix A</param>
            <param name="B">Input matrix B</param>
            <returns>Matrix with result of matrix multiplication</returns>
            <remarks>Both arrays must be matrices with matching dimension length. Therefore the number of rows 
            of B must equal the number of columns of A. An ILArgumentSizeException will be thrown otherwise. 
            The multiplication will be carried out inside optimized BLAS libraries if availiable. If not it 
            will be done in managed code. 
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">If at least one arrays is not a matrix</exception>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If the size of both matrices do not match</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Multiply arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Multiply arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Multiply arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Multiply arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Multiply arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Multiply arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Multiply arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.mvnrnd(System.Int32)">
            <summary>
            Choose samples from a multivariate random distribution
            </summary>
            <returns>n random numbers as taken from the multivariate random probability distribution with zero mean and unity covariance</returns>
            <remarks><para>This is an alias for <see cref="M:ILNumerics.ILMath.randn(params int[])"/>. If n was not specified, a single random number is generated.</para>
            <para>The samples are returned as row vector of size 1 x n.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mvnrnd">
            <summary>
            Choose one sample from a multivariate random distribution
            </summary>
            <returns>Single random number, taken from the multivariate random probability distribution with zero mean and unity covariance</returns>
            <remarks><para>This is an alias for <see cref="M:ILNumerics.ILMath.randn(params int[])"/>. A single (scalar) random number is generated.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mvnrnd(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            choose samples from a multivariate random distribution  
            </summary>
            <param name="inMu">[optional] centers, size d x n; if d x 1 is given, optional parameter <paramref name="n"/> is used to replicate mu accordingly, if null, the values will be genereated with a center of zero</param>
            <param name="inSigma">[optional] covariance matrix, must be positive definite, size d x d or vector of lenght d, if null (not set), unitiy matrix is expected</param>
            <param name="n">[optional] number of samples to generate, per default (-1) the number of columns of <paramref name="mu"/> defines that number</param>
            <param name="sigmaIsSquaredCov">[optional] if false: safe the effort of finding the square root of <paramref name="sigma"/> parameter; default: true</param>
            <returns>random numbers as taken from the multivariate random probability distribution given by mu and sigma</returns>
            <remarks><para>In order to safe the step of finding the root of sigma, the following options exist: 
            <list type="bullet">
            <item>Provide only the diagonal of a (virtual) diagonal matrix to <paramref name="sigma"/>.</item>
            <item>Compute the root manually, give it to sigma and set <paramref name="sigmaIsSquaredCov"/> to false.</item>
            </list></para>
            <para>In case <paramref name="sigmaIsSquaredCov"/> set to 'false' and <paramref name="sigma"/> is given, 
            the root is computed via cholesky factorization. The result of the last root finding process is cached and reused for 
            subsequent requests with the same set of <paramref name="n"/> and <paramref name="sigma"/> parameters.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mvnrnd(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Int32,System.Boolean)">
            <summary>
            choose samples from a multivariate random distribution  
            </summary>
            <param name="inMu">[optional] centers, size d x n; if d x 1 is given, optional parameter <paramref name="n"/> is used to replicate mu accordingly, if null, the values will be genereated with a center of zero</param>
            <param name="inSigma">[optional] covariance matrix, must be positive definite, size d x d or vector of lenght d, if null (not set), unitiy matrix is expected</param>
            <param name="n">[optional] number of samples to generate, per default (-1) the number of columns of <paramref name="mu"/> defines that number</param>
            <param name="sigmaIsSquaredCov">[optional] if false: safe the effort of finding the square root of <paramref name="sigma"/> parameter; default: true</param>
            <returns>random numbers as taken from the multivariate random probability distribution given by mu and sigma</returns>
            <remarks><para>In order to safe the step of finding the root of sigma, the following options exist: 
            <list type="bullet">
            <item>Provide only the diagonal of a (virtual) diagonal matrix to <paramref name="sigma"/>.</item>
            <item>Compute the root manually, give it to sigma and set <paramref name="sigmaIsSquaredCov"/> to false.</item>
            </list></para>
            <para>In case <paramref name="sigmaIsSquaredCov"/> set to 'false' and <paramref name="sigma"/> is given, 
            the root is computed via cholesky factorization. The result of the last root finding process is cached and reused for 
            subsequent requests with the same set of <paramref name="n"/> and <paramref name="sigma"/> parameters.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.String},ILNumerics.ILInArray{System.String})">
            <summary>
            Elementwise logical 'not equal' operator
            </summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A not equal elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">if neither of A or B is scalar and the size of both arrays does not match</exception>
        </member>
        <member name="M:ILNumerics.ILMath.New``1(System.Int32)">
             <summary>
             Request System.Array <typeparamref name="T"/>[] from ILNumerics Memory Pool
             </summary>
             <typeparam name="T">the element type</typeparam>
             <param name="minLength"><b>minimal</b> length of the array returned</param>
             <returns>A system array of element type <typeparamref name="T"/> and minimal length <paramref name="minLength"/>.</returns>
             <remarks>
             <para>This function fetches a System.Array from the collection of available arrays which are currently held in the ILNumerics Memory Pool. 
             If no matching array is available, a new array will be allocated from the runtime.</para>
             <para>Important note: the array returned is not guaranteed to be cleared! Furthermore, it may contain more elements than requested by <paramref name="minLength"/>!</para>
             <para>The array returned is fetched from the collection of available arrays in the pool. If no matching array was found, a new array is requested from the managed heap.</para>
             <para>The user is reponsible to return the array to the pool once finished using it. The <see cref="M:ILNumerics.ILMath.free``1(``0[])"/> method should be used for returning an array.</para>
             <para>Keep in mind, the array returned may be <b>longer</b> as requested! Therefore, in order to reference its elements use the <paramref name="length"/> parameter rather than the System.Array.Length property.</para>
             <example>A system array is needed inside a computational loop. The loop calls a native function repeatedly which requests a working array. The System.Array is requested from the pool and returned to the pool after usage.
             <code><![CDATA[
            [System.Runtime.InteropServices.DllImport("myDLL")]
            private static extern void MyDllFunc(double[] a, int lenA, double[] b, double[] work, int lenWork);
            
            public static ILRetArray<double> MyFunc(ILInArray<double> A) {
                using (ILScope.Enter(A)) {
                    // myDllFunc needs storage for the result
                    ILArray<double> ret = zeros(A.Size);
                    ILArray<double> tmpRow = zeros(1, A.S[1]);
            
                    // myDllFunc needs a working storage:
                    double[] work = New<double>(A.S[1]);
                    // for all rows of A use the same working array
                    for (int i = 0; i < A.S[0]; i++) {
                        using (ILScope.Enter()) {
                            ILArray<double> ARow = A[i, full];
                            MyDllFunc(ARow.GetArrayForRead(), A.Length, tmpRow.GetArrayForWrite(), work, A.Length);
                            ret[i, full] = tmpRow;
                        }
                    }
                    // return the System.Array to the pool 
                    free(work);
                    return ret;
                }
            }
             ]]></code>
             However, in most situations, the handling of system.arrays directly can be circumvented. The same goal as in the 
             example could be archieved as follows: 
             <code><![CDATA[       
             public static ILRetArray<double> MyFunc(ILInArray<double> A) {
            using (ILScope.Enter(A)) {
                // myDllFunc needs storage for the result
                ILArray<double> ret = zeros(A.Size);
                ILArray<double> tmpRow = zeros(1, A.S[1]);
                // myDllFunc needs a working storage. We us a regular ILNumerics array 
                // which we dont have to free afterwards. 
                ILArray<double> work = zeros(tmpRow.S); 
            
                // for all rows of A use the same working array
                for (int i = 0; i < A.S[0]; i++) {
                    using (ILScope.Enter()) {
                        ILArray<double> ARow = A[i, full];
                        MyDllFunc(ARow.GetArrayForRead(), A.Length, tmpRow.GetArrayForWrite(), work.GetArrayForWrite(), A.Length);
                        ret[i, full] = tmpRow;
                    }
                }
                // returning the working storage is not needed here...
            
                return ret;
            }
            }]]></code>
             Both examples archieve a 100% memory efficiency by completely reusing the memory needed within the function. 
             </example>
             </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.norm(ILNumerics.ILInArray{System.Double},System.Double)">
            <summary>
            Vector or matrix norm
            </summary>
            <param name="A">input matrix or vector</param>
            <param name="degree">[optional] degree of norm (default: 2)</param>
            <returns>Array of same type as input array A</returns>
            <remarks>For vectors, <paramref name="degree"/> must be one of: 
            <list type="bullet">
            <item>0 : returns sqrt(sum(A * A))</item>
            <item>arbitrary double value : returns sum(pow(abs(A),degree))^(1/degree)</item>
            <item>System.double.PositiveInfinity: return Max(abs(A))</item>
            <item>System.double.NegativeInfinity: return Min(abs(A))</item>
            </list>
            For matrices <paramref name="degree"/> must be one out of: 
            <list type="bullet">
            <item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A.T))))</item>
            <item>1: returns 1-norm, max(sum(abs(A)))</item>
            <item>2: returns the largest singular value of A, max(svd(A))</item>
            <item>PositiveInfinity: returns maxall(sum(abs(A), 1)), the largest value of the sums along the rows</item>
            </list>
            <para>norm(A,0) with A being a vector extends naturally to the frobenius norm for matrices.</para>
            <para>For empty arrays A, scalar 0 is returned.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.norm(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Double)">
            <summary>
            Vector or matrix norm
            </summary>
            <param name="A">input matrix or vector</param>
            <param name="degree">[optional] degree of norm (default: 2)</param>
            <returns>Array of same type as input array A</returns>
            <remarks>For vectors, <paramref name="degree"/> must be one of: 
            <list type="bullet">
            <item>0 : returns sqrt(sum(A * A))</item>
            <item>arbitrary double value : returns sum(pow(abs(A),degree))^(1/degree)</item>
            <item>System.double.PositiveInfinity: return Max(abs(A))</item>
            <item>System.double.NegativeInfinity: return Min(abs(A))</item>
            </list>
            For matrices <paramref name="degree"/> must be one out of: 
            <list type="bullet">
            <item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A.T))))</item>
            <item>1: returns 1-norm, max(sum(abs(A)))</item>
            <item>2: returns the largest singular value of A, max(svd(A))</item>
            <item>PositiveInfinity: returns maxall(sum(abs(A), 1)), the largest value of the sums along the rows</item>
            </list>
            <para>norm(A,0) with A being a vector extends naturally to the frobenius norm for matrices.</para>
            <para>For empty arrays A, scalar 0 is returned.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.norm(ILNumerics.ILInArray{System.Single},System.Double)">
            <summary>
            Vector or matrix norm
            </summary>
            <param name="A">input matrix or vector</param>
            <param name="degree">[optional] degree of norm (default: 2)</param>
            <returns>Array of same type as input array A</returns>
            <remarks>For vectors, <paramref name="degree"/> must be one of: 
            <list type="bullet">
            <item>0 : returns sqrt(sum(A * A))</item>
            <item>arbitrary double value : returns sum(pow(abs(A),degree))^(1/degree)</item>
            <item>System.double.PositiveInfinity: return Max(abs(A))</item>
            <item>System.double.NegativeInfinity: return Min(abs(A))</item>
            </list>
            For matrices <paramref name="degree"/> must be one out of: 
            <list type="bullet">
            <item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A.T))))</item>
            <item>1: returns 1-norm, max(sum(abs(A)))</item>
            <item>2: returns the largest singular value of A, max(svd(A))</item>
            <item>PositiveInfinity: returns maxall(sum(abs(A), 1)), the largest value of the sums along the rows</item>
            </list>
            <para>norm(A,0) with A being a vector extends naturally to the frobenius norm for matrices.</para>
            <para>For empty arrays A, scalar 0 is returned.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.norm(ILNumerics.ILInArray{ILNumerics.complex},System.Double)">
            <summary>
            Vector or matrix norm
            </summary>
            <param name="A">input matrix or vector</param>
            <param name="degree">[optional] degree of norm (default: 2)</param>
            <returns>Array of same type as input array A</returns>
            <remarks>For vectors, <paramref name="degree"/> must be one of: 
            <list type="bullet">
            <item>0 : returns sqrt(sum(A * A))</item>
            <item>arbitrary double value : returns sum(pow(abs(A),degree))^(1/degree)</item>
            <item>System.double.PositiveInfinity: return Max(abs(A))</item>
            <item>System.double.NegativeInfinity: return Min(abs(A))</item>
            </list>
            For matrices <paramref name="degree"/> must be one out of: 
            <list type="bullet">
            <item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A.T))))</item>
            <item>1: returns 1-norm, max(sum(abs(A)))</item>
            <item>2: returns the largest singular value of A, max(svd(A))</item>
            <item>PositiveInfinity: returns maxall(sum(abs(A), 1)), the largest value of the sums along the rows</item>
            </list>
            <para>norm(A,0) with A being a vector extends naturally to the frobenius norm for matrices.</para>
            <para>For empty arrays A, scalar 0 is returned.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ones(System.Int32[])">
            <summary>
            Create new double array, set initial values to 1
            </summary>
            <returns>array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.ones(ILNumerics.NumericType,ILNumerics.ILSize)">
            <summary>
            Create array initialized with all elements set to one
            </summary>
            <param name="type">Numeric type specification. One value out of the types listed in the <see cred="ILNumerics.NumericType"/>
            enum.</param>
            <param name="size">Size descriptor</param>
            <returns>Array of inner type corresponding to <paramref name="type"/> argument.</returns>
            <remarks>The array returned must be casted to the appropriate actual type afterwards and assigned to a concrete array! Caution: 
            This overload is provided for compatibility reasons only! Use <see cref="M:ILNumerics.ILMath.ones``1(ILNumerics.ILSize)"/> instead.
            <para>
            <list type="number"> 
            <listheader>The following types are supported: </listheader>
            <item>Double</item>
            <item>Single</item>
            <item>Complex</item>
            <item>FComplex</item>
            <item>Byte</item>
            <item>Int32</item>
            <item>Int64</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ones``1(System.Int32[])">
            <summary>
            Create array initialized with all elements set to one
            </summary>
            <typeparam name="T">Numeric type specification.</typeparam>
            <param name="size">Size descriptor</param>
            <returns>Array of inner type corresponding to the given type.</returns>
             <remarks>The array returned may be casted to the appropriate actual type afterwards. 
            <para>
            <list type="number"> 
            <listheader>The following types are supported: </listheader>
            <item>Double</item>
            <item>Single</item>
            <item>complex</item>
            <item>fcomplex</item>
            <item>Byte</item>
            <item>Int32</item>
            <item>Int64</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ones``1(ILNumerics.ILSize)">
            <summary>
            Create array initialized with all elements set to one
            </summary>
            <typeparam name="T">Numeric type specification.</typeparam>
            <param name="size">Size descriptor</param>
            <returns>Array of inner type corresponding to the given type.</returns>
             <remarks>The array returned may be casted to the appropriate actual type afterwards. 
            <para>
            <list type="number"> 
            <listheader>The following types are supported: </listheader>
            <item>Double</item>
            <item>Single</item>
            <item>complex</item>
            <item>fcomplex</item>
            <item>Byte</item>
            <item>Int32</item>
            <item>Int64</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ones(ILNumerics.ILSize)">
            <summary>
            Create new double array, set initial values to 1
            </summary>
            <returns>Array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'or' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'or' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'or' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'or' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'or' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'or' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'or' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double})">
            <summary>
            Pseudo - inverse of input argument M
            </summary>
            <param name="M">Input matrix M</param>
            <returns>Pseudo inverse of input matrix M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) being the largest singular value of M, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            You may use a overloaded function to define an alternative tolerance. 
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double},System.Double)"/>
        </member>
        <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double},System.Double)">
            <summary>
            Pseudo inverse of input matrix M
            </summary>
            <param name="M">Input matrix M</param>
            <param name="tolerance">Tolerance, see remarks (default = -1; use default tolerance)</param>
            <returns>Pseudo inverse of M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) being the largest singular value of M, </item>
            <item>Double.epsilon - the smallest constructable double precision number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Single})">
            <summary>
            Pseudo - inverse of input argument M
            </summary>
            <param name="M">Input matrix M</param>
            <returns>Pseudo inverse of input matrix M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) being the largest singular value of M, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            You may use a overloaded function to define an alternative tolerance. 
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double},System.Double)"/>
        </member>
        <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Single},System.Single)">
            <summary>
            Pseudo inverse of input matrix M
            </summary>
            <param name="M">Input matrix M</param>
            <param name="tolerance">Tolerance, see remarks (default = -1; use default tolerance)</param>
            <returns>Pseudo inverse of M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) being the largest singular value of M, </item>
            <item>Double.epsilon - the smallest constructable double precision number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Pseudo - inverse of input argument M
            </summary>
            <param name="M">Input matrix M</param>
            <returns>Pseudo inverse of input matrix M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) being the largest singular value of M, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            You may use a overloaded function to define an alternative tolerance. 
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double},System.Double)"/>
        </member>
        <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.fcomplex)">
            <summary>
            Pseudo inverse of input matrix M
            </summary>
            <param name="M">Input matrix M</param>
            <param name="tolerance">Tolerance, see remarks (default = -1; use default tolerance)</param>
            <returns>Pseudo inverse of M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) being the largest singular value of M, </item>
            <item>Double.epsilon - the smallest constructable double precision number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Pseudo - inverse of input argument M
            </summary>
            <param name="M">Input matrix M</param>
            <returns>Pseudo inverse of input matrix M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) being the largest singular value of M, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            You may use a overloaded function to define an alternative tolerance. 
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double},System.Double)"/>
        </member>
        <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.complex)">
            <summary>
            Pseudo inverse of input matrix M
            </summary>
            <param name="M">Input matrix M</param>
            <param name="tolerance">Tolerance, see remarks (default = -1; use default tolerance)</param>
            <returns>Pseudo inverse of M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) being the largest singular value of M, </item>
            <item>Double.epsilon - the smallest constructable double precision number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.pol2cart(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Transform polar/ cylindrical coordinates into scalar coordinates
            </summary>
            <param name="theta">Angle to x axis</param>
            <param name="radius">Radius from z axis</param>
            <param name="Z">Height</param>
            <param name="outY">If on entry not null, the Y components are returned in outY</param>
            <param name="outZ">If on entry not null, the Z components are returned in outZ</param>
            <returns>X component, Y and Z are returned as out parameter if requested</returns>
            <remarks>Theta, radius and Z must be of the same size or either one may be scalar. 
            Scalar coordinate arrays returned are of the same size then the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.pol2cart(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Transform polar/ cylindrical coordinates into scalar coordinates
            </summary>
            <param name="theta">Angle to x axis</param>
            <param name="radius">Radius from z axis</param>
            <param name="Z">Height</param>
            <param name="outY">If on entry not null, the Y components are returned in outY</param>
            <param name="outZ">If on entry not null, the Z components are returned in outZ</param>
            <returns>X component, Y and Z are returned as out parameter if requested</returns>
            <remarks>Theta, radius and Z must be of the same size or either one may be scalar. 
            Scalar coordinate arrays returned are of the same size then the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Power elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise result of A <sup>B</sup></returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Power elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise result of A <sup>B</sup></returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Power elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise result of A <sup>B</sup></returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Power elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise result of A <sup>B</sup></returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Power elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise result of A <sup>B</sup></returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Power elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise result of A <sup>B</sup></returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Power elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise result of A <sup>B</sup></returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>Product of array elements along specific dimension</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{System.Int64},System.Int32)">
            <summary>Product of array elements along specific dimension</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{System.Int32},System.Int32)">
            <summary>Product of array elements along specific dimension</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{System.Byte},System.Int32)">
            <summary>Product of array elements along specific dimension</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>Product of array elements along specific dimension</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>Product of array elements along specific dimension</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having dim's dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>Product of array elements along specific dimension</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having dim's dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double})">
            <summary>
            QR decomposition - raw Lapack output
            </summary>
            <param name="A">Input matrix A</param>
            <returns>Orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
            <remarks><para>Input matrix A will not be altered. </para>
            <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This means that it contains 
            the decomposition factors Q and R, but they are combined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> 
            instead, which returns those factors separately.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            QR decomposition, returning Q and R
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition, size [m x m]</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds within roundoff errors. ('*' denotes 
            matrix multiplication)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)">
            <summary>
            QR decomposition, returning Q and R, optionally economical sized
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
            <param name="economySize">If true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
            <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize"/> (see remarks below)</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            QR decomposition with pivoting
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
            <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x min(m,n)]</returns>
            <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.</remarks>
            <seealso cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)">
            <summary>
            QR decomposition with pivoting, possibly economical sized
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize"/> (see remarks).</param>
            <param name="economySize"><para>If true, <list type="bullet">
            <item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item>
            <item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
            <para>If false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/></para>
            </param>
            <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize"/> is 
            true, a row vector of length n otherwise</para></param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks><para> If <paramref name="economySize"/> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds within 
            roundoff errors. </para>
            <para>If <paramref name="economySize"/> is true, E will be a permutation 
            vector and the equation A[":",E] == Q * R holds (except roundoff).</para>
            <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Single})">
            <summary>
            QR decomposition - raw Lapack output
            </summary>
            <param name="A">Input matrix A</param>
            <returns>Orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
            <remarks><para>Input matrix A will not be altered. </para>
            <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This means that it contains 
            the decomposition factors Q and R, but they are combined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> 
            instead, which returns those factors separately.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            QR decomposition, returning Q and R
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition, size [m x m]</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds within roundoff errors. ('*' denotes 
            matrix multiplication)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean)">
            <summary>
            QR decomposition, returning Q and R, optionally economical sized
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
            <param name="economySize">If true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
            <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize"/> (see remarks below)</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            QR decomposition with pivoting
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
            <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x min(m,n)]</returns>
            <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.</remarks>
            <seealso cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean)">
            <summary>
            QR decomposition with pivoting, possibly economical sized
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize"/> (see remarks).</param>
            <param name="economySize"><para>If true, <list type="bullet">
            <item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item>
            <item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
            <para>If false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/></para>
            </param>
            <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize"/> is 
            true, a row vector of length n otherwise</para></param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks><para> If <paramref name="economySize"/> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds within 
            roundoff errors. </para>
            <para>If <paramref name="economySize"/> is true, E will be a permutation 
            vector and the equation A[":",E] == Q * R holds (except roundoff).</para>
            <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            QR decomposition - raw Lapack output
            </summary>
            <param name="A">Input matrix A</param>
            <returns>Orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
            <remarks><para>Input matrix A will not be altered. </para>
            <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This means that it contains 
            the decomposition factors Q and R, but they are combined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> 
            instead, which returns those factors separately.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            QR decomposition, returning Q and R
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition, size [m x m]</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds within roundoff errors. ('*' denotes 
            matrix multiplication)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean)">
            <summary>
            QR decomposition, returning Q and R, optionally economical sized
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
            <param name="economySize">If true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
            <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize"/> (see remarks below)</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            QR decomposition with pivoting
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
            <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x min(m,n)]</returns>
            <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.</remarks>
            <seealso cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean)">
            <summary>
            QR decomposition with pivoting, possibly economical sized
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize"/> (see remarks).</param>
            <param name="economySize"><para>If true, <list type="bullet">
            <item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item>
            <item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
            <para>If false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/></para>
            </param>
            <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize"/> is 
            true, a row vector of length n otherwise</para></param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks><para> If <paramref name="economySize"/> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds within 
            roundoff errors. </para>
            <para>If <paramref name="economySize"/> is true, E will be a permutation 
            vector and the equation A[":",E] == Q * R holds (except roundoff).</para>
            <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            QR decomposition - raw Lapack output
            </summary>
            <param name="A">Input matrix A</param>
            <returns>Orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
            <remarks><para>Input matrix A will not be altered. </para>
            <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This means that it contains 
            the decomposition factors Q and R, but they are combined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> 
            instead, which returns those factors separately.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            QR decomposition, returning Q and R
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition, size [m x m]</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds within roundoff errors. ('*' denotes 
            matrix multiplication)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean)">
            <summary>
            QR decomposition, returning Q and R, optionally economical sized
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
            <param name="economySize">If true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
            <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize"/> (see remarks below)</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            QR decomposition with pivoting
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
            <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x min(m,n)]</returns>
            <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.</remarks>
            <seealso cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean)">
            <summary>
            QR decomposition with pivoting, possibly economical sized
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize"/> (see remarks).</param>
            <param name="economySize"><para>If true, <list type="bullet">
            <item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item>
            <item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
            <para>If false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/></para>
            </param>
            <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize"/> is 
            true, a row vector of length n otherwise</para></param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks><para> If <paramref name="economySize"/> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds within 
            roundoff errors. </para>
            <para>If <paramref name="economySize"/> is true, E will be a permutation 
            vector and the equation A[":",E] == Q * R holds (except roundoff).</para>
            <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.r(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Region creator for subarray specifications
            </summary>
            <param name="start">Begin of region, index of first element</param>
            <param name="end">End of region, last element</param>
            <returns>An array which specifies all indices of the region</returns>
            <remarks>The r function provides a shorter way to specify regions in subarray
            expressions. Other than alternatives like <see cref="M:ILNumerics.ILMath.vec(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)"/>, 
            it also enables the use of the <see cref="P:ILNumerics.ILMath.end"/> keyword - even in 
            conjunction with simple mathematical expressions.</remarks>
            <example><code>ILArray&lt;double&gt; A = counter(5,4,3), B;
            
            // the following subarrays will all create the same B: 
            B = A[full,r(1,end-1),full]; 
            B = A[r(0,end),"1,2",":"];
            B = A[":;1:2;0:end"];
            
            // however, these expression will <b>not</b> work:
            B = A[":;0:end-1,:"]; // 'end' expression evaluation is not supported in strings. 
            </code></example>
        </member>
        <member name="M:ILNumerics.ILMath.r(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Stepped region creator for subarray specifications
            </summary>
            <param name="start">Begin of region, index of first element</param>
            <param name="end">End of region, last element</param>
            <param name="step">Increment, distance between created indices</param>
            <returns>An array which specifies the indices of the region</returns>
            <remarks>The r function provides a shorter way to specify regions in subarray
            expressions. Other than alternatives like <see cref="M:ILNumerics.ILMath.vec(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)"/>, 
            it also enables the use of the <see cref="P:ILNumerics.ILMath.end"/> keyword - even in 
            conjunction with simple mathematical expressions.</remarks>
            <example><code>ILArray&lt;double&gt; A = counter(5,4,3), B;
            
            // the following subarrays will all create the same B: 
            B = A[full,r(1,end-1),full]; 
            B = A[r(0,end),"1,2",":"];
            B = A[":;1:2;0:end"];
            
            // however, these expression will <b>not</b> work:
            B = A[":;0:end-1,:"]; // 'end' expression evaluation is not supported in strings. 
            </code></example>
        </member>
        <member name="M:ILNumerics.ILMath.rand(System.Int32[])">
            <summary>
            Pseudo random N-dimensional array elements.
            </summary>
            <param name="dimensions">int array or single int paramters specifying 
            dimensions for new array to be created.</param>
            <returns>N-dimensional array filled with random numbers.</returns>
            <remarks><para>The elements lie within the range 0.0 ... 1.0 and are uniformly 
            distributed.</para>
            <para>The initial seed will be set to Environment.TickCount on the first call.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.randn(System.Int32[])">
            <summary>
            Normal randomly-distributed N-dimensional array elements.
            </summary>
            <param name="dimensions">int array or single int paramters specifying 
            dimensions for new array to be created.</param>
            <returns>N-dimensional array filled with random numbers.</returns>
            <remarks>The elements lie within the range 0.0 ... 1.0 and are choosen to be normally 
            distributed.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.randperm(ILNumerics.ILBaseArray)">
            <summary>
            Create a random permutation of integers 
            </summary>
            <param name="length">Number of unique integers to be created</param>
            <returns>Integer vector of length 'length'</returns>
        </member>
        <member name="M:ILNumerics.ILMath.rank(ILNumerics.ILInArray{System.Double},System.Double)">
            <summary>
            Rank of matrix A
            </summary>
            <param name="A">Input matrix</param>
            <param name="tolerance">[Optional]Tolerance used to decide, if a singular value is 
            treated as zero. If a value &lt; 0 is specified the tolerance will be determined automatically (see below - default = -1.0)</param>
            <returns>Rank of matrix A</returns>
            <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(A) * norm(A) * MachineParameterDouble.epsilon \\
            with 
            <list type="bullet">
            <item>length(A) - the longest dimension of A</item>
            <item>norm(A) being the largest singular value of A, </item>
            <item>MachineParameterDouble.eps - the distance between 1 and the smallest next greater value</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.rank(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Double)">
            <summary>
            Rank of matrix A
            </summary>
            <param name="A">Input matrix</param>
            <param name="tolerance">[Optional]Tolerance used to decide, if a singular value is 
            treated as zero. If a value &lt; 0 is specified the tolerance will be determined automatically (see below - default = -1.0)</param>
            <returns>Rank of matrix A</returns>
            <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(A) * norm(A) * MachineParameterDouble.epsilon \\
            with 
            <list type="bullet">
            <item>length(A) - the longest dimension of A</item>
            <item>norm(A) being the largest singular value of A, </item>
            <item>MachineParameterDouble.eps - the distance between 1 and the smallest next greater value</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.rank(ILNumerics.ILInArray{System.Single},System.Double)">
            <summary>
            Rank of matrix A
            </summary>
            <param name="A">Input matrix</param>
            <param name="tolerance">[Optional]Tolerance used to decide, if a singular value is 
            treated as zero. If a value &lt; 0 is specified the tolerance will be determined automatically (see below - default = -1.0)</param>
            <returns>Rank of matrix A</returns>
            <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(A) * norm(A) * MachineParameterDouble.epsilon \\
            with 
            <list type="bullet">
            <item>length(A) - the longest dimension of A</item>
            <item>norm(A) being the largest singular value of A, </item>
            <item>MachineParameterDouble.eps - the distance between 1 and the smallest next greater value</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.rank(ILNumerics.ILInArray{ILNumerics.complex},System.Double)">
            <summary>
            Rank of matrix A
            </summary>
            <param name="A">Input matrix</param>
            <param name="tolerance">[Optional]Tolerance used to decide, if a singular value is 
            treated as zero. If a value &lt; 0 is specified the tolerance will be determined automatically (see below - default = -1.0)</param>
            <returns>Rank of matrix A</returns>
            <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(A) * norm(A) * MachineParameterDouble.epsilon \\
            with 
            <list type="bullet">
            <item>length(A) - the longest dimension of A</item>
            <item>norm(A) being the largest singular value of A, </item>
            <item>MachineParameterDouble.eps - the distance between 1 and the smallest next greater value</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Real part of complex array
            </summary>
            <param name="X">Complex input array</param>
            <returns>Real part of complex array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Real part of complex array
            </summary>
            <param name="X">Complex input array</param>
            <returns>Real part of complex array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert real array to complex array
            </summary>
            <param name="A">Input array</param>
            <returns>Complex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Create complex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert real array to complex array
            </summary>
            <param name="A">Input array</param>
            <returns>Complex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>
            Create complex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert real array to complex array
            </summary>
            <param name="A">Input array</param>
            <returns>Complex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>
            Create complex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert real array to complex array
            </summary>
            <param name="A">Input array</param>
            <returns>Complex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>
            Create complex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert real array to complex array
            </summary>
            <param name="A">Input array</param>
            <returns>Complex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Create complex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert real array to fcomplex array
            </summary>
            <param name="A">Input array</param>
            <returns>fcomplex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Create fcomplex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert real array to fcomplex array
            </summary>
            <param name="A">Input array</param>
            <returns>fcomplex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>
            Create fcomplex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert real array to fcomplex array
            </summary>
            <param name="A">Input array</param>
            <returns>fcomplex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>
            Create fcomplex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert real array to fcomplex array
            </summary>
            <param name="A">Input array</param>
            <returns>fcomplex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>
            Create fcomplex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert real array to fcomplex array
            </summary>
            <param name="A">Input array</param>
            <returns>fcomplex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Create fcomplex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{System.Double},System.Int32[])">
            <summary>
            Array replication 
            </summary>
            <param name="X">Input array to be replicated</param>
            <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>Reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
            <summary>
            Array replication 
            </summary>
            <param name="X">Input array to be replicated</param>
            <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>Reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
            <summary>
            Array replication 
            </summary>
            <param name="X">Input array to be replicated</param>
            <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>Reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{System.Byte},System.Int32[])">
            <summary>
            Array replication 
            </summary>
            <param name="X">Input array to be replicated</param>
            <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>Reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{System.Int64},System.Int32[])">
            <summary>
            Array replication 
            </summary>
            <param name="X">Input array to be replicated</param>
            <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>Reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{System.Int32},System.Int32[])">
            <summary>
            Array replication 
            </summary>
            <param name="X">Input array to be replicated</param>
            <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>Reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{System.Single},System.Int32[])">
            <summary>
            Array replication 
            </summary>
            <param name="X">Input array to be replicated</param>
            <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>Reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.ILMath.repmat``1(ILNumerics.ILInArray{``0},System.Int32[])">
            <summary>
            Array replication 
            </summary>
            <param name="X">Input array to be replicated</param>
            <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>Reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Double},ILNumerics.ILSize)">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="dim">New dimension</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Double},System.Int32[])">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions"/>. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILSize)">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="dim">New dimension</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions"/>. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILSize)">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="dim">New dimension</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions"/>. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Byte},ILNumerics.ILSize)">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="dim">New dimension</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Byte},System.Int32[])">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions"/>. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Int64},ILNumerics.ILSize)">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="dim">New dimension</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Int64},System.Int32[])">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions"/>. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Int32},ILNumerics.ILSize)">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="dim">New dimension</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Int32},System.Int32[])">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions"/>. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Single},ILNumerics.ILSize)">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="dim">New dimension</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Single},System.Int32[])">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions"/>. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape``1(ILNumerics.ILInArray{``0},System.Int32[])">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="newDimensions">New dimensions array. This may be 
            a comma seperated list or an int array</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions"/>. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape``1(ILNumerics.ILInArray{``0},ILNumerics.ILSize)">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="dim">New dimension</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new reference array is created, having 
            the size and number of dimensions specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.round(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Round to nearest integer</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded to nearest integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.round(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Round to nearest integer</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded to nearest integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.round(ILNumerics.ILInArray{System.Single})">
            <summary>Round to nearest integer</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded to nearest integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.round(ILNumerics.ILInArray{System.Double})">
            <summary>Round to nearest integer</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded to nearest integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Double})">
            <summary>Signum of array elements</summary>
            <param name="A">Input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Single})">
            <summary>Signum of array elements</summary>
            <param name="A">Input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Signum of array elements</summary>
            <param name="A">Input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function for each element a is computed by: a / abs(a). Therefore, values returned will all lay on the unit circle.</para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Signum of array elements</summary>
            <param name="A">Input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function for each element a is computed by: a / abs(a). Therefore, values returned will all lay on the unit circle.</para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Int64})">
            <summary>Signum of array elements</summary>
            <param name="A">Input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Int32})">
            <summary>Signum of array elements</summary>
            <param name="A">Input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Int16})">
            <summary>Signum of array elements</summary>
            <param name="A">Input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Byte})">
            <summary>Signum of array elements</summary>
            <param name="A">Input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sin(ILNumerics.ILInArray{System.Double})">
            <summary>Sinus of array elements</summary>
            <param name="A">Input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sin(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Sinus of array elements</summary>
            <param name="A">Input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sin(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Sinus of array elements</summary>
            <param name="A">Input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sin(ILNumerics.ILInArray{System.Single})">
            <summary>Sinus of array elements</summary>
            <param name="A">Input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sinh(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Hyperbolic sine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic sine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sinh(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Hyperbolic sine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic sine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sinh(ILNumerics.ILInArray{System.Single})">
            <summary>Hyperbolic sine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic sine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sinh(ILNumerics.ILInArray{System.Double})">
            <summary>Hyperbolic sine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic sine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">Right hand side B. Size [n x m]</param>
            <returns>Solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
            <remarks><para>Depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item>
            <item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), <see cref="P:ILNumerics.ILMath.eps"/> is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.MatrixProperties@)">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">Right hand side B. Size [n x m]</param>
            <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the 
            matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. 
            This flag should be tested on return, in order to verify the reliability of the solution.</param>
            <returns>The solution x solving multiply(A,x) = B. Size [n x m]</returns>
            <remarks><para>Depending on the <paramref name="props"/> parameter the equation system will be solved 
            differently for special structures of A:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly 
            be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, 
            whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item>
            <item><para>If A is square and symmetric or hermitian, A will be decomposed into a triangular equation 
            system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the 
            corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item>
            <item>Otherwise if A is square only, it will be decomposed into upper and lower triangular matrices 
            using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>Otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. 
            A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a 
            reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same 
            logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU 
            factorization here. The un-squared case is handled differently. A direct Lapack driver function 
            (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course 
            fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), 
            <see cref="P:ILNumerics.ILMath.eps"/> is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolveTriUp(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A being a upper triangular matrix
            </summary>
            <param name="A">Input matrix of size [n x n], must be upper triangular. No check is made for that!</param>
            <param name="B">Solution vector or matrix. Size [n x m]</param>
            <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via backward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A below the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolveTriLow(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A being a lower triangular matrix
            </summary>
            <param name="A">Input matrix of size [n x n], must be lower triangular. No check is made for that!</param>
            <param name="B">Solution vector. Size [n x 1]</param>
            <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via forward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A above the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">Right hand side B. Size [n x m]</param>
            <returns>Solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
            <remarks><para>Depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item>
            <item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), <see cref="P:ILNumerics.ILMath.eps"/> is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.MatrixProperties@)">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">Right hand side B. Size [n x m]</param>
            <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the 
            matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. 
            This flag should be tested on return, in order to verify the reliability of the solution.</param>
            <returns>The solution x solving multiply(A,x) = B. Size [n x m]</returns>
            <remarks><para>Depending on the <paramref name="props"/> parameter the equation system will be solved 
            differently for special structures of A:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly 
            be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, 
            whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item>
            <item><para>If A is square and symmetric or hermitian, A will be decomposed into a triangular equation 
            system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the 
            corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item>
            <item>Otherwise if A is square only, it will be decomposed into upper and lower triangular matrices 
            using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>Otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. 
            A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a 
            reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same 
            logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU 
            factorization here. The un-squared case is handled differently. A direct Lapack driver function 
            (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course 
            fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), 
            <see cref="P:ILNumerics.ILMath.eps"/> is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolveTriUp(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A being a upper triangular matrix
            </summary>
            <param name="A">Input matrix of size [n x n], must be upper triangular. No check is made for that!</param>
            <param name="B">Solution vector or matrix. Size [n x m]</param>
            <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via backward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A below the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolveTriLow(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A being a lower triangular matrix
            </summary>
            <param name="A">Input matrix of size [n x n], must be lower triangular. No check is made for that!</param>
            <param name="B">Solution vector. Size [n x 1]</param>
            <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via forward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A above the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">Right hand side B. Size [n x m]</param>
            <returns>Solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
            <remarks><para>Depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item>
            <item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), <see cref="P:ILNumerics.ILMath.eps"/> is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@)">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">Right hand side B. Size [n x m]</param>
            <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the 
            matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. 
            This flag should be tested on return, in order to verify the reliability of the solution.</param>
            <returns>The solution x solving multiply(A,x) = B. Size [n x m]</returns>
            <remarks><para>Depending on the <paramref name="props"/> parameter the equation system will be solved 
            differently for special structures of A:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly 
            be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, 
            whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item>
            <item><para>If A is square and symmetric or hermitian, A will be decomposed into a triangular equation 
            system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the 
            corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item>
            <item>Otherwise if A is square only, it will be decomposed into upper and lower triangular matrices 
            using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>Otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. 
            A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a 
            reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same 
            logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU 
            factorization here. The un-squared case is handled differently. A direct Lapack driver function 
            (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course 
            fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), 
            <see cref="P:ILNumerics.ILMath.eps"/> is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolveTriUp(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A being a upper triangular matrix
            </summary>
            <param name="A">Input matrix of size [n x n], must be upper triangular. No check is made for that!</param>
            <param name="B">Solution vector or matrix. Size [n x m]</param>
            <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via backward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A below the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolveTriLow(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A being a lower triangular matrix
            </summary>
            <param name="A">Input matrix of size [n x n], must be lower triangular. No check is made for that!</param>
            <param name="B">Solution vector. Size [n x 1]</param>
            <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via forward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A above the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">Right hand side B. Size [n x m]</param>
            <returns>Solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
            <remarks><para>Depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item>
            <item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), <see cref="P:ILNumerics.ILMath.eps"/> is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.MatrixProperties@)">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">Right hand side B. Size [n x m]</param>
            <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the 
            matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. 
            This flag should be tested on return, in order to verify the reliability of the solution.</param>
            <returns>The solution x solving multiply(A,x) = B. Size [n x m]</returns>
            <remarks><para>Depending on the <paramref name="props"/> parameter the equation system will be solved 
            differently for special structures of A:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly 
            be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, 
            whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item>
            <item><para>If A is square and symmetric or hermitian, A will be decomposed into a triangular equation 
            system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the 
            corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item>
            <item>Otherwise if A is square only, it will be decomposed into upper and lower triangular matrices 
            using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>Otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. 
            A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a 
            reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same 
            logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU 
            factorization here. The un-squared case is handled differently. A direct Lapack driver function 
            (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course 
            fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), 
            <see cref="P:ILNumerics.ILMath.eps"/> is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolveTriUp(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A being a upper triangular matrix
            </summary>
            <param name="A">Input matrix of size [n x n], must be upper triangular. No check is made for that!</param>
            <param name="B">Solution vector or matrix. Size [n x m]</param>
            <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via backward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A below the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolveTriLow(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A being a lower triangular matrix
            </summary>
            <param name="A">Input matrix of size [n x n], must be lower triangular. No check is made for that!</param>
            <param name="B">Solution vector. Size [n x 1]</param>
            <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via forward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A above the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Double})">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Double},System.Boolean)">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <param name="Indices">[Output] Returns permutation matrix</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int64},System.Boolean)">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <param name="Indices">[Output] Returns permutation matrix</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int32},System.Boolean)">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int32},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <param name="Indices">[Output] Returns permutation matrix</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Single})">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Single},System.Boolean)">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Single},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <param name="Indices">[Output] Returns permutation matrix</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Boolean)">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <param name="Indices">[Output] Returns permutation matrix</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.complex},System.Boolean)">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <param name="Indices">[Output] Returns permutation matrix</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Byte},System.Boolean)">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Byte},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Byte},ILNumerics.ILOutArray{System.Int32},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <param name="Indices">[Output] Returns permutation matrix</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.String})">
            <summary>
            Sort strings in A along first non singleton dimension ascending
            </summary>
            <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
            <returns>Sorted array of the same size/shape as A</returns>
            <remarks><para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the other rows/columns.</para>
            <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.String},System.Boolean)">
            <summary>
            Sort strings in A along first non singleton dimension
            </summary>
            <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
            <param name="descending">Specifies the direction of sorting: true: descending sort direction; false: ascending</param>
            <returns>Sorted array of the same size/shape as A</returns>
            <remarks><para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the other rows/columns.</para>
            <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.String},System.Int32,System.Boolean)">
            <summary>
            Sort strings in A along dimension 'dim'
            </summary>
            <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
            <param name="dim">Dimension to sort along</param>
            <param name="descending">Specifies the direction of sorting: true: descending sort direction; false: ascending</param>
            <returns>Sorted array of the same size/shape as A</returns>
            <remarks><para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the other rows/columns.</para>
            <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.String},ILNumerics.ILOutArray{System.Double},System.Int32,System.Boolean)">
             <summary>
             Sort data in A along dimension 'dim'
             </summary>
             <param name="A">Input array: empty, scalar, vector or matrix</param>
             <param name="descending">Specifies the direction of sorting</param>
             <param name="dim">Dimension to sort along</param>
             <param name="Indices">[Output] Returns permutation matrix also</param>
             <returns>Sorted array of the same size as A</returns>
             <remarks><para>The data in A will be sorted using the quick sort algorithm. Data 
             along the dimension <paramref name="dim"/> will get sorted independently from data 
             in the next row/column.</para>
             <para>This overload also returns an array 'Indices' which will hold the indices into the original 
             elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort``3(ILNumerics.ILInArray{``0},ILNumerics.ILOutArray{``2},System.Int32,System.Boolean,ILNumerics.Algorithms.ILKeyMapper{``0,``1})">
            <summary>
            Generic bucket sort algorithm in A along arbitrary dimension 
            </summary>
            <param name="A">Input array: empty, scalar, vector or matrix</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">Dimension to sort along</param>
            <param name="Indices">[Input/Output] The values in Indices will be returned in the same sorted order as the elements 
            in A. This can be used to derive a permutation matrix of the sorted indices.</param>
            <typeparam name="T">Element type of values of A</typeparam>
            <typeparam name="S">Subelement type. For element type of string this would be 'char'</typeparam>
            <typeparam name="I">Element type of indices</typeparam>
            <param name="keymapper">Instancce of an object of type ILKeyMapper. This object must 
            be derived from ILKeyMapper{T,SubelementType} and match the generic argument <typeparamref name="T"/>. It will be 
            used to split single elements into its subelements and map their content into bucket numbers. For all 
            reference types except those of type string you will have to write your own ILKeyMapper class for that purpose.</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks><para>The data in A will be sorted using the bucket sort algorithm. Data 
            along the dimension <paramref name="dim"/> will get sorted independently. I.e., for dim = 0, columns are sorted independently.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Therefore, the unsorted indices must be provided by the user on entry. Indices must not be null.</para>
            <para>This generic version is able to sort arbitrary element types. Even user defined reference types can be sorted 
            by specifying a user defined ILKeyMapper class instance. Also the type of Indices may be arbitrarily choosen. In difference 
            to the regular sort function overload, Indices must manually be given to the function on entry. Elements in 'Indices'
            are sorted in the same order as the elements of A.</para>
            <para>By using this overload you may use the same permutation matrix several times to reflect the 
            manipulations done to A due multiple sort processes. The Indices given will directly be used for the sorting 
            disregarding initial order.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sqrtc(ILNumerics.ILInArray{System.Single})">
            <summary>Square root of array elements - complex output</summary>
            <param name="A">Input array - positive and negative values allowed</param>
            <returns>Square root of elements of A - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sqrtc(ILNumerics.ILInArray{System.Double})">
            <summary>Square root of array elements - complex output</summary>
            <param name="A">Input array - positive and negative values allowed</param>
            <returns>Square root of elements of A - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sqrt(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Square root of array elements</summary>
            <param name="A">Input array</param>
            <returns>Square root of elements of A </returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sqrt(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Square root of array elements</summary>
            <param name="A">Input array</param>
            <returns>Square root of elements of A </returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sqrt(ILNumerics.ILInArray{System.Single})">
            <summary>Square root of array elements - real output</summary>
            <param name="A">Input array - only positive values are allowed.</param>
            <returns>Square root of elements of A - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sqrt(ILNumerics.ILInArray{System.Double})">
            <summary>Square root of array elements - real output</summary>
            <param name="A">Input array - only positive values are allowed.</param>
            <returns>Square root of elements of A - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.std(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Boolean,System.Int32)">
            <summary>
            Standard deviation for values in A
            </summary>
            <param name="A">Input array</param>
            <param name="Weights">Vector of scaling factors, same length as working dimension of A, default: no scaling</param>
            <param name="biased">[Optional] true: apply biased normalization to result, default: false (non-biased)</param>
            <param name="dim">[Optional] Dimension index of A to operate along, default: first non singleton dimension</param>
            <returns>Variances</returns>
            <remarks><para>On scalar A a scalar 0 of the same shape as A is returned.</para>
            <para>On empty A an empty array is returned, having the dimension to operate along reduced to length 1.</para>
            <para>The parameters <paramref name="Weights"/>, <paramref name="biased"/> and <paramref name="dim"/> are optional. 
            Ommiting either one will choose its respective default value.</para>
            <para>The standard deviation is computed by the formula 
            <c>std = sqrt(var(A,...))</c>. For further details on given parameters, see 
            <see cref="M:ILNumerics.ILMath.var(ILNumerics.ILInArray{T},ILNumerics.ILInArray{T},bool,false);"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.std(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Boolean,System.Int32)">
            <summary>
            Standard deviation for values in A
            </summary>
            <param name="A">Input array</param>
            <param name="Weights">Vector of scaling factors, same length as working dimension of A, default: no scaling</param>
            <param name="biased">[Optional] true: apply biased normalization to result, default: false (non-biased)</param>
            <param name="dim">[Optional] Dimension index of A to operate along, default: first non singleton dimension</param>
            <returns>Variances</returns>
            <remarks><para>On scalar A a scalar 0 of the same shape as A is returned.</para>
            <para>On empty A an empty array is returned, having the dimension to operate along reduced to length 1.</para>
            <para>The parameters <paramref name="Weights"/>, <paramref name="biased"/> and <paramref name="dim"/> are optional. 
            Ommiting either one will choose its respective default value.</para>
            <para>The standard deviation is computed by the formula 
            <c>std = sqrt(var(A,...))</c>. For further details on given parameters, see 
            <see cref="M:ILNumerics.ILMath.var(ILNumerics.ILInArray{T},ILNumerics.ILInArray{T},bool,false);"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sub2ind(ILNumerics.ILBaseArray,System.Int32[])">
            <summary>
            Convert subscript indices to sequential index
            </summary>
            <param name="A">Input array</param>
            <param name="subscripts">Subscripts</param>
            <returns>Sequential index for subscript indices</returns>
            <remarks>The function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Subtract arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of subtraction</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Subtract arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of subtraction</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Subtract arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of subtraction</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Subtract arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of subtraction</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Subtract arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of subtraction</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Subtract arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of subtraction</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Subtract arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of subtraction</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{System.Double})">
            <summary>
            Sum all elements of array A 
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Sum all elements of array A 
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Sum all elements of array A 
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Sum all elements of array A 
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Sum all elements of array A 
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{System.Single})">
            <summary>
            Sum all elements of array A 
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Sum all elements of array A 
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            Sum elements of A along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Int64},System.Int32)">
            <summary>
            Sum elements of A along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Int32},System.Int32)">
            <summary>
            Sum elements of A along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Byte},System.Int32)">
            <summary>
            Sum elements of A along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Sum elements of A along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            Sum elements of A along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Sum elements of A along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Double})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix A</param>
            <returns>Vector with min(M,N) singular values of A as column vector</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Single})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix A</param>
            <returns>Vector with min(M,N) singular values of A as column vector</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix A</param>
            <returns>Vector with min(M,N) singular values of A as column vector</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix A</param>
            <returns>Vector with min(M,N) singular values of A as column vector</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="U">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="U">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="U">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="U">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value (e.g. 'empty') signals the need of returning those values.</param>
            <param name="small">If true: return only first min(M,N) columns of outU will be 
            of size [min(M,N),min(M,N)]</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean)">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value (e.g. 'empty') signals the need of returning those values.</param>
            <param name="small">If true: return only first min(M,N) columns of outU will be 
            of size [min(M,N),min(M,N)]</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean)">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value (e.g. 'empty') signals the need of returning those values.</param>
            <param name="small">If true: return only first min(M,N) columns of outU will be 
            of size [min(M,N),min(M,N)]</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean)">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value (e.g. 'empty') signals the need of returning those values.</param>
            <param name="small">If true: return only first min(M,N) columns of outU will be 
            of size [min(M,N),min(M,N)]</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <param name="outV">[Output] Right singular vectors of X as rows of matrix V.
            This parameter must not be null. It might be an empty array on input.</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <param name="outV">[Output] Right singular vectors of X as rows of matrix V.
            This parameter must not be null. It might be an empty array on input.</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <param name="outV">[Output] Right singular vectors of X as rows of matrix V.
            This parameter must not be null. It might be an empty array on input.</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <param name="outV">[Output] Right singular vectors of X as rows of matrix V.
            This parameter must not be null. It might be an empty array on input.</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <param name="outV">[Output] Right singular vectors of X as rows of matrix outV.
            This parameter must not be null. It might be an empty array on input.</param>
            <param name="small">If true: return only first min(M,N) columns of outU and S (returned) will be 
            of size [min(M,N),min(M,N)]</param>
            <param name="discardFiniteTest">If true: the matrix given will not be checked for infinte or NaN values. If such elements 
            exist nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib! Use with care! </param>
            <returns>Singular values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <param name="outV">[Output] Right singular vectors of X as rows of matrix outV.
            This parameter must not be null. It might be an empty array on input.</param>
            <param name="small">If true: return only first min(M,N) columns of outU and S (returned) will be 
            of size [min(M,N),min(M,N)]</param>
            <param name="discardFiniteTest">If true: the matrix given will not be checked for infinte or NaN values. If such elements 
            exist nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib! Use with care! </param>
            <returns>Singular values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <param name="outV">[Output] Right singular vectors of X as rows of matrix outV.
            This parameter must not be null. It might be an empty array on input.</param>
            <param name="small">If true: return only first min(M,N) columns of outU and S (returned) will be 
            of size [min(M,N),min(M,N)]</param>
            <param name="discardFiniteTest">If true: the matrix given will not be checked for infinte or NaN values. If such elements 
            exist nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib! Use with care! </param>
            <returns>Singular values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <param name="outV">[Output] Right singular vectors of X as rows of matrix outV.
            This parameter must not be null. It might be an empty array on input.</param>
            <param name="small">If true: return only first min(M,N) columns of outU and S (returned) will be 
            of size [min(M,N),min(M,N)]</param>
            <param name="discardFiniteTest">If true: the matrix given will not be checked for infinte or NaN values. If such elements 
            exist nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib! Use with care! </param>
            <returns>Singular values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.tan(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Tangens of array elements</summary>
            <param name="A">Input array</param>
            <returns>Tangens of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tan(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Tangens of array elements</summary>
            <param name="A">Input array</param>
            <returns>Tangens of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tan(ILNumerics.ILInArray{System.Single})">
            <summary>Tangens of array elements</summary>
            <param name="A">Input array</param>
            <returns>Tangens of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tan(ILNumerics.ILInArray{System.Double})">
            <summary>Tangens of array elements</summary>
            <param name="A">Input array</param>
            <returns>Tangens of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tanh(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Hyperbolic tangent of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic tangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tanh(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Hyperbolic tangent of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic tangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tanh(ILNumerics.ILInArray{System.Single})">
            <summary>Hyperbolic tangent of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic tangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tanh(ILNumerics.ILInArray{System.Double})">
            <summary>Hyperbolic tangent of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic tangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{System.Double})">
            <summary>
            Trace of matrix
            </summary>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Trace of matrix
            </summary>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Trace of matrix
            </summary>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{System.Single})">
            <summary>
            Trace of matrix
            </summary>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Trace of matrix
            </summary>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Trace of matrix
            </summary>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Trace of matrix
            </summary>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.triu``1(ILNumerics.ILInArray{``0})">
            <summary>
            Upper triangular part of matrix
            </summary>
            <typeparam name="T">Inner type of matrix</typeparam>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Array of size [m x n], holding upper triangular part of A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.tril``1(ILNumerics.ILInArray{``0})">
            <summary>
            Lower triangular part of matrix
            </summary>
            <typeparam name="T">Inner type of matrix</typeparam>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Array of size [m x n], holding lower triangular part of A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.var(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Boolean,System.Int32)">
            <summary>
            Variance along dimension of A
            </summary>
            <param name="A">Input array A</param>
            <param name="Weights">[Optional] Vector of scaling factors, same length as working dimension of A, default: no scaling</param>
            <param name="biased">[Optional] true: apply biased normalization to result, default: false (non-biased)</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Variances</returns>
            <remarks><para>On scalar A a scalar 0 of the same shape as A is returned.</para>
            <para>On empty A an empty array is returned, having the dimension to operate along reduced to length 1.</para>
            <para>The parameters <paramref name="Weights"/>, <paramref name="biased"/> and <paramref name="dim"/> are optional. 
            Ommiting either one will choose its respective default value.</para>
            <para> The result for <paramref name="biased"/> = true is computed by the following formula: 
            <code>r = (A - mean(A)); 
            var = sum(r * r) / A.D[dim];</code>
            If <paramref name="biased"/> is false (default) the normalization is done with the length of the working dimension of A as follows: 
            <code>r = (A - mean(A)); 
            var = sum(r * r) / (A.D[dim] - 1); </code>
            If <paramref name="Weights"/> is given, the parameter <paramref name="biased"/> is ignored.</para>
            <para>If <paramref name="Weights"/> is given, the normalization is applied to r as follows: 
            <code>w = w / sum(w); 
            r = A - sum(w * A);
            var = sum(w * (r * r)); 
            </code></para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.var(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Boolean,System.Int32)">
            <summary>
            Variance along dimension of A
            </summary>
            <param name="A">Input array A</param>
            <param name="Weights">[Optional] Vector of scaling factors, same length as working dimension of A, default: no scaling</param>
            <param name="biased">[Optional] true: apply biased normalization to result, default: false (non-biased)</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Variances</returns>
            <remarks><para>On scalar A a scalar 0 of the same shape as A is returned.</para>
            <para>On empty A an empty array is returned, having the dimension to operate along reduced to length 1.</para>
            <para>The parameters <paramref name="Weights"/>, <paramref name="biased"/> and <paramref name="dim"/> are optional. 
            Ommiting either one will choose its respective default value.</para>
            <para> The result for <paramref name="biased"/> = true is computed by the following formula: 
            <code>r = (A - mean(A)); 
            var = sum(r * r) / A.D[dim];</code>
            If <paramref name="biased"/> is false (default) the normalization is done with the length of the working dimension of A as follows: 
            <code>r = (A - mean(A)); 
            var = sum(r * r) / (A.D[dim] - 1); </code>
            If <paramref name="Weights"/> is given, the parameter <paramref name="biased"/> is ignored.</para>
            <para>If <paramref name="Weights"/> is given, the normalization is applied to r as follows: 
            <code>w = w / sum(w); 
            r = A - sum(w * A);
            var = sum(w * (r * r)); 
            </code></para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.vec(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Regulary spaced vector
            </summary>
            <param name="start">Start value</param>
            <param name="end">End value</param>
            <returns>Row vector of size 1xN, where N is the number of elements 
            between start and end, all equally spaced with interval 1. The last element 
            of the returned vector will be less than or equal to end, if start <![CDATA[<]]> end.</returns>
            <remarks>This is the same as vector (start,1,end).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If start <![CDATA[>]]> end</exception>
        </member>
        <member name="M:ILNumerics.ILMath.vec``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Regularly spaced vector, spacing 1
            </summary>
            <param name="start">Start value</param>
            <param name="end">End value</param>
            <returns>Row vector of size 1xN, where N is the number of elements 
            between start and end, all equally spaced with stepsize of 1. The last element 
            of the returned vector will be less than or equal to end, if start &lt; end. </returns>
        </member>
        <member name="M:ILNumerics.ILMath.vec``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Regulary spaced column vector
            </summary>
            <param name="start">Start value</param>
            <param name="step">Step size</param>
            <param name="end">End value</param>
            <returns>Column vector of length N, where N is the number of elements 
            between start and end, all equally spaced with stepsize of 'step'. The last element 
            of the returned vector will be less than or equal to end, if start &lt; end. If start 
            &gt; end, the elements in the vector will linearly decrease from 
            start to end. In this case, step must be negative.</returns>
            <remarks><para>The shape of the vector created is controlled by the setting switch <see cref="P:ILNumerics.Settings.CreateRowVectorsByDefault"/>.
            This setting defaults to 'false' which will cause the creation of a column vector. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{System.Double}[])">
            <summary>
            Vertical array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
            <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{ILNumerics.fcomplex}[])">
            <summary>
            Vertical array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
            <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{ILNumerics.complex}[])">
            <summary>
            Vertical array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
            <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{System.Byte}[])">
            <summary>
            Vertical array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
            <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{System.Int64}[])">
            <summary>
            Vertical array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
            <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{System.Int32}[])">
            <summary>
            Vertical array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
            <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{System.Single}[])">
            <summary>
            Vertical array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
            <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.vertcat``1(ILNumerics.ILInArray{``0}[])">
            <summary>
            Vertical array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
            <returns>Larger array having all arrays in 'arrays' placed beneath each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'xor' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'xor' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'xor' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'xor' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'xor' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'xor' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'xor' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.zeros(System.Int32[])">
            <summary>
            Create double array with all elements initialized to 0
            </summary>
            <param name="size">Size description</param>
            <returns>Zeros-filled array.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.zeros(ILNumerics.ILSize)">
            <summary>
            Create double array with all elements initialized to 0
            </summary>
            <param name="size">Size descriptor</param>
            <returns>Zeros-filled array.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.zeros``1(ILNumerics.ILSize)">
            <summary>
            Create array with all elements initialized to default(T)
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="size">Size descriptor</param>
            <returns>New array, initialized to default(T)</returns>
        </member>
        <member name="M:ILNumerics.ILMath.zeros``1(System.Int32[])">
            <summary>
            Create new array of arbitrary element type, initialized to '0'
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="size">Size description</param>
            <returns>New array having the size determined by 'dims', initialized to '0'</returns>
            <remarks>For T deriving from Sytem.ValueType elements will be '0'. All other element types
            will be initialized to default(T).</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.zeros(ILNumerics.NumericType,ILNumerics.ILSize)">
            <summary>
            Create array initialized with all elements set to zero
            </summary>
            <param name="type">Numeric type specification. One value out of the types listed in the <see cred="ILNumerics.NumericType"/>
            enum.</param>
            <param name="size">Size descriptor</param>
            <returns>Array of inner type corresponding to <paramref name="type"/> argument.</returns>
            <remarks>The array returned may be casted to the appropriate actual type afterwards. 
            <para>
            <list type="number"> 
            <listheader>The following types are supported: </listheader>
            <item>Double</item>
            <item>Single</item>
            <item>Complex</item>
            <item>FComplex</item>
            <item>Byte</item>
            <item>Int32</item>
            <item>Int64</item>
            </list>
            </para>
            <para>This function is provided for downward compatibility reasons only and will be removed in a future update. It is recommended to use the <see cref="M:ILNumerics.ILMath.zeros``1(ILNumerics.ILSize)"/> or <see cref="M:ILNumerics.ILMath.zeros``1(System.Int32[])"/> overloads instead.</para>
            <para>The interface of this function does not confirm to the rules of functions in ILNumerics. Therefore, in order to prevent for potential memory issues, the return value should be converted to 
            a concrete array type explicitely: </para>
            <example>
            <code>
            ILArray&lt;double&gt; A = todouble(zeros(NumericType.double, size(10,20))); 
            
            // better and easier would be: 
            ILArray&lt;double&gt; B = zeros&lt;double&gt;(10,20); 
            </code>
            </example>
            </remarks>
        </member>
        <member name="F:ILNumerics.ILMath.Lapack">
            <summary>
            Concrete interface wrapper class providing the native LAPACK functions
            </summary>
            <remarks>The LAPACK wrapper will be initialized the first time, 
            a call to any static method of ILMath is made. The decision, which 
            native module to load is done by use of native CPUID assembly statements.
            If the current processor does not support those calls or is not recognizable
            by ILNumerics, a generic - not optimized - version of native LAPACK code will
            be used than.</remarks>
        </member>
        <member name="F:ILNumerics.ILMath.FFTImplementation">
            <summary>
            Platform specific FFT implementation, <b>internally</b> used to compute fft 
            </summary>
        </member>
        <member name="M:ILNumerics.ILMath.#cctor">
            <summary>
            Main math class providing static builtin functions
            </summary>
        </member>
        <member name="M:ILNumerics.ILMath.median(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            Calculate median along the specified dimension
            </summary>
            <param name="A">Input Array</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the median of 
            all elements along that dimension.</para>
            <param name="dim">[Optional] Index of dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <para>The result will have the same number of dimensions as A, but the specified dimension will have the 
            size 1.</para><para>If the specified dimension of A is empty, the median along that dimension will be NaN and that dimension will be 1.</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.median(ILNumerics.ILInArray{System.Int64},System.Int32)">
            <summary>
            Calculate median along the specified dimension
            </summary>
            <param name="A">Input Array</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the median of 
            all elements along that dimension.</para>
            <param name="dim">[Optional] Index of dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <para>The result will have the same number of dimensions as A, but the specified dimension will have the 
            size 1.</para><para>If the specified dimension of A is empty, the median along that dimension will be NaN and that dimension will be 1.</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.median(ILNumerics.ILInArray{System.Int32},System.Int32)">
            <summary>
            Calculate median along the specified dimension
            </summary>
            <param name="A">Input Array</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the median of 
            all elements along that dimension.</para>
            <param name="dim">[Optional] Index of dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <para>The result will have the same number of dimensions as A, but the specified dimension will have the 
            size 1.</para><para>If the specified dimension of A is empty, the median along that dimension will be NaN and that dimension will be 1.</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.median(ILNumerics.ILInArray{System.Byte},System.Int32)">
            <summary>
            Calculate median along the specified dimension
            </summary>
            <param name="A">Input Array</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the median of 
            all elements along that dimension.</para>
            <param name="dim">[Optional] Index of dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <para>The result will have the same number of dimensions as A, but the specified dimension will have the 
            size 1.</para><para>If the specified dimension of A is empty, the median along that dimension will be NaN and that dimension will be 1.</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.median(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Calculate median along the specified dimension
            </summary>
            <param name="A">Input Array</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the median of 
            all elements along that dimension.</para>
            <param name="dim">[Optional] Index of dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <para>The result will have the same number of dimensions as A, but the specified dimension will have the 
            size 1.</para><para>If the specified dimension of A is empty, the median along that dimension will be NaN and that dimension will be 1.</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.median(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            Calculate median along the specified dimension
            </summary>
            <param name="A">Input Array</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the median of 
            all elements along that dimension.</para>
            <param name="dim">[Optional] Index of dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <para>The result will have the same number of dimensions as A, but the specified dimension will have the 
            size 1.</para><para>If the specified dimension of A is empty, the median along that dimension will be NaN and that dimension will be 1.</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.median(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Calculate median along the specified dimension
            </summary>
            <param name="A">Input Array</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the median of 
            all elements along that dimension.</para>
            <param name="dim">[Optional] Index of dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <para>The result will have the same number of dimensions as A, but the specified dimension will have the 
            size 1.</para><para>If the specified dimension of A is empty, the median along that dimension will be NaN and that dimension will be 1.</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.nanmean(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            Mean of array along specified dimension ignoring NaN values
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to work along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of non-NaN elements along specified dimension</returns>
            <remarks><para>The return array has the same shape as A, but the selected dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.
            </para><para>If A contains an all NaN vector along the specified dimension the resulting value will by NaN
            (as the nansum of these elements is 0 divided by 0 elements)</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.nanmean(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Mean of array along specified dimension ignoring NaN values
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to work along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of non-NaN elements along specified dimension</returns>
            <remarks><para>The return array has the same shape as A, but the selected dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.
            </para><para>If A contains an all NaN vector along the specified dimension the resulting value will by NaN
            (as the nansum of these elements is 0 divided by 0 elements)</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.nanmean(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            Mean of array along specified dimension ignoring NaN values
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to work along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of non-NaN elements along specified dimension</returns>
            <remarks><para>The return array has the same shape as A, but the selected dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.
            </para><para>If A contains an all NaN vector along the specified dimension the resulting value will by NaN
            (as the nansum of these elements is 0 divided by 0 elements)</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.nanmean(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Mean of array along specified dimension ignoring NaN values
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to work along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of non-NaN elements along specified dimension</returns>
            <remarks><para>The return array has the same shape as A, but the selected dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.
            </para><para>If A contains an all NaN vector along the specified dimension the resulting value will by NaN
            (as the nansum of these elements is 0 divided by 0 elements)</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.nansum(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            Sum elements along first non singleton dimension ignoring NaN values
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Sum of elements along specified of first non singleton dimension, ignoring nan values</returns>
            <remarks><para>The array returned will have the same size as <paramref name="A"/>, with the specified or first non singleton dimension 
            reduced to the length 1. It will contain the sum of all elements along that dimension after removing NaN values respectively. </para>
            <para>If A contains an all NaN vector along <paramref name="dim"/> , 
            the resulting sum will be 0 - not NaN! This corresponds to the sum of an empty vector.</para></remarks> 
        </member>
        <member name="M:ILNumerics.ILMath.nansum_internal(ILNumerics.ILInArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            Depending on settings, calculate nansum or nanmean
            </summary>
        </member>
        <member name="M:ILNumerics.ILMath.nansum(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Sum elements along first non singleton dimension ignoring NaN values
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Sum of elements along specified of first non singleton dimension, ignoring nan values</returns>
            <remarks><para>The array returned will have the same size as <paramref name="A"/>, with the specified or first non singleton dimension 
            reduced to the length 1. It will contain the sum of all elements along that dimension after removing NaN values respectively. </para>
            <para>If A contains an all NaN vector along <paramref name="dim"/> , 
            the resulting sum will be 0 - not NaN! This corresponds to the sum of an empty vector.</para></remarks> 
        </member>
        <member name="M:ILNumerics.ILMath.nansum_internal(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
            <summary>
            Depending on settings, calculate nansum or nanmean
            </summary>
        </member>
        <member name="M:ILNumerics.ILMath.nansum(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            Sum elements along first non singleton dimension ignoring NaN values
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Sum of elements along specified of first non singleton dimension, ignoring nan values</returns>
            <remarks><para>The array returned will have the same size as <paramref name="A"/>, with the specified or first non singleton dimension 
            reduced to the length 1. It will contain the sum of all elements along that dimension after removing NaN values respectively. </para>
            <para>If A contains an all NaN vector along <paramref name="dim"/> , 
            the resulting sum will be 0 - not NaN! This corresponds to the sum of an empty vector.</para></remarks> 
        </member>
        <member name="M:ILNumerics.ILMath.nansum_internal(ILNumerics.ILInArray{System.Single},System.Int32,System.Boolean)">
            <summary>
            Depending on settings, calculate nansum or nanmean
            </summary>
        </member>
        <member name="M:ILNumerics.ILMath.nansum(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Sum elements along first non singleton dimension ignoring NaN values
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Sum of elements along specified of first non singleton dimension, ignoring nan values</returns>
            <remarks><para>The array returned will have the same size as <paramref name="A"/>, with the specified or first non singleton dimension 
            reduced to the length 1. It will contain the sum of all elements along that dimension after removing NaN values respectively. </para>
            <para>If A contains an all NaN vector along <paramref name="dim"/> , 
            the resulting sum will be 0 - not NaN! This corresponds to the sum of an empty vector.</para></remarks> 
        </member>
        <member name="M:ILNumerics.ILMath.nansum_internal(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Boolean)">
            <summary>
            Depending on settings, calculate nansum or nanmean
            </summary>
        </member>
        <member name="M:ILNumerics.ILMath.select(ILNumerics.ILInArray{System.Double},System.Int32,System.Int32)">
            <summary>
            Select the k-th smallest element from an array along a specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="k">The element to find. If k is smaller 1 or larger than the number of elements in list, the smallest/largest value will be returned.</param>
            <param name="dim">[Optional] Dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the value of the k-the smallest element along that dimension.</para>
            <para>Exception: If the selected dimension is of size 0 it will remain 0 (an empty set).</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.select(ILNumerics.ILInArray{System.Int64},System.Int32,System.Int32)">
            <summary>
            Select the k-th smallest element from an array along a specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="k">The element to find. If k is smaller 1 or larger than the number of elements in list, the smallest/largest value will be returned.</param>
            <param name="dim">[Optional] Dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the value of the k-the smallest element along that dimension.</para>
            <para>Exception: If the selected dimension is of size 0 it will remain 0 (an empty set).</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.select(ILNumerics.ILInArray{System.Int32},System.Int32,System.Int32)">
            <summary>
            Select the k-th smallest element from an array along a specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="k">The element to find. If k is smaller 1 or larger than the number of elements in list, the smallest/largest value will be returned.</param>
            <param name="dim">[Optional] Dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the value of the k-the smallest element along that dimension.</para>
            <para>Exception: If the selected dimension is of size 0 it will remain 0 (an empty set).</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.select(ILNumerics.ILInArray{System.Byte},System.Int32,System.Int32)">
            <summary>
            Select the k-th smallest element from an array along a specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="k">The element to find. If k is smaller 1 or larger than the number of elements in list, the smallest/largest value will be returned.</param>
            <param name="dim">[Optional] Dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the value of the k-the smallest element along that dimension.</para>
            <para>Exception: If the selected dimension is of size 0 it will remain 0 (an empty set).</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.select(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
            <summary>
            Select the k-th smallest element from an array along a specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="k">The element to find. If k is smaller 1 or larger than the number of elements in list, the smallest/largest value will be returned.</param>
            <param name="dim">[Optional] Dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the value of the k-the smallest element along that dimension.</para>
            <para>Exception: If the selected dimension is of size 0 it will remain 0 (an empty set).</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.select(ILNumerics.ILInArray{System.Single},System.Int32,System.Int32)">
            <summary>
            Select the k-th smallest element from an array along a specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="k">The element to find. If k is smaller 1 or larger than the number of elements in list, the smallest/largest value will be returned.</param>
            <param name="dim">[Optional] Dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the value of the k-the smallest element along that dimension.</para>
            <para>Exception: If the selected dimension is of size 0 it will remain 0 (an empty set).</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.select(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            Select the k-th smallest element from an array along a specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="k">The element to find. If k is smaller 1 or larger than the number of elements in list, the smallest/largest value will be returned.</param>
            <param name="dim">[Optional] Dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the value of the k-the smallest element along that dimension.</para>
            <para>Exception: If the selected dimension is of size 0 it will remain 0 (an empty set).</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.quickselect_worker(System.Double[],System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Quick select algorithm: Find the k-th smallest element in list.
            Will change the list parameter!
            </summary>
            <remarks><para>Elements in the array list will be reordered. Make sure to pass a copy if you intend to use that data later</para></remarks>
            <param name="list">The list to search in</param>
            <param name="left">The first index in the list to start the search</param>
            <param name="right">The last index in the list to end the search</param>
            <param name="k">The k-th smallest element to find in list[left:right]. If k is smaller than 1 or larger than the number of elements the smallest/largest value will be returned.</param>
            <param name="position">Returns the index in list where the smallest element was found</param>
            <returns>The k-th smallest element</returns>
        </member>
        <member name="M:ILNumerics.ILMath.quickselect_worker(System.Int64[],System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Quick select algorithm: Find the k-th smallest element in list.
            Will change the list parameter!
            </summary>
            <remarks><para>Elements in the array list will be reordered. Make sure to pass a copy if you intend to use that data later</para></remarks>
            <param name="list">The list to search in</param>
            <param name="left">The first index in the list to start the search</param>
            <param name="right">The last index in the list to end the search</param>
            <param name="k">The k-th smallest element to find in list[left:right]. If k is smaller than 1 or larger than the number of elements the smallest/largest value will be returned.</param>
            <param name="position">Returns the index in list where the smallest element was found</param>
            <returns>The k-th smallest element</returns>
        </member>
        <member name="M:ILNumerics.ILMath.quickselect_worker(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Quick select algorithm: Find the k-th smallest element in list.
            Will change the list parameter!
            </summary>
            <remarks><para>Elements in the array list will be reordered. Make sure to pass a copy if you intend to use that data later</para></remarks>
            <param name="list">The list to search in</param>
            <param name="left">The first index in the list to start the search</param>
            <param name="right">The last index in the list to end the search</param>
            <param name="k">The k-th smallest element to find in list[left:right]. If k is smaller than 1 or larger than the number of elements the smallest/largest value will be returned.</param>
            <param name="position">Returns the index in list where the smallest element was found</param>
            <returns>The k-th smallest element</returns>
        </member>
        <member name="M:ILNumerics.ILMath.quickselect_worker(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Quick select algorithm: Find the k-th smallest element in list.
            Will change the list parameter!
            </summary>
            <remarks><para>Elements in the array list will be reordered. Make sure to pass a copy if you intend to use that data later</para></remarks>
            <param name="list">The list to search in</param>
            <param name="left">The first index in the list to start the search</param>
            <param name="right">The last index in the list to end the search</param>
            <param name="k">The k-th smallest element to find in list[left:right]. If k is smaller than 1 or larger than the number of elements the smallest/largest value will be returned.</param>
            <param name="position">Returns the index in list where the smallest element was found</param>
            <returns>The k-th smallest element</returns>
        </member>
        <member name="M:ILNumerics.ILMath.quickselect_worker(ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Quick select algorithm: Find the k-th smallest element in list.
            Will change the list parameter!
            </summary>
            <remarks><para>Elements in the array list will be reordered. Make sure to pass a copy if you intend to use that data later</para></remarks>
            <param name="list">The list to search in</param>
            <param name="left">The first index in the list to start the search</param>
            <param name="right">The last index in the list to end the search</param>
            <param name="k">The k-th smallest element to find in list[left:right]. If k is smaller than 1 or larger than the number of elements the smallest/largest value will be returned.</param>
            <param name="position">Returns the index in list where the smallest element was found</param>
            <returns>The k-th smallest element</returns>
        </member>
        <member name="M:ILNumerics.ILMath.quickselect_worker(System.Single[],System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Quick select algorithm: Find the k-th smallest element in list.
            Will change the list parameter!
            </summary>
            <remarks><para>Elements in the array list will be reordered. Make sure to pass a copy if you intend to use that data later</para></remarks>
            <param name="list">The list to search in</param>
            <param name="left">The first index in the list to start the search</param>
            <param name="right">The last index in the list to end the search</param>
            <param name="k">The k-th smallest element to find in list[left:right]. If k is smaller than 1 or larger than the number of elements the smallest/largest value will be returned.</param>
            <param name="position">Returns the index in list where the smallest element was found</param>
            <returns>The k-th smallest element</returns>
        </member>
        <member name="M:ILNumerics.ILMath.quickselect_worker(ILNumerics.complex[],System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Quick select algorithm: Find the k-th smallest element in list.
            Will change the list parameter!
            </summary>
            <remarks><para>Elements in the array list will be reordered. Make sure to pass a copy if you intend to use that data later</para></remarks>
            <param name="list">The list to search in</param>
            <param name="left">The first index in the list to start the search</param>
            <param name="right">The last index in the list to end the search</param>
            <param name="k">The k-th smallest element to find in list[left:right]. If k is smaller than 1 or larger than the number of elements the smallest/largest value will be returned.</param>
            <param name="position">Returns the index in list where the smallest element was found</param>
            <returns>The k-th smallest element</returns>
        </member>
        <member name="P:ILNumerics.ILMath.end">
            <summary>
            Substitute for the index of the last element of a dimension
            </summary>
            <remarks>The 'end' placeholder can be used in subarray specification expressions. It will get 
            evaluated in a delayed manner, once the index of the dimension (and therefore the dimension length)
            is known. It than evaluates to the number of the index of the last element in the dimension.
            </remarks>
        </member>
        <member name="P:ILNumerics.ILMath.eps">
            <summary>
            Double precision epsilon - the smallest difference from 1.0
            </summary>
        </member>
        <member name="P:ILNumerics.ILMath.epsf">
            <summary>
            Single precision epsilon - the smalles difference from 1.0f
            </summary>
        </member>
        <member name="P:ILNumerics.ILMath.MachineParameterDouble">
            <summary>
            Give extensive numerical machine parameter informations - double precision
            </summary>
        </member>
        <member name="P:ILNumerics.ILMath.MachineParameterSingle">
            <summary>
            Give extensive numerical machine parameter informations - single precision
            </summary>
        </member>
        <member name="P:ILNumerics.ILMath.full">
            <summary>
            Address the whole dimension for subarray access
            </summary>
        </member>
        <member name="P:ILNumerics.ILMath.RandomGenerator">
            <summary>
            Random number generator used for any generation of random numbers.
            </summary>
            <remarks>This property is thread safe (by using the [ThreadStatic] attribute).</remarks>
        </member>
        <member name="T:ILNumerics.ILMath.EMInitializationMethod">
            <summary>
            Determine method of center initialization for EM algorithm
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.EMInitializationMethod.KMeans_random">
            <summary>
            Use the kmeans algorithm, choose random samples as centers for start 
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.EMInitializationMethod.KMeans_firstK">
            <summary>
            Use the kmeans algorithm, choose first k samples as centers for start 
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.EMInitializationMethod.User">
            <summary>
            Provide custom centers in the 'InitCenter' argument
            </summary>
        </member>
        <member name="T:ILNumerics.ILMath.KRRTypes">
            <summary>
            Type definitions for possible kernels in kernel ridge regression
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.KRRTypes.linear">
            <summary>
            Linear kernel <c>k(x,y) = x'*y</c>
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.KRRTypes.polynomial">
            <summary>
            Polynominal kernel <c>k(x,y) = (x'*y + c)^d</c>
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.KRRTypes.gaussian">
            <summary>
            Gaussian (exponential) kernel <c>k(x,y) = exp(-norm(x-y)/sigma)</c>
            </summary>
        </member>
        <member name="T:ILNumerics.ILMath.ILKRRResult">
            <summary>
            Encapsulates the result of a kernel ridge regression and makes it applicable to new data
            </summary>
        </member>
        <member name="T:ILNumerics.ILResult`1">
            <summary>
            Result datatype, used for storing computational results and applying them to new data within ILNumerics machine learning functions
            </summary>
            <typeparam name="T">Datatype of underlying array elements</typeparam>
        </member>
        <member name="M:ILNumerics.ILResult`1.Apply(ILNumerics.ILInArray{`0},ILNumerics.ILBaseArray[])">
            <summary>
            Apply the result on new datapoints
            </summary>
            <param name="X">New datapoints, same dimension as used for learning</param>
            <returns></returns>
        </member>
        <member name="T:ILNumerics.ILMath.ILRidgeRegressionResult`1">
            <summary>
            This class stores the result of a ridge regression
            </summary>
            <typeparam name="T">Element type (precision) for the result</typeparam>
            <remarks>This class is returned from <see cref="M:ILNumerics.ILMath.ridge_regression(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)"/>
            and all its overloads. The class stores all data needed to apply the regression result to new data points. Therefore a 
            function <see cref="M:ILNumerics.ILMath.ILRidgeRegressionResult`1.Apply(ILNumerics.ILInArray{`0},ILNumerics.ILBaseArray[])"/> is provided.
            <para>The class implements the <c>IDisposable</c> interface and should be used inside a 'using' block or manually be disposed 
            after use.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ILRidgeRegressionResult`1.Apply(ILNumerics.ILInArray{`0},ILNumerics.ILBaseArray[])">
            <summary>
            Apply the result on new datapoints
            </summary>
            <param name="X">New datapoints, same dimension as used for learning</param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.ILMath.ILRidgeRegressionResult`1.Dispose">
            <summary>
            Dispose off the result and free all storages used 
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.BinOptItExMode.VAN">
            <summary>
            vector op. array - not in-place
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.BinOptItExMode.VAI">
            <summary>
            vector op. arra - in-place
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.BinOptItExMode.AVN">
            <summary>
            array op. vector - not in-place
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.BinOptItExMode.AVI">
            <summary>
            array op. vector - in-place
            </summary>
        </member>
        <member name="T:ILNumerics.ILMath.GenEigenType">
            <summary>
            Specifies the type of eigenproblem 
            </summary>
            <remarks>The enumeration describes possible problem definitions for generelized eigenproblems:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list></remarks>
        </member>
        <member name="F:ILNumerics.ILMath.GenEigenType.Ax_eq_lambBx">
            <summary>
            A*V = r*B*V
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.GenEigenType.ABx_eq_lambx">
            <summary>
            A*B*V = r*V
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.GenEigenType.BAx_eq_lambx">
            <summary>
            B*A*V = r*V
            </summary>
        </member>
        <member name="T:ILNumerics.ILMath.precisionHelper`1">
            <summary>
            Prevent JIT "optimizations" - force single precision to be applied
            </summary>
            <typeparam name="T">mainly float here</typeparam>
        </member>
        <member name="T:ILNumerics.Misc.ILBucketSort">
            <summary>
            Bucket sort algorithm (for internal use)
            </summary>
            <remarks>This class is not intended to be used directly. Sorting functionality is supplied by <see cref="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Double})"/></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILBucketSort.BucketSort``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``2},ILNumerics.Algorithms.ILKeyMapper{``0,``1},ILNumerics.Misc.ILBucketSort.SortMethod)">
            <summary>
            Bucket sort algorithm 
            </summary>
            <param name="input"></param>
            <param name="indices">Return corresponding source element indices</param>
            <param name="mapper"></param>
            <param name="method"></param>
        </member>
        <member name="T:ILNumerics.Misc.ILBucketSort.SortMethod">
            <summary>
            Sort method for bucket sorts
            </summary>
        </member>
        <member name="F:ILNumerics.Misc.ILBucketSort.SortMethod.ConstantLength">
            <summary>
            Constant length
            </summary>
        </member>
        <member name="F:ILNumerics.Misc.ILBucketSort.SortMethod.VariableLenth">
            <summary>
            Variable length
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILKeyMapper`2">
            <summary>
            Key mapper class, to be overriden for user defined classes to be sorted with bucket sort
            </summary>
            <typeparam name="ElementType">Type of elements. Elements are constructed out of any number of subelements</typeparam>
            <typeparam name="SubelementType">Type of subelements</typeparam>
            <remarks>This class can be extended to enable sorting (bucket sort) for arbitrary types. The elements of those types may be devidable into subelements.
            <para>Examples of sortable classes:
            <list>
            <item>colors: number/type of subelements: 1/any (e.g. the color code). One should write a <![CDATA[ILKeyMapper<Color,int>]]>.</item>
            <item>strings: number/type of subelements: arbitrary/char. Here a sample ILASCIKeyMapper implementation exists already. This implementation is the default implementation used for bucket sort via ILMath.sort().</item>
            <item>trees: number/type of subelements: arbitrary/tree nodes. One should write a key mapper to map a node of a tree to a bucket number</item>
            <item>...</item></list></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.Map(`1)">
            <summary>
            Maps subelement types to bucket index
            </summary>
            <param name="inSubelement">Item</param>
            <returns>Bucket index</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.Map(`0,System.Int32,System.Int32)">
            <summary>
            Map subelemt - provide fallback on error
            </summary>
            <param name="element">Element item</param>
            <param name="position">Position of subelement in element item to be mapped</param>
            <param name="fallback">If position is out of range, give back fallback</param>
            <returns>Mapped bucket for subelement or fallback on error</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.SubelementsCount(`0)">
            <summary>
            Count subelements in an element
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.GetSubelement(`0,System.Int32)">
            <summary>
            Get subelement from element item
            </summary>
            <param name="element">Element item</param>
            <param name="idx">Position of subitem in element</param>
            <returns>Subitem referenced</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.#ctor(System.Int32)">
            <summary>
            Construct key mapper
            </summary>
            <param name="NumberOfKeys">Maximm number of different subitems (keys)</param>
        </member>
        <member name="P:ILNumerics.Algorithms.ILKeyMapper`2.NumberOfKeys">
            <summary>
            Maximum number of keys (different subitems)
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILASCIIKeyMapper">
            <summary>
            Concrete implementation of a key mapper for strings
            </summary>
            <remarks>this class is the default key mapper, used for bucket sort on strings</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.Map(System.Char)">
            <summary>
            map subelement to bucket 
            </summary>
            <param name="inSubelement">subelement to be mapped</param>
            <returns>ASCII code of the subelement character</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.Map(System.String,System.Int32,System.Int32)">
            <summary>
            Map char out of string with fallback
            </summary>
            <param name="element">full string item</param>
            <param name="position">position of character in string</param>
            <param name="fallback">fallback bucket number, if position is out of range</param>
            <returns>ASCII code for character specified, fallback on error</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.GetSubelement(System.String,System.Int32)">
            <summary>
            give one char from string
            </summary>
            <param name="element">full string item</param>
            <param name="idx">character position in string</param>
            <returns>character in string</returns>
            <exception cref="T:System.IndexOutOfRangeException"> if idx is not within element ranges</exception>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.SubelementsCount(System.String)">
            <summary>
            Count numer of characters in string
            </summary>
            <param name="element">element item</param>
            <returns>number of characters in string - length of string</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.#ctor">
            <summary>
            construct ASCII key mapper for 256 buckets
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILIntLimitedKeyMapper">
            <summary>
            Integer key mapper - sample implementation for bucket sort
            </summary>
            <remarks>This mapper may be used for sorting integers with bucketsort. 
            <para>The integers to be sorted must be positive and limited. It corresponds to the number of buckets to be created.</para>
            <para>This implementation serves as a sample implementation for bucket sort. You should consider using quicksort instead, which is implemented for ILMath.sort()</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.GetSubelement(System.Int32,System.Int32)">
            <summary>
            Gives subelement - i.e. the element itself
            </summary>
            <param name="element">element</param>
            <param name="idx">(ignored)</param>
            <returns>element</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.Map(System.Int32,System.Int32,System.Int32)">
            <summary>
            map element - ignoring position &amp; fallback
            </summary>
            <param name="element">integer element</param>
            <param name="position">(ignored)</param>
            <param name="fallback">(ignored)</param>
            <returns>integer element</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.Map(System.Int32)">
            <summary>
            map (copy) subelement
            </summary>
            <param name="inSubelement">subelement</param>
            <returns>subelement</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.SubelementsCount(System.Int32)">
            <summary>
            number of subelements in an element (Here: always 1)
            </summary>
            <param name="element">element</param>
            <returns>1</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.#ctor(System.Int32)">
            <summary>
            construct integer key mapper
            </summary>
            <param name="limit">maximum number of buckets to be used</param>
        </member>
        <member name="T:ILNumerics.Misc.ILListItem`2">
            <summary>
            List items to be used in ILQueueList
            </summary>
            <typeparam name="T1">Data type</typeparam>
            <typeparam name="T2">Index type</typeparam>
            <remarks>This class is not intended to be used directly. Internally it serves as a helper class for sorting.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILListItem`2.#ctor(`0)">
            <summary>
            construct list item by data
            </summary>
            <param name="item">item data</param>
            <remarks>the indet will be set to its default value</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILListItem`2.#ctor(`0,`1)">
            <summary>
            construct list item, takes item data and index
            </summary>
            <param name="item">item data</param>
            <param name="index">index</param>
        </member>
        <member name="P:ILNumerics.Misc.ILListItem`2.Index">
            <summary>
            index stored with this item
            </summary>
        </member>
        <member name="T:ILNumerics.Misc.ILQueueList`2">
            <summary>
            Queuelist - a queue with partial list properties 
            </summary>
            <typeparam name="T1">data type</typeparam>
            <typeparam name="T2">index type</typeparam>
            <remarks>This class is not intended to be used directly. Internally it serves as a helper class for sorting.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(`0,`1)">
            <summary>
            add indexed item at end of queue
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(`0)">
            <summary>
            add item at end of queue
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(ILNumerics.Misc.ILListItem{`0,`1})">
            <summary>
            add item at end of queue
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(ILNumerics.Misc.ILQueueList{`0,`1})">
            <summary>
            add queue list to end of this queue list
            </summary>
            <param name="list">queue list to be added</param>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Dequeue">
            <summary>
            Remove from start of queue
            </summary>
            <returns>item from start of queue</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.AddToStart(`0)">
            <summary>
            Add to start of queue
            </summary>
            <param name="item">item data to add to start of queue</param>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.AddToStart(ILNumerics.Misc.ILQueueList{`0,`1})">
            <summary>
            concatenate 2 queuelists
            </summary>
            <param name="qlist">queue list to be added at start of this queuelist</param>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Sort``1(ILNumerics.Algorithms.ILKeyMapper{`0,``0})">
            <summary>
            sort utilizing bucket sort
            </summary>
            <typeparam name="SubelementType">subelement type</typeparam>
            <param name="mapper">keymapper mapping subelement items to buckets</param>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.ToArray">
            <summary>
            convert (copy) items to system array
            </summary>
            <returns>system array with items</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Clear">
            <summary>
            Clear this queue list from all elements 
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.GetEnumerator">
            <summary>
            Create enumerator utilizing 'foreach'
            </summary>
            <returns>enumerator for contained elements</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            gives enumerator for internal list items (ILListItem)
            </summary>
            <returns>ILListItem's</returns>
        </member>
        <member name="P:ILNumerics.Misc.ILQueueList`2.Count">
            <summary>
            number of items currently in the queue (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILQueueList`2.ListItems">
            <summary>
            Gives enumerator for contained items (ILListItem)
            </summary>
        </member>
        <member name="T:ILNumerics.Misc.ILQuickSort">
            <summary>
            the class provides a number of one dimensional quicksort implementations for several datatypes/ properties
            </summary>
            <summary>
            the class provides a number of one dimensional quicksort implementations for several datatypes/ properties
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.Double[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.Double[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.UInt64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.UInt64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.UInt64[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.UInt64[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.UInt32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.UInt32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.UInt16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.UInt16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.UInt16[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.UInt16[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.Int64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.Int64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.Int64[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.Int64[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.Int16[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.Int16[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.Single[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.Single[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(ILNumerics.fcomplex[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(ILNumerics.fcomplex[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(ILNumerics.complex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(ILNumerics.complex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(ILNumerics.complex[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(ILNumerics.complex[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.Char[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.Char[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscST(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescST(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXST(System.Byte[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXST(System.Byte[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.Double[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.Double[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.UInt64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.UInt64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.UInt64[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.UInt64[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.UInt32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.UInt32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.UInt16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.UInt16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.UInt16[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.UInt16[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.Int64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.Int64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.Int64[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.Int64[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.Int16[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.Int16[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.Single[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.Single[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(ILNumerics.fcomplex[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(ILNumerics.fcomplex[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(ILNumerics.complex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(ILNumerics.complex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(ILNumerics.complex[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(ILNumerics.complex[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.Char[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.Char[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscMT(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescMT(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortAscIDXMT(System.Byte[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.QuickSortDescIDXMT(System.Byte[],System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNIDXAsc(System.Int32,System.Int32@,System.Int32,System.Int32*,System.Double*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNIDXDesc(System.Int32,System.Int32@,System.Int32,System.Int32*,System.Double*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNAsc(System.Int32,System.Int32@,System.Int32,System.Double*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNDesc(System.Int32,System.Int32@,System.Int32,System.Double*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNIDXAsc(System.Int32,System.Int32@,System.Int32,System.Int32*,System.Single*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNIDXDesc(System.Int32,System.Int32@,System.Int32,System.Int32*,System.Single*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNAsc(System.Int32,System.Int32@,System.Int32,System.Single*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNDesc(System.Int32,System.Int32@,System.Int32,System.Single*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNIDXAsc(System.Int32,System.Int32@,System.Int32,System.Int32*,ILNumerics.fcomplex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNIDXDesc(System.Int32,System.Int32@,System.Int32,System.Int32*,ILNumerics.fcomplex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNAsc(System.Int32,System.Int32@,System.Int32,ILNumerics.fcomplex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNDesc(System.Int32,System.Int32@,System.Int32,ILNumerics.fcomplex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNIDXAsc(System.Int32,System.Int32@,System.Int32,System.Int32*,ILNumerics.complex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNIDXDesc(System.Int32,System.Int32@,System.Int32,System.Int32*,ILNumerics.complex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNAsc(System.Int32,System.Int32@,System.Int32,ILNumerics.complex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQuickSort.checkNaNDesc(System.Int32,System.Int32@,System.Int32,ILNumerics.complex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="T:ILNumerics.ILSpecialData">
            <summary>
            A helper class that can be used to generate various simple yet non-trivial test data sets
            </summary>
        </member>
        <member name="M:ILNumerics.ILSpecialData.sinc(System.Int32,System.Int32,System.Single)">
            <summary>
            Generate sinc function in 2D, useful for plotting examples
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <param name="periods">Influences the number of periods to be drawn in both directions. 1 will result in 4 zero crossings, higher values result in more, lower values in less zero crossings.</param>
            <returns>Matrix with sinc data in 2 dimensions</returns>
        </member>
        <member name="M:ILNumerics.ILSpecialData.sinc(System.Int32,System.Int32)">
            <summary>
            Generate sinc function in 2D, useful for plotting examples
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <returns>Matrix with sinc data in 2 dimensions</returns>
            <remarks>The function generates 4 zero crossings in each direction</remarks>
        </member>
        <member name="M:ILNumerics.ILSpecialData.sincf(System.Int32,System.Int32)">
            <summary>
            Generate sinc function in 2D, single precision, useful for plotting examples
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <returns>Matrix with sinc data in 2 dimensions</returns>
            <remarks>The function generates 4 zero crossings in each direction</remarks>
        </member>
        <member name="M:ILNumerics.ILSpecialData.sincf(System.Int32,System.Int32,System.Single)">
            <summary>
            Generate sinc function in 2D, useful for plotting examples
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <param name="periods">Influences the number of periods to be drawn in both directions. 1 will result in 4 zero crossings, higher values result in more, lower values in less zero crossings.</param>
            <returns>Matrix with sinc data in 2 dimensions</returns>
        </member>
        <member name="M:ILNumerics.ILSpecialData.sincos1D(System.Int32,System.Double)">
            <summary>
            Create specified periods of sine and cosine data
            </summary>
            <param name="numSamples">Number of samples</param>
            <param name="periods">Number of (full) periods to be generated, must be &gt; 0</param>
            <returns>Matrix with sine data in first column, cosine data in second column</returns>
        </member>
        <member name="M:ILNumerics.ILSpecialData.sincos1Df(System.Int32,System.Double)">
            <summary>
            Create specified periods of sine and cosine data, single precision
            </summary>
            <param name="numSamples">Number of samples</param>
            <param name="periods">Number of (full) periods to be generated, must be &gt; 0</param>
            <returns>Matrix with sine data in first column, cosine data in second column</returns>
        </member>
        <member name="M:ILNumerics.ILSpecialData.waterfall(System.Int32,System.Int32)">
            <summary>
            Create demo data for surface plots looking like a waterfall
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <returns>Matrix with data showing a waterfall terrain. </returns>
        </member>
        <member name="M:ILNumerics.ILSpecialData.waterfallf(System.Int32,System.Int32)">
            <summary>
            Create demo data for surface plots looking like a waterfall
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <returns>Matrix with data showing a waterfall terrain. </returns>
        </member>
        <member name="M:ILNumerics.ILSpecialData.sphere(System.Int32,ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Create surface data of a sphere
            </summary>
            <param name="n">Number of facettes per angle</param>
            <param name="X">[Output] X coords</param>
            <param name="Y">[Output] Y coords</param>
            <param name="Z">[Output] Z coords</param>
        </member>
        <member name="M:ILNumerics.ILSpecialData.moebius(System.Int32,System.Double,System.Double,ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Create surface data for a M旦bius strip 
            </summary>
            <param name="n">Granularity (number of facettes)</param>
            <param name="w">Width</param>
            <param name="R">Radius</param>
            <param name="X">[Output] X coords</param>
            <param name="Y">[Output] Y coords</param>
            <param name="Z">[Output] Z coords</param>
            <remarks>M旦bius strip is a surfcae, crated by cutting a regular strip, twisting one end by 180 deg and glueing 
            both ends together again.</remarks>
        </member>
        <member name="M:ILNumerics.ILSpecialData.torus(System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Create torus cartesian coordinates, to be used for surface plotting
            </summary>
            <param name="outerRadius">[optional] the outer radius of the torus ring, default: 0.75</param>
            <param name="innerRadius">[optional] the inner radius of the torus ring, default: 0.25</param>
            <param name="stepsPoloidal">[optional] number of grid points in poloidal direction, default: 100</param>
            <param name="stepsToroidal">[optional] number of grid points in toroidal direction, default: 100</param>
            <returns>Data array with cartesian coordinates of the torus gris points. </returns>
            <remarks></remarks>
        </member>
        <member name="P:ILNumerics.ILSpecialData.terrain">
            <summary>
            Get example terrain data, 401 x 401 short matrix with heights in meters
            </summary>
        </member>
        <member name="T:ILNumerics.ILArray`1">
             <summary>
             The main rectangular array to be used in algorithms 
             </summary>
             <typeparam name="ElementType">Inner type. This will mostly be a system numeric type or a 
             complex floating point type.</typeparam>
             <remarks>This class serves as the main rectangular array, holding arbitrary elements (usually numeric types) 
             in arbitrary dimensions.
             <para>Arrays of this type may use any type as generic element. However, common mathematical functions and operators 
             are defined for a limited number of inner types only. All binary operations (+,-,*,/,<![CDATA[<,>,<=]]>,etc.) are 
             defined for two arrays with the same <i>numeric type</i>, would it be from the <c>System</c> namespace (<c>double</c>, 
             <c>int</c>,...) or <c>ILNumerics.complex</c>/ <c>ILNumerics.fcomplex</c>. Most algebraic functions require floating point 
             types. See the <see cref="T:ILNumerics.ILMath"/> class for a list of all computational functions.</para>
             <para>Arrays are capable of creating flexible <a href="http://ilnumerics.net/$Subarray0.html" target="ILMain">subarrays</a> 
             and to get altered at runtime. Read about all details of ILNumerics arrays in the 
             <a href="http://ilnumerics.net/$Arrays.html" target="ILMain">ILNumerics Array documentation</a>.</para>
             <para>Arrays of this type are dense arrays. Cloning arrays is done as lazy 
             copy on write, i.e. clones do only use new memory, if attempting to write on them. Arrays integrate into the memory 
             management of ILNumerics. Read about the most <a href="http://ilnumerics.net/$GeneralRules.html" target="ILMain">important 
             simple rules</a>, for using arrays in custom computational functions.</para>
             <para>Arrays come with overloaded mathematical operators, allowing for a convenient syntax. A 
             sophisticated memory management in the back will make sure, that as little memory as needed is used, even in 
             expressions like: a + c * 2 / abs(sin(c) * -b / log(a)). Here all arrays are of the same size. Evaluating 
             this expression does only need the memory of twice the size of one array. Memory gets collected and reused 
             for every subexpression evaluation. Further optimization options exist, as described in 
             <a href="http://ilnumerics.net/$PerfMemoryOpt.html" target="ILMain">Optimizing Algorithm Performance</a>.</para>
             </remarks>
             <example><para>A simple example demonstrating some uses of arrays in a very simple application:</para>
             <code>using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Text;
            using ILNumerics; 
            
            
            namespace ConsoleApplication1 {
                class Program : ILMath {
                    static void Main(string[] args) {
                        ILArray&lt;double&gt; A = rand(10,20);
                        ILArray&lt;double&gt; B = A * 30 + 100; 
                        ILLogical C = any(multiply(B,B.T)); 
                        Console.Out.Write(-B); 
                        Console.ReadKey(); 
                    }
                }
            }
            </code>
             </example>
             <seealso cref="T:ILNumerics.ILLogical"/>
             <seealso cref="T:ILNumerics.ILCell"/>
        </member>
        <member name="T:ILNumerics.ILBaseArray`1">
            <summary>
            Typed base class for all ILNumerics data storage classes for any storage type. 
            </summary>
            <remarks><para>You should not use this type directly. It serves as a base class 
            for all typed storages only and will be used by derived classes like ILArray<![CDATA[<>]]>.</para>
            <para>If you are looking for an (untyped) base class to be used as generic class for any ILArray types, you should use ILBaseArray instead!</para>
            </remarks>
        </member>
        <member name="T:ILNumerics.ILBaseArray">
            <summary>
            Base type for all arrays in ILNumerics
            </summary>
            <remarks>All numerical arrays derive from ILBaseArray. ILBaseArrays itself 
            cannot be instantiated. Currently, only ILArray<![CDATA[<>]]> exist, which describe 
            a rectangular array as full (solid) or referencing array. There are plans to 
            extend the collection of derived types to encompass triangular, diagonal and sparse arrays. 
            </remarks>
        </member>
        <member name="F:ILNumerics.ILBaseArray.m_name">
            <summary>
            Name of this array
            </summary>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.Double)~ILNumerics.ILBaseArray">
            <summary>
            Implicit cast from scalar of typeof(a) to <c>ILRetArray&lt;typeof(A)&gt;</c>
            </summary>
            <param name="a">Input scalar</param>
            <returns>A ILRetArray of same type as <paramref name="a"/> and size 1x1</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(ILNumerics.complex)~ILNumerics.ILBaseArray">
            <summary>
            Implicit cast from scalar of typeof(A) to ILRetArray&lt;typeof(A)&gt;
            </summary>
            <param name="a">Input scalar</param>
            <returns>A ILRetArray of same type as <paramref name="a"/> ans size 1x1</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(ILNumerics.fcomplex)~ILNumerics.ILBaseArray">
            <summary>
            Implicit cast from scalar of typeof(A) to ILRetArray&lt;typeof(A)&gt;
            </summary>
            <param name="a">Input scalar</param>
            <returns>A ILRetArray of same type as <paramref name="a"/> ans size 1x1</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.String)~ILNumerics.ILBaseArray">
            <summary>
            Implicit cast from scalar of typeof(A) to ILRetArray&lt;typeof(A)&gt;
            </summary>
            <param name="s">Input scalar</param>
            <returns>A ILRetArray of same type as <paramref name="s"/> and size 1x1</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.Double[])~ILNumerics.ILBaseArray">
            <summary>
            Implicit cast from scalar of typeof(A) to ILRetArray&lt;typeof(A)&gt;
            </summary>
            <param name="a">Input scalar</param>
            <returns>A ILRetArray of same type as <paramref name="a"/> ans size 1x1</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.Equals(System.Object)">
            <summary>
            Compare elements and shape of this array with another array
            </summary>
            <param name="A">Other array</param>
            <returns>true if shape and element values of both arrays match, false otherwise</returns>
            <remarks><para>'Equals' accepts two vectors even if the orientations do not match. Therefore, a row vector 
            with the same element values than another column vector would be considered equal to each other.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.GetHashCode">
            <summary>
            Generate a hash code based on the current arrays values
            </summary>
            <returns>Hash code</returns>
            <remarks>The hashcode is created by taking the values currently stored in the array into account.
            Therefore, the function iterates over all elements in the array - which makes it somehow an expensive 
            operation. Take this into account, if you consider using large arrays in collections like dictionaries 
            or hashtables, which make great use of hash codes.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.Clone">
            <summary>
            Clone this array (shallow) 
            </summary>
            <returns>ILBaseArray as new representation of this storages data.</returns>
            <remarks>The object returned will be of the same size than this array.
            This this is a 'shallow' copy only! I.e., if elements are copied only. If they are 
            references to any objects, those objects are not replicated.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
            <summary>
            Print values of this instance to a stream. 
            </summary>
            <param name="outStream">Stream to write the values into.</param>
            <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)"/> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
            <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags"/>. Specifies the way 
            the values will be serialized.</param>
            <remarks><para>If method 'Formatted' is used, any occurences of NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style for the output.</para>
            <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as 
            the array name for writing. This array instance will be the only array in the mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.ToString">
            <summary>
            Convert to string
            </summary>
            <returns>String representation of content</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.ToString(System.Int32)">
            <summary>
            Convert to string with limited length
            </summary>
            <param name="maxLength">Maximal length of returned string; set to 0 to not limit result</param>
            <returns>String representation of content</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.ShortInfo">
            <summary>
            Short textual summary of this instance, used for debug output
            </summary>
            <returns>String representation of type and size</returns>
            <remarks>The type of elements and the size of the array are displayed. If the array
            is scalar, its value is displayed next to the type.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.Dispose">
            <summary>
            Dispose this array and all its content
            </summary>
        </member>
        <member name="M:ILNumerics.ILBaseArray.GetElementType">
            <summary>
            Gets the System.Type of the elements stored in this array
            </summary>
            <returns>Sytem.Type of the generic argument of concreate subclass instances</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.GetStorageHandle">
            <summary>
            Get a GC handle for the underlying storage system array for unsafe operations. CAUTION! Use at own risk! 
            </summary>
            <returns>GCHandle with address of first element of the pinned underlying one dimensional system storage or an un-allocated handle if this storage cannot get accessed.</returns>
            <remarks>This method is provided to give users a generic way to access the underlying system array for unsafe (native) operations. Extreme care must be taken when 
            using this method. Therefore, it is not recommended for 'everyday' use. Users must not forget to free the handle as soon as possible after use!</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.Size">
            <summary>
            Size descriptor specification
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.Dimensions">
            <summary>
            [deprecated] Use 'Size' as size descriptor!
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.S">
            <summary>
            Size descriptor shortcut
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.D">
            <summary>
            [deprecated] Use 'S' as size descriptor!
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.Length">
            <summary>
            Length of the longest dimension of this instance
            </summary>
            <remarks>This property is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.Name">
            <summary>
            Gets the name of this array or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsScalar">
            <summary>
            Test if this instance is a scalar
            </summary>
            <remarks>This attribute is readonly. It returns: Size.NumberOfElements == 1.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsMatrix">
            <summary>
            Test if this instance is a matrix
            </summary>
            <remarks>In order for an array to be a matrix the number of <b>non singleton</b> 
            dimensions must equal 2. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsVector">
            <summary>
            Test if this array is a vector
            </summary>
            <remarks>In order for an array to be a vector the number of <b>non singleton</b> 
            dimensions must equal 1. Keep in mind that all ILArrays have at least 2 dimensions. Therefore 
            it is not sufficient to test for the number of dimensions, but to take the number of 
            <b>non singleton</b> dimensions into account. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsRowVector">
            <summary>
            Test if this array instance is a row vector
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsColumnVector">
            <summary>
            Test if this array instance is a column vector
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsEmpty">
            <summary>
            Test if this instance is an empty array (number of elements stored = 0)
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsComplex">
            <summary>
            Determine if this array is of complex inner type.
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsNumeric">
            <summary>
            Determine if this array is of numeric inner type.
            </summary>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Serialize(System.IO.Stream)">
            <summary>
             Serialize this array into a binary stream.
            </summary>
            <param name="outStream">System.IO.Stream to receive the byte stream 
            for this ILBaseArray</param>
            <returns>True on success, false on error.</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Deserialize(System.IO.Stream)">
            <summary>
            Deserialize / restore array from binary stream 'inStream'
            </summary>
            <param name="inStream">System.IO.Stream to reconstruct the 
            array from</param>
            <returns>Array reconstructed from stream.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">If the array could not get restored</exception>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.GetValue(System.Int32[])">
            <summary>
            Get single element from this array
            </summary>
            <param name="idx">Indices, location of element</param>
            <returns>The selected value</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.GetLimits(`0@,`0@)">
            <summary>
            Get minimum and maximum value of all elements - if any
            </summary>
            <param name="min">[Output] Minimum value</param>
            <param name="max">[Output] Maximum value</param>
            <returns>true if the limits exists and could be computed, false otherwise</returns>
            <remarks>Empty arrays will return false. In this case the output parameter will be: default(ElementType).
            </remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.GetLimits(`0@,`0@,System.Boolean)">
            <summary>
            Get minimum and maximum value of all elements - if any
            </summary>
            <param name="min">[Output] Minimum value</param>
            <param name="max">[Output] Maximum value</param>
            <param name="includeInfNaNs">true: recognize Inf, NaN values; false: ignore those values</param>
            <returns>true if the limits exists and could be computed, false otherwise</returns>
            <remarks>Empty arrays will return false. In this case the output parameter will be: default(ElementType).</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.GetElementType">
            <summary>
            Gets the System.Type of the elements stored in this array
            </summary>
            <returns>Sytem.Type of the generic argument of concreate subclass instances</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.System#Collections#Generic#IEnumerable{ElementType}#GetEnumerator">
            <summary>
            Enumerator returning elements as ElementType
            </summary>
            <returns>Enumerator</returns>
            <remarks>This method enables the us of ILNumerics arrays in foreach loops.
            <para>This iterator implements IEnumerable&lt;ElementType> explicitely and is used in situations, 
            where instances of ILNumerics arrays are casted to instances of the IEnumerable interface. This iterator 
            is not integrated into the ILNumerics memory management.</para></remarks>
            <example><code>ILDenseStorage&lt;T&gt; A = ILMath.rand(5,4,6);
            foreach (double element in A) {
            // all elements are scalar double values
            String.Format("Element: {0} ",element);
            // Note: 'element' cannot be used to alter the collection! 
            } 
            </code></example> 
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerator returning elements as ElementType
            </summary>
            <returns>Enumerator</returns>
            <remarks>This method enables the use of ILNumerics arrays in foreach loops directly.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.GetEnumerator">
            <summary>
            Enumerator returning elements as ElementType
            </summary>
            <returns>Enumerator</returns>
            <remarks>This method enables the use of ILNumerics arrays in foreach loops directly.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray`1.IsComplex">
            <summary>
            Determine if this array has complex elements.
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray`1.IsNumeric">
            <summary>
            Determine if this array holds numeric values.
            </summary>
            <remarks>An ILArray is numeric as long as its elements are one of the 
            following types: 
            <list type="table">
            <listheader>
                <term>inner type</term>
            </listheader>
            <item>
                <term>System.double</term>
                <description>floating point, real, 8 bytes </description>
            </item>
            <item>
                <term>System.float</term>
                <description>floating point real, 4 bytes</description>
            </item>
            <item>
                <term>ILNumerics.complex</term>
                <description>floating point complex, 16 bytes</description>
            </item>
            <item>
                <term>ILNumerics.fcomplex</term>
                <description>floating point complex, 8 bytes</description>
            </item>
            <item>
                <term>System.char</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.byte</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.Int16</term>
                <description>integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.Int32</term>
                <description>integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.Int64</term>
                <description>integer, real, 8 byte</description>
            </item>
            <item>
                <term>System.UInt16</term>
                <description>unsigned integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.UInt32</term>
                <description>unsigned integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.UInt64</term>
                <description>unsigned integer, real, 8 byte</description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray`1.Storage">
            <summary>
            Access to internal typed storage 
            </summary>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.GetArrayForRead">
            <summary>
            Get direct reference to inner System.Array storage for <b>read access</b> - use with care! 
            </summary>
            <returns>Reference to inner System.Array for reading</returns>
            <remarks>This method is provided for experts only! Altering elements of this 
            array may cause the data to be invalidated or corrupted! Use this array only for reading! Note 
            the ILNumerics array storage format (column major). Keep in mind, the length 
            of the internal system array T[] may exceeds the number of elements in this ILNumerics array! 
            <para>Accessing the inner system array directly should be left to ILNumerics experts only! 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T>!</para>
            <para>Unlike other member functions of ILNumerics arrays, this function
            does not keep track of internal memory management. It means, the storage which this array is based 
            upon, will not be set free after the function returns. You will have to keep 
            track of the reference yourself. As a rule of thumb, the reference is only valid within the current 
            ILNumerics scope, which <a href="http://ilnumerics.net/FunctionRules.html">obligatory for all function bodies</a>. 
            If the reference is used outside of the current 
            ILNumerics scope, the behavior is undefined. It is likely that the reference will address the storage of 
            another ILNumerics array already by then!</para>
            <para>Furthermore, for elements of reference
            types (e.g. ILCell), retrieving and storing elements from/into the System.Array directly does 
            not simulate a value semantic as all other functions do! This means, references are copied. Attention
            must be paid to dereference / clone elements accordingly. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.Clone">
            <summary>
            Clone of this array
            </summary>
            <remarks><para>
            Clones of all arrays in ILNumerics are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays 
            on write access.</para>
            <para>The clone returned will be of the same type as this instance.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.Concat(ILNumerics.ILInArray{`0},System.Int32)">
            <summary>
            Concatenate this array
            </summary>
            <param name="A">N-dimensional array. Except for dimensions <paramref name="dim"/>
            the dimensions of A must match the dimensions of this storage</param>
            <param name="dim">Index of dimension to concatenate arrays along.
            If dim is larger than the number of dimensions of any of the arrays,
            its value will be used in modulus the number of dimensions.</param>
            <returns>New array having the size 
            of both input arrays layed behind each other along the dim's-dimension</returns>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.ExportValues(`0[]@)">
            <summary>
            Copy values of all elements into System.Array.
            </summary>
            <param name="outArray">[Output] System.Array, holding all element values of this ILDenseStorage.</param>
            <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            its leading elements will be overwritten when function returns. If 'outArray' is null or has too few elements, 
            it will be recreated from the ILNumerics memory pool.</remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.GetEnumerator">
            <summary>
            Enumerator returning elements as ElementType
            </summary>
            <returns>Enumerator</returns>
            <remarks>This method enables the use of ILNumerics arrays in foreach loops.
            <para>The iterator is returned, if arrays are directly used in foreach statements. The iterator 
            is compatible with ILNumerics memory management.</para></remarks>
            <example><code>ILArray&lt;double&gt; A = rand(5,4,6);
            foreach (double element in A) {
                // all elements are scalar double values
                String.Format("Element: {0} ", element);
                // Note: 'element' cannot be used to alter the collection! 
            } </code>
            </example> 
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.GiveStorageAwayOrClone">
            <summary>
            Gives away internal storage for further use (e.g. in ILArray), disposes this array
            </summary>
            <returns>Internal storage</returns>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.Repmat(System.Int32[])">
            <summary>
            Create replication of this array
            </summary>
            <param name="dims">Dimensions specifier. If the number of elements in <paramref name="dims"/> is 
            less than the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
            <returns>Array being created by multiple replications of this array along 
            arbitrary dimensions according to <paramref name="dims"/></returns>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.Reshape(ILNumerics.ILSize)">
            <summary>
            Reshaped copy of this array
            </summary>
            <param name="dimensions">New dimensions of the array</param>
            <returns>Reshaped copy of the array</returns>
            <remarks><para>The current instance will not be changed. A new storage is created, having 
            the elements of this array and a shape as determined by <paramref name="dimensions"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in <paramref name="dimensions"/>
            do not match the number of elements in this array.</exception>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.Reshape(System.Int32[])">
            <summary>
            Reshaped copy of this array
            </summary>
            <param name="dimensions">New dimensions of the array</param>
            <returns>Reshaped copy of the array</returns>
            <remarks><para>The current instance will not be changed. A new array is created, having 
            the elements of this array and a shape as determined by <paramref name="dimensions"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 'newDimension'
            do not match the number of elements in this array.</exception>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray creation
            </summary>
            <param name="size">Range specification, defining the size of the subarray</param>
            <returns>Subarray as copy of a part of this array</returns>
            <remarks>Consult the ILNumerics subarray documentation for all subarray indexing rules.</remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.Shifted(System.Int32)">
            <summary>
            Create array from this array and shift dimensions
            </summary>
            <param name="shift">Number of dimensions to shift</param>
            <returns>Shifted version of this array</returns>
            <remarks><para>The shift is done 'to the left':</para>
            <example><code>ILArray&lt;double&gt; A = zeros(2,4); 
            ILArray&lt;double&gt; B = A.Shifted(1); 
            // B is now: &lt;double&gt; [4,2]
            
            ILArray&lt;double&gt; C = zeros(2,4,3);
            ILArray&lt;double&gt; D = C.Shifted(1);
            // D is now: &lt;double&gt; [4,3,2]
            </code></example>
            <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style.</para>
            <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T"/> property for readability.</para>
            <para><paramref name="shift"/> must be positive. It is taken modulus the number of dimensions.</para>
            <seealso cref="P:ILNumerics.ILDenseArray`1.T"/></remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
            <summary>
            Send values of this instance to stream. 
            </summary>
            <param name="stream">Stream to write the values into.</param>
            <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)"/> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
            <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags"/>. Specifies the way in which
            the values will be serialized.</param>
            <remarks><para>If the 'Formatted' method is used, any occurences of the NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style of the output.</para>
            <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as the
            array name for writing. This array instance will be the only array in the .mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.TryGetStorage4InplaceOp(`0[]@)">
            <summary>
            Give that storage away for in-place operations, if possible (depends on scope and temp type of array)
            </summary>
            <returns>true if the storage of the array is about to get disposed anyway</returns>
            <remarks>The function investigates the state of the array. If this is a temporary array in 
            the outer most scope, it would get disposed after the </remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Subtraction(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            Elementwise subtraction operator
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result of subtraction</returns>
            <remarks>The operator is defined for both arrays of the same numeric 'ElementType' (double, float, complex,
            fcomplex, int, long, byte).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the array elements are of an unsupported type</exception>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Addition(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            Elementwise addition operator
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result of addition</returns>
            <remarks>The operator is defined for both arrays of the same numeric 'ElementType' (double, float, complex,
            fcomplex, int, long, byte).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the array elements are of an unsupported type</exception>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Multiply(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            Elementwise multiplication operator
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result of multiplication</returns>
            <remarks>The operator is defined for both arrays of the same numeric 'ElementType' (double, float, complex,
            fcomplex, int, long, byte).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the array elements are of an unsupported type</exception>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Division(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            Elementwise division operator
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result of division</returns>
            <remarks>The operator is defined for both arrays of the same numeric 'ElementType' (double, float, complex,
            fcomplex, int, long, byte).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the array elements are of an unsupported type</exception>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Modulus(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            Elementwise modulus operator
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result of modulus operation</returns>
            <remarks>The operator is defined for 2 arrays of the same numeric real element types: double, float, int, long, byte.</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the array elements are of an unsupported type</exception>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Equality(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            'Equalty' operator of two arrays
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Logical array of same size than A and B, result of operation along all elements</returns>
            <remarks>Sizes and types of A and B must match.</remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Inequality(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            'unequalty' operator of two arrays
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Logical array of same size than A and B, result of operation along all elements</returns>
            <remarks>Sizes and types of A and B must match.</remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_GreaterThanOrEqual(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            'greater or equal' operator of two arrays
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Logical array of same size than A and B, result of operation along all elements</returns>
            <remarks>Sizes and types of A and B must match.</remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_LessThanOrEqual(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            'smaller or equal' operator of two arrays
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Logical array of same size than A and B, result of operation along all elements</returns>
            <remarks>Sizes and types of A and B must match.</remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_GreaterThan(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            'greater' operator of two arrays
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Logical array of same size than A and B, result of operation along all elements</returns>
            <remarks>Dimension and types of A and B must match.</remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_LessThan(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            'smaller' operator of two arrays
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Logical array of same size than A and B, result of operation along all elements</returns>
            <remarks>Dimension and types of A and B must match.</remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Explicit(ILNumerics.ILDenseArray{`0})~`0">
            <summary>
            Explicitly convert scalar array to System.Value type (ElementType)
            </summary>
            <param name="val">Array of arbitrary type and size of 1x1</param>
            <returns>Single value of type ElementType and of scalar size (1x1)</returns>
            <exception cref="T:ILNumerics.Exceptions.ILCastException">If input array is not scalar</exception>
            <exception cref="T:System.NullReferenceException">If val is null</exception>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Implicit(`0)~ILNumerics.ILDenseArray{`0}">
            <summary>
            Implicitly convert scalar to array of size 1x1 (scalar).
            </summary>
            <param name="val">Single element of ElementType type</param>
            <returns>New array of type ILRetArray<![CDATA[<ElementType>]]> of size 1x1 
            holding the only element with value of val.
            </returns>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_UnaryNegation(ILNumerics.ILDenseArray{`0})">
            <summary>
            Negate elements of array - if applicable
            </summary>
            <param name="A">Input array</param>
            <returns>New solid arrray having the elements of A negated</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If elements of the array are not of 
            any supported numeric type</exception>
        </member>
        <member name="P:ILNumerics.ILDenseArray`1.Storage">
            <summary>
            internal access to the underlying storage
            </summary>
        </member>
        <member name="P:ILNumerics.ILDenseArray`1.C">
            <summary>
            Clone of this array (fast, lazy and shallow)
            </summary>
        </member>
        <member name="P:ILNumerics.ILDenseArray`1.T">
            <summary>
            Return transposed version of this array
            </summary>
            <remarks>For matrices, this swaps columns with rows. For arrays, the dimensions are shifted by one.
            <para>Note, for complex elements, <b>no</b> conjugate is created! Use conj(A.T) if this is intended.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILDenseArray`1.MaxValue">
            <summary>
             [deprecated] Get maximum value of array - if any
            </summary>
            <remarks>This property is marked as deprecated and will be removed in a future version. Use one of the 
            following alternatives instead: 
            </remarks>
            <seealso cref="M:ILNumerics.ILBaseArray`1.GetLimits(`0@,`0@)"/>
        </member>
        <!-- Ung端ltiger XML-Kommentar wurde f端r den Member "P:ILNumerics.ILDenseArray`1.MinValue" ignoriert -->
        <member name="P:ILNumerics.ILDenseArray`1.ReferenceCount">
            <summary>
            Get number of arrays, referencing the same underlying data storage 
            </summary>
            <return>This number is always greater than or equal to 1.</return>
            <remarks>For temporary arrays (ILRetArray&lt;T&gt;), calling this property is not considered a 
            'regular use' (hence does not dispose off the array as usual).</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Create new ILArray, specify (dense) storage
            </summary>
            <param name="storage"></param>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(ILNumerics.ILSize)">
            <summary>
            create new ILArray, specify dimensions
            </summary>
            <param name="dimensions"></param>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(ILNumerics.Storage.ILDenseStorage{`0},System.Boolean)">
            <summary>
            create new ILArray, specify storage and if the new array should be disposed automatically
            </summary>
            <param name="storage"></param>
            <param name="registerForDisposal"></param>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(ILNumerics.ILSize,System.Boolean)">
            <summary>
            create new ILArray, specify dimensions
            </summary>
            <param name="dimensions"></param>
            <param name="registerForDisposal"></param>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(`0[],ILNumerics.ILSize)">
            <summary>
            create new ILArray from System.Array
            </summary>
            <param name="elements">System.Array</param>
            <param name="size">dimension specifier</param>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(`0[],ILNumerics.ILSize,System.Boolean)">
            <summary>
            create new ILArray from System.Array, optionally register the array for disposal 
            </summary>
            <param name="elements">System.Array</param>
            <param name="registerForDisposal">if true, the array will be disposed once the current scope is closed</param>
            <param name="size">dimension specifier</param>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(`0[],System.Int32[])">
            <summary>
            create new ILArray from System.Array
            </summary>
            <param name="elements">System.Array</param>
            <param name="size">dimension specifier</param>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(`0[])">
            <summary>
            create new ILArray from System.Array
            </summary>
            <param name="elements">variable length System.Array</param>
        </member>
        <member name="M:ILNumerics.ILArray`1.empty(System.Int32[])">
            <summary>
            [deprecated] Create empty array of arbitrary size
            </summary>
            <param name="size">Dimension sizes</param>
            <returns>New empty array</returns>
            <remarks>This function is markes as deprecated and only included for compatibility reasons.
            It will be removed in a future version. Use <see cref="M:ILNumerics.ILMath.empty``1"/> instead.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.empty(ILNumerics.ILSize)">
            <summary>
            [deprecated] Create empty array of arbitrary size
            </summary>
            <param name="size">Dimension sizes</param>
            <returns>New empty array</returns>
            <remarks>This function is markes as deprecated and only included for compatibility reasons.
            It will be removed in a future version. Use <see cref="M:ILNumerics.ILMath.empty``1"/> instead.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(`0)~ILNumerics.ILArray{`0}">
            <summary>
            Implicitly convert scalar to array of size 1x1 (scalar).
            </summary>
            <param name="val">System type of size scalar</param>
            <returns>New ILArray of type ILArray <![CDATA[<typeof(val)>]]> of size 1x1 
            holding the only element with value of val.
            </returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(`0[])~ILNumerics.ILArray{`0}">
            <summary>
            Implicitly cast one dimensional System.Array to ILNumerics array (vector)
            </summary>
            <param name="A">1-dimensional system array, arbitrary type</param>
            <returns>ILNumerics array of same element type as elements of A. If A is null: empty array.</returns>
            <remarks><para>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion</para>
            <para>The size of the result depends on the global option <c>Settings.CreateRowVectorByDefault</c></para></remarks>
            <seealso cref="P:ILNumerics.Settings.CreateRowVectorsByDefault"/>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(System.Array)~ILNumerics.ILArray{`0}">
            <summary>
            Implicitly convert n-dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">Arbitrarily sized System.Array</param>
            <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
            <remarks>The inner type of input array <paramref name="A"/> must match the requested type
            <typeparamref name="ElementType"/>. The resulting ILArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of the output array (shallow copy).</remarks>
            <seealso cref="P:ILNumerics.Settings.CreateRowVectorsByDefault"/>
            <exception cref="T:ILNumerics.Exceptions.ILCastException">If type of input does not match 
            ElementType</exception>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(`0[0:,0:])~ILNumerics.ILArray{`0}">
            <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">2-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(`0[0:,0:,0:])~ILNumerics.ILArray{`0}">
            <summary>
            Implicitly cast three dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">3-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(ILNumerics.ILRetArray{`0})~ILNumerics.ILArray{`0}">
            <summary>
            "Persistence cast" make a steady array out of a temp array
            </summary>
            <param name="A">Temporary array</param>
            <returns>Steady ILArray, will survive multiple usages</returns>
            <remarks>This is one of the most important casts in the ILNumerics framework. It changes temporary 
            arrays from temporary state to ('steady') ILArrays and persistent state. The inner storage is kept and used for 
            the new array. The new arrays can than get used multiple times in any function. In contrast to
            that, ILRetArrays are disposed off after first use.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(ILNumerics.ILInArray{`0})~ILNumerics.ILArray{`0}">
            <summary>
            "Persistence cast" make a steady array out of an input array
            </summary>
            <param name="A">Input array</param>
            <returns>Steady ILArray, will survive multiple usages</returns>
            <remarks>This is one of the most important casts in the ILNumerics framework. It changes temporary 
            arrays from temporary state to ('steady') ILArrays and persistent state. The inner storage is kept and used for 
            the new array. The new arrays can than get used multiple times in any function. In contrast to
            that, ILRetArrays are disposed off after first use.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(ILNumerics.ILOutArray{`0})~ILNumerics.ILArray{`0}">
            <summary>
            "Persistence cast" make a steady array out of an input array
            </summary>
            <param name="A">Input array</param>
            <returns>Steady ILArray, will survive multiple usages</returns>
            <remarks>This is one of the most important casts in the ILNumerics framework. It changes temporary 
            arrays from temporary state to ('steady') ILArrays and persistent state. The inner storage is kept and used for 
            the new array. The new arrays can than get used multiple times in any function. In contrast to
            that, ILRetArrays are disposed off after first use.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(ILNumerics.ILArray{`0})~ILNumerics.ILRetCell">
            <summary>
            Convert dense array to scalar temporary cell 
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar cell having the only element with a clone of array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.Assign(ILNumerics.ILRetArray{`0})">
            <summary>
            Assign another array to this array variable. This is an optional, yet more efficient alternative to '='
            </summary>
            <param name="value">New array</param>
            <remarks>By using this method, this array is immediately released to the memory pool and replaced by the new array. In difference to that, 
            by using the common '=' assignment operator, the array is released only at the time, the current 
            <see cref="M:ILNumerics.ILScope.Enter(ILNumerics.ILBaseArray[])"/> block  is left. Therefeore, prefere this method, if a 
            smaller memory pool is crucial.</remarks>
            <seealso cref="M:ILNumerics.ILOutArray`1.Assign(ILNumerics.ILRetArray{`0})"/>
        </member>
        <member name="M:ILNumerics.ILArray`1.GetArrayForWrite">
            <summary>
            Direct reference to inner System.Array storage for write access - use with care!
            </summary>
            <returns>Reference to inner System.Array</returns>
            <remarks>Altering this array can be done directly. If necessary, the array is detached before 
            returned. Watch the column order format of storages in ILNumerics. Keep in mind, the length 
            of the System.Array may exceed the number of elements of the ILNumerics array.
            <para>Accessing the inner system array directly should be left to ILNumerics experts only. 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T>!</para>
            <para>For elements of reference types (e.g. ILCell), retrieving and storing elements from/into the System.Array directly 
            obviously does not simulate a value semantic as all other common API methods do! This means, references are copied. Attention
            must be paid to dereference / clone elements accordingly or (recommended) prevent from using this 
            function with reference element types.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetValue(`0,System.Int32[])">
            <summary>
            Set single value to element at index specified
            </summary>
            <param name="value">New value</param>
            <param name="idx">Index of element to be altered</param>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILInArray{`0},ILNumerics.ILBaseArray[])">
            <summary>
            Alter range of this array
            </summary>
            <param name="value">Array with new values</param>
            <param name="range">Range specification</param>
        </member>
        <member name="P:ILNumerics.ILArray`1.a">
            <summary>
            Assign another array to this array variable. This is an optional, yet more efficient alternative to using '='
            </summary>
            <param name="value">New array</param>
            <remarks>By assigning to this property, this array is immediately released to the memory pool and replaced by the new array. In difference to that, 
            by using the common '=' assignment operator, the array is released only at the time, the current 
            <see cref="M:ILNumerics.ILScope.Enter(ILNumerics.ILBaseArray[])"/> block  is left. Therefeore, prefere this method, if a 
            smaller memory pool is crucial. However, for variables of type <c>ILArray</c>, regular assignments are allowed as well.</remarks>
            <seealso cref="M:ILNumerics.ILOutArray`1.Assign(ILNumerics.ILRetArray{`0})"/>
        </member>
        <member name="P:ILNumerics.ILArray`1.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray creation/ manipulation/ deletion
            </summary>
            <param name="range">Range specification, defining the size of the subarray</param>
            <returns>Subarray as copy of this array</returns>
        </member>
        <member name="T:ILNumerics.ILBaseCell">
            <summary>
            The class implements additional functionality needed for cells
            </summary>
        </member>
        <member name="M:ILNumerics.ILBaseCell.Concat(ILNumerics.ILInCell,System.Int32)">
            <summary>
            Concatenate this cell 
            </summary>
            <param name="A">Cell to concatenate this cell with</param>
            <param name="dim">Dimension index along which to concatenate the cells.</param>
            <returns>New cell with concatenation of all elements of both cells</returns>
            <remarks>The array returned will be a copy of both cells involved. 
            If <paramref name="dim"/> is larger than 
            the number of dimensions of one of the arrays its value will be used in modulus. 
            <para>The resulting cell has the size of both input cells, laid beside one 
            another along the <paramref name="dim"/> dimension.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILBaseCell.GetArray``1(ILNumerics.ILBaseArray[])">
            <summary>
            Retrieve a single array of a known type from a cell position
            </summary>
            <typeparam name="T">Element type of the array</typeparam>
            <param name="indices">Position of the array within this cell</param>
            <returns>Lazy, shallow clone of the array found at the given position</returns>
        </member>
        <member name="M:ILNumerics.ILBaseCell.GetBaseArray(ILNumerics.ILBaseArray[])">
            <summary>
            For EXPERTS only! Retrieve a single element from the given position 
            </summary>
            <param name="indices">Position of the element to retrieve, must evaluate to a scalar position</param>
            <returns>A clone of the scalar element found</returns>
            <remarks>
            <para>The method returns a lazy, shallow clone of the content of the cell element specified by <paramref name="indices"/>. 
            However, the return type (<code>ILBaseArray</code>) is not strongly typed and may contain <b>any</b> element. According to the 
            true element stored in the cell, this might be an array of arbitrary type, null or even another cell. Moreover, handling 
            <code>ILBaseArray</code> directly is not recommended for ILNumerics, since this would hinder the memory management from proper 
            functioning. Therefore: <b>The use of this method is not recommended and left to ILNumerics experts - for very 
            specific and rare situations.</b></para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILBaseCell.GetCell(ILNumerics.ILBaseArray[])">
            <summary>
            Retrieves a subcell of this cell
            </summary>
            <param name="indices">Subcell definition, arbitrary size</param>
            <returns>A cell with a lazy, shallow clone of the elements of this cell, addressed by <paramref name="indices"/></returns>
            <remarks>The cell returned will have the size and shape specified by <paramref name="indices"/>.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseCell.GetEnumerator">
            <summary>
            Enumerator returning elements as scalar cells
            </summary>
            <returns>Enumerator</returns>
            <remarks>This method enables the use of cells in foreach loops.
            <para>The iterator is returned, if arrays are directly used in foreach statements. The iterator 
            is compatible with ILNumerics memory management.</para></remarks>
            <example><code>ILDenseStorage&lt;T&gt; A = ILMath.rand(5,4,6);
            foreach (double element in A) {
            // all elements are scalar double values
            String.Format("Element: {0} ",element);
            // Note: 'element' cannot be used to alter the collection! 
            } 
            </code></example> 
        </member>
        <member name="M:ILNumerics.ILBaseCell.GetValue(System.Int32[])">
            <summary>
            Retrieve single element from this cell
            </summary>
            <param name="idx">Position of the element</param>
            <returns>Lazy, shallow clone of the element to retrieve or null, if there is no element at this place</returns>
        </member>
        <member name="M:ILNumerics.ILBaseCell.GetValue``1(System.Int32[])">
            <summary>
            Retrieve a typed single element from within the cell, supports deep indexing
            </summary>
            <typeparam name="T">Expected type of the value to be returned</typeparam>
            <param name="indices">Location of the single element addressed</param>
            <returns>A clone of the single element addressed by <paramref name="indices"/></returns>
            <remarks>The element returned will have the type given by <typeparamref name="T"/>. It is an error to specify 
            a different type as the true type of the element specified. An exception is thrown if both types differ.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseCell.IsTypeOf``1(ILNumerics.ILBaseArray[])">
            <summary>
            Test if an element of the cell is an array of the given element type
            </summary>
            <typeparam name="T">The array element type to check the cell element against</typeparam>
            <param name="position">Position of the cell element to be tested</param>
            <returns>true if the element found at the given position is an array of the element type <typeparamref name="T"/>, false otherwise</returns>
            <remarks>The method is helpful in order to investigate the contents of a cell array. If you are not sure about the 
            types of elements in the cell, this function can be used to make sure, elements are of the expected type before retrieving them as such.
            <para>In most situations, elements of a cell are stored arrays of a distinct element type. That element type is given to IsTypeOf as 
            typeparameter <typeparamref name="T"/>. That means, in order to find out, if the first cell element stores an array of int (<code>ILArray&lt;int></code>), 
            one may use <code>cell.IsTypeOf&lt;int>(0)</code></para>
            <para>In order to test, if a cell element is of type <code>ILCell</code>, one can provide the type <code>ILCell</code> as type parameter: 
            <code>cell.IsTypeOf&lt;ILCell>(0)</code>. Note the different semantic when checking for cell elements of type cell. Here we do not test for the 
            element type but for the array type itself, ie. <code>ILCell</code>. The reason of this is: the type of elements of <code>ILCell</code> is 
            an implementation detail and therefore hidden to the user.</para>
            </remarks>
            <example>
            <para>In the following example a ILCell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
            <code>ILCell cell = ILMath.cell(new ILSize(3, 2) 
                                 , "first element"
                                 , 2.0
                                 , ILMath.cell(Math.PI, 100f)
                                 , ILMath.create&lt;short>(1, 2, 3, 4, 5, 6)
                                 , new double[] {-1.4, -1.5, -1.6});
            </code>
            The cell is now: 
            <code>ILCell [3,2]
                     &lt;String>      first element  &lt;Int16> [2,3,4,5,6] 
                     &lt;Double>          2          ILCell [1,3]           
                     ILCell [2,1]                                    (null)	
            </code>
            We test the element type of every element in the cell: 
            <code>
            Console.Out.WriteLine("cell[0,0] is of type 'string': {0}", cell.IsTypeOf&lt;string>(0));
            Console.Out.WriteLine("cell[0,0] is of type 'double': {0}", cell.IsTypeOf&lt;double>(0));
                                                 
            Console.Out.WriteLine("cell[1,0] is of type 'double': {0}", cell.IsTypeOf&lt;double>(1));
            Console.Out.WriteLine("cell[2,0] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell>(2));
                                                                                    
            Console.Out.WriteLine("cell[0,1] is of type 'short': {0}", cell.IsTypeOf&lt;short>(0, 1));
            Console.Out.WriteLine("cell[1,1] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell>(1, 1));
            Console.Out.WriteLine("cell[2,1] is of type 'double': {0}", cell.IsTypeOf&lt;double>(2, 1));
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'ILCell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'ILCell': True
            cell[2,1] is element type 'double': False  // element is null, IsTypeOf&lt;> never gives true
            </code></example>
        </member>
        <member name="M:ILNumerics.ILBaseCell.Reshape(ILNumerics.ILSize)">
            <summary>
            Create reshaped copy of this cell
            </summary>
            <param name="size">New size of the cell</param>
            <returns>Reshaped copy of the cell</returns>
            <remarks><para>The current instance will not be changed! A new cell is created, having 
            the elements of this cell and a shape as determined by <paramref name="size"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="size"/> do not match the number of elements in this cell.</exception>
        </member>
        <member name="M:ILNumerics.ILBaseCell.Reshape(System.Int32[])">
            <summary>
            Create reshaped copy of this cell
            </summary>
            <param name="size">New size of the cell</param>
            <returns>Reshaped copy of the cell</returns>
            <remarks><para>The current instance will not be changed! A new cell is created, having 
            the elements of this cell and a shape as determined by <paramref name="size"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="size"/> do not match the number of elements in this cell.</exception>
        </member>
        <!-- Ung端ltiger XML-Kommentar wurde f端r den Member "M:ILNumerics.ILBaseCell.Repmat(System.Int32[])" ignoriert -->
        <member name="M:ILNumerics.ILBaseCell.Shifted(System.Int32)">
            <summary>
            Dimension shifted cell from this cell
            </summary>
            <param name="shift">Number of dimensions to shift</param>
            <returns>Shifted version of this cell</returns>
            <remarks><para>The shift is done 'to the left':</para>
            <example><code>ILCell A = cell(2,4); <br/>
            ILCell B = A.Shifted(1); <br/>
            // B is now: ILCell [4,2] <br/>
            // <br/>
            ILCell C = cell(2,4,3);<br/>
            ILCell D = C.Shifted(1); <br/>
            // D is now: ILCell [4,3,2] <br/>
            </code></example>
            <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style. </para>
            <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T"/> property for readability.</para>
            <para><paramref name="shift"/> must be positive. It is taken modulus the number of dimensions.</para>
            <seealso cref="P:ILNumerics.ILDenseArray`1.T"/></remarks>
        </member>
        <member name="M:ILNumerics.ILBaseCell.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access. Get/set regular subarray. 
            </summary>
            <param name="indices">Address range</param>
            <returns>Reference cell array with subarray addressed by <c>indices</c>. </returns>
            <remarks>Query access: for N-dimensional cell arrays missing trailing dimensions indices will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para>
            <para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements.</para>
            <para>The indexer may also be used for removing parts of the cell. Therefore null must be assigned to the range specified by <c>indices</c> (using the set-access). <c>indices</c> 
            must contain exactly one dimension specification other than 'full' in this case. This may be any vector-sized numeric ILArray of any 
            numeric type. If <c>indices</c> apply to fewer dimensions than the number of dimensions existing, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.
            <example>
            <code>
            ILCell C = new ILCell(4,10); 
            C[":",2] = null;  // &gt;- will remove the third column (index: 2) from the cell.
            C[full,vec(2,5)] = null;  &gt;- will remove columns 3...6
            C[1,1] = null; &gt;- will produce an error. Only one dimension can be specified not full! 
            </code></example></para>
            <para>The general behavior of this access methods is full compatible with the corresponding Matlab/Octave/Scilab access: a(:) = []. </para>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILBaseCell.T">
            <summary>
            Transposed version of this ILCell
            </summary>
            <remarks>This property is an alias for 'Shifted(1). </remarks>
            <seealso cref="M:ILNumerics.ILBaseCell.Shifted(System.Int32)"/>
        </member>
        <member name="P:ILNumerics.ILBaseCell.Storage">
            <summary>
            Access to the more specialized version (ILCellStorage) of this storage
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseCell.C">
            <summary>
            Clone of this cell
            </summary>
            <remarks><para>
            Clones of all arrays in ILNumerics.Server are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays on write access.</para>
            <para>Cells profit from the same efficient clone creation process. However, since a cell may store an arbitrarily deep 
            hirarchy of other cells and arrays, in order to clone a cell, the cells elements have to be cloned as well - in an 
            recursive manner. Clones play an important role for ILNumerics cells. They are used to implement value semantics for cell
            elements. I.e.: the cloned cell returned cannot not be used to alter elements of the original cell in any way.</para></remarks>
        </member>
        <member name="T:ILNumerics.ILBaseLogical">
            <summary>
            Boolean array for high performance relational operations on arbitrary arrays 
            </summary>
            <remarks>
            Logical arrays are derived from <![CDATA[ILArray<byte>]]>. It consumes
            1 byte per element and is the output parameter of all relational comparisons
            as well as the input parameter for all functions consuming <![CDATA[ILArray<byte>]]>.
            The difference between <![CDATA[<byte>]]> and an ILLogical is, the ILLogical 
            storing a integer value with the number of nonzero elements as additional information. 
            Therefore functions like 'find' are able to determine the lenght of output array to 
            be created omitting the need of multiple walks through the array. Therefore ILLogicalArrays 
            consume (a little) more time while construction but are much more performand on functions like 
            'find'.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.#ctor(ILNumerics.Storage.ILDenseStorage{System.Byte},System.Boolean)">
            <summary>
            Constructor creating ILLogical from dense storage
            </summary>
            <param name="A">Input array, the storage of this ILArray will directly be used for 
            storage of the new ILLogical</param>
            <param name="isTempArray">Indicate whether the result is supposed to be a temporary array (true) or persistent (false)</param>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.sumElements">
            <summary>
            Sum all elements of this storage. 
            </summary>
            <returns>Number of non zero elements</returns>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.Concat(ILNumerics.ILInLogical,System.Int32)">
            <summary>
            Concatenate this array
            </summary>
            <param name="A">N-dimensional array. Except for dimensions <paramref name="dim"/>
            the dimensions of A must match the dimensions of this storage</param>
            <param name="dim">Index of dimension to concatenate arrays along.
            If dim is larger than the number of dimensions of any of the arrays,
            its value will be used in modulus the number of dimensions.</param>
            <returns>New array having the size 
            of both input arrays layed behind each other along the dim's-dimension</returns>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.Reshape(ILNumerics.ILSize)">
            <summary>
            Create reshaped copy of this logical array
            </summary>
            <param name="size">New dimensions of the array</param>
            <returns>Reshaped copy of this array</returns>
            <remarks><para>The current instance will not be changed! A new array is created, having 
            the elements of this array and a shape as determined by <paramref name="size"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="size"/> do not match the number of elements in this array.</exception>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.Reshape(System.Int32[])">
            <summary>
            Create reshaped copy of this logical array
            </summary>
            <param name="size">New dimensions of the array</param>
            <returns>Reshaped copy of the array</returns>
            <remarks><para>The current instance will not be changed! A new array is created, having 
            the elements of this array and a shape as determined by <paramref name="size"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="size"/> do not match the number of elements in this array.</exception>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.Repmat(System.Int32[])">
            <summary>
            Create replication of this array
            </summary>
            <param name="dims">Dimensions specifier. If the number of elements in <paramref name="dims"/> is 
            less than the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
            <returns>array being created out of multiple replications of this array along 
            arbitrary dimensions according to <paramref name="dims"/></returns>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.Shifted(System.Int32)">
            <summary>
            Create logical array from this logical and shift dimensions
            </summary>
            <param name="shift">Number of dimensions to shift</param>
            <returns>Shifted version of this array</returns>
            <remarks><para>The shift is done 'to the left':</para>
            <example><code>ILArray&lt;double&gt; A = zeros(2,4); 
            ILArray&lt;double&gt; B = A.Shifted(1); 
            // B is now: &lt;double&gt; [4,2] 
            
            ILArray&lt;double&gt; C = zeros(2,4,3);
            ILArray&lt;double&gt; D = C.Shifted(1); 
            // D is now: &lt;double&gt; [4,3,2] 
            </code></example>
            <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style.</para>
            <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T"/> property for readability.</para>
            <para><paramref name="shift"/> must be positive. It is taken modulus the number of dimensions.</para>
            <seealso cref="P:ILNumerics.ILDenseArray`1.T"/></remarks>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray from this array
            </summary>
            <param name="range">Arrays specifying the ranges to create subarray from</param>
            <returns>Subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.ShortInfo">
            <summary>
            Short summary of this logical array
            </summary>
            <returns>Type and size information</returns>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.empty(ILNumerics.ILSize)">
            <summary>
            [deprecated] create empty ILLogical 
            </summary>
            <returns>empty ILLogical.</returns>
        </member>
        <member name="P:ILNumerics.ILBaseLogical.NumberNonZero">
            <summary>
            Number of 'true' elements in this array
            </summary>
            <remarks>This value caches the number of 'true' elements in this logical array. 
            It may be used for information purposes but is actually needed internally for performance 
            reasons.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseLogical.T">
            <summary>
            Shift the dimensions of this array by one (transpose for matrix)
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseLogical.C">
            <summary>
            Create clone of this array 
            </summary>
        </member>
        <member name="T:ILNumerics.ILCell">
            <summary>
            Mathematical container class holding arbitrary array objects as elements 
            </summary>
            <remarks>
            Cells act as general purpose container. Cells store arbitrary arrays of arbitrary element type. 
            Theses elements commonly are cells itself. <c>ILCell</c> is used for local cell variables in 
            your algorithms. 
            <para>More details about cells are found in the <a href="http://ilnumerics.net/$Cells.html">online manual</a>.</para>
            </remarks>
            <seealso cref="T:ILNumerics.ILCell"/>
        </member>
        <member name="M:ILNumerics.ILCell.#ctor(ILNumerics.Storage.ILStorage[],System.Int32[])">
            <summary>
            Create cell object with pre-created data in specified dimensions 
            </summary>
            <param name="data">predefined element data array, will be used for new cell (no copy will be made)</param>
            <param name="size">size of the new cell</param>
            <remarks>object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)</remarks>
        </member>
        <member name="M:ILNumerics.ILCell.#ctor(ILNumerics.Storage.ILStorage[],ILNumerics.ILSize)">
            <summary>
            Create cell object with pre-created data in specified dimensions 
            </summary>
            <param name="data">predefined element data array, will be used for new cell (no copy will be made)</param>
            <param name="size">size of the new cell</param>
            <remarks>object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)</remarks>
        </member>
        <member name="M:ILNumerics.ILCell.#ctor(System.Int32[])">
            <summary>
            [deprecated] create new cell object, elements will be 'null' 
            </summary>
            <param name="size">dimension sizes of the new cell</param>
            <remarks><para>After creation, the cell elements can be set by use 
            of the indexer methods or by using corresponding methods of ILCell like SetValue()</para>
            <para>Consider using <see cref="M:ILNumerics.ILMath.cell()"/> in order to create 
            cell arrays.</para></remarks>
            <seealso cref="P:ILNumerics.ILCell.Item(System.Int32[])"/>
            <seealso cref="P:ILNumerics.ILCell.Item(ILNumerics.ILBaseArray[])"/>
            <seealso cref="M:ILNumerics.ILBaseCell.GetArray``1(ILNumerics.ILBaseArray[])"/>
        </member>
        <member name="M:ILNumerics.ILCell.op_Implicit(ILNumerics.ILRetCell)~ILNumerics.ILCell">
            <summary>
            Convert temporary cell to persistent cell
            </summary>
            <param name="A">Temporary cell</param>
            <returns>Persistent cell</returns>
        </member>
        <member name="M:ILNumerics.ILCell.op_Implicit(ILNumerics.ILInCell)~ILNumerics.ILCell">
            <summary>
            Convert input parameter cell to persistent cell
            </summary>
            <param name="A">Input parameter cell</param>
            <returns>Persistent cell</returns>
        </member>
        <member name="M:ILNumerics.ILCell.op_Implicit(ILNumerics.ILOutCell)~ILNumerics.ILCell">
            <summary>
            Convert output parameter cell to persistent cell
            </summary>
            <param name="A">Output parameter cell</param>
            <returns>Persistent cell</returns>
        </member>
        <member name="M:ILNumerics.ILCell.Assign(ILNumerics.ILRetCell)">
            <summary>
            Replaces storage of this array with new array elements, registers this array for out-of-scope disposal
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="M:ILNumerics.ILCell.SetValue(ILNumerics.ILBaseArray,System.Int32[])">
            <summary>
            Set single element of the cell
            </summary>
            <param name="value">The new value</param>
            <param name="idx">Indices specifying the location to set the element to</param>
            <remarks>The function supports the following features: 
            <list type="bullet">
            <item>Automatic expansion of the cell, when addressing an element outside of the cells size limits.</item>
            <item>Before storing the new element into the cell, an old element may existing on the same location gets disposed.</item>
            <item>A clone of the new value is stored, therefore, none of the source and the stored element are altered, whenever the other cell is altered (value semantics).</item>
            <item>The function supports deep index addressing. This is the only way of altering array elements inside the cell - without recreation.</item>
            </list>
            <para>Removal of parts of the cell is <b>not</b> supported. If null or an empty array is provided as <paramref name="value"/>, the corresponding 
            element is overwritten or removed.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILCell.SetValue(ILNumerics.Storage.ILStorage,System.Int32[])">
            <summary>
            Set single element of the cell
            </summary>
            <param name="value">The new value</param>
            <param name="idx">Indices specifying the location to set the element to</param>
            <remarks>The function supports the following features: 
            <list type="bullet">
            <item>Automatic expansion of the cell, when addressing an element outside of the cells size limits.</item>
            <item>Before storing the new element into the cell, an old element may existing on the same location gets disposed.</item>
            <item>A clone of the new value is stored, therefore, none of the source and the stored element are altered, whenever the other cell is altered (value semantics).</item>
            <item>The function supports deep index addressing. This is the only way of altering array elements inside the cell - without recreation.</item>
            </list>
            <para>Removal of parts of the cell is <b>not</b> supported. If null or an empty array is provided as <paramref name="value"/>, the corresponding 
            element is overwritten or removed.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILCell.SetRange(ILNumerics.ILInCell,ILNumerics.ILBaseArray[])">
            <summary>
            Alter range of this array
            </summary>
            <param name="value">Array with new values</param>
            <param name="range">Range specification</param>
            <remarks>All common array modification/ reshaping/ removing/ expansion rules apply.
            <para>Like for almost all operations on cell, the values stored in the cell are 
            not connected to the original cell elements outside the cell (value semantics).</para></remarks>
        </member>
        <member name="M:ILNumerics.ILCell.GetArrayForWrite">
            <summary>
            Direct reference to inner System.Array storage for write access - use with care!
            </summary>
            <returns>Reference to inner System.Array</returns>
            <remarks>Altering this array can be done directly. If necessary, the array is detached before 
            returned. Watch the column order format of storages in ILNumerics. Keep in mind, the length 
            of the System.Array may exceed the number of elements of the ILNumerics array.
            <para>Accessing the inner system array directly should be left to ILNumerics experts only. 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T>!</para>
            <para>Unlike (almost) all other member function of an array, this function
            does not keep track of internal memory management. It means, the storage which this array is based 
            upon, will not be set free after the function returns. You (as the user of the array) will have to pay 
            attention yourself, when to call dispose on the array - if necessary. Also, for elements of reference
            types (e.g. ILCell), retrieving and storing elements from/into the System.Array directly does 
            not simulate a value semantic as all other functions do! This means, references are copied. Attention
            must be paid to dereference / clone elements accordingly. </para></remarks>
        </member>
        <member name="P:ILNumerics.ILCell.a">
            <summary>
            Replace the elements of this array with another array's elements, preventing memory leaks
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="P:ILNumerics.ILCell.Item(System.Int32[])">
            <summary>
            Get/set/remove single element 
            </summary> 
            <paramref name="indices" value="Index to element"/>
            <value>Inner element, new inner element or null</value>
            <remarks>The type of access depends on the length of indices. If indices contains only one element, 
            the array will be accessed via sequential index access. This is sometimes called referred to as 'linear' 
            index addressing. 
            Sequential index access reflects the index of internal storage the way the data are actually organized 
            in memory. This access method is mainly convinient for vectors where you are not interested of orientation.
            The following example demonstrates sequential index access for ILArray's (which also holds for ILCells): 
            <example>For <c>
            ILArray&lt;double&gt; A = ILMath.counter(1,12);</c>, <c>A[2]</c> gives: 3.0.
            But the transpose 
            <c>A.T[2]</c> gives also: 3.0.
            For matrices and N-dimensional arrays this holds as well: 
            <code>
            ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,3,2,2);
            A = 
            [1.0 4.0
             2.0 5.0 
             3.0 6.0 
            
             7.0 10.0
             8.0 11.0
             9.0 12.0]
            
            A = ILMath.Reshape(A,3,2,2); 
            A[10] gives 11.0
            A[10,1] gives ILArgumentException -> out of range
            A[2,1,1] gives 12.0
            A[2,1] gives 6.0 (set trailing dimension to '0')</code></example>
            <para>If the element addressed is a ILCell itself, a deep reference to this element will be returned instead. 
            I.e. all elements of the ILCell will be recursively replaced with references to itself. Therefore, altering the 
            elements returned will not alter the elements contained in the cell.</para>
            <para>
            <list type="bullet">
            <listheader>The type of the element returned depends on the type of the element addressed:</listheader>
            <item>For ILArray&lt;ElementType&gt; the array returned will be a clone of the original array.</item> 
            <item>For ILCell the ILBaseArray returned is a deep reference of the original elements stored.</item>
            <item>For other types the behavior is undefined. (since other types are not implemented yet ;)</item>
            </list> </para>
            <para>This indexer may also be used for direct access to inner elements of (elements of elements of ...) this cell:
            <example>
            <code>
            ILCell innerCell = new ILCell(2,1); 
            innerCell[0] = ILMath.vec(10,200); 
            innerCell[1] = new int[] {-10,-20,-30};
            ILCell cell = new ILCell(2,1); 
            cell[0] = innerCell; 
            cell[1] = new string[] {"foobla"}; 
            // cell is now: 
            // [ILCell,(1x2)] 
            //      [innerCell[0], ILArray&lt;double&gt;(1x181)]
            //      [innerCell[0], ILArray&lt;double&gt;(1x3)]
            // [ILArray&lt;string&gt;,(1x1)]
            
            cell[0,0] -&gt; will give innerCell eq. ILCell (1x2)
            cell[0,1] -&gt; will give ILArray&lt;string&gt;
            cell[0,0,0,1] -&gt; will give innerCell[1] eq. ILArray&lt;int&gt;(1x3)
            </code>
            </example> 
            In the last example above the trailing indices specified make the indexer walk down into the ILCell element and retrieve 
            the content of this element. This kind of index access may be done as deep as you want. Just 
            append the inner indices into inner elements to the right side of index specification. Addressing inner elements 
            this way is the only way to alter elements <b>directly</b> inside the ILCell. </para></remarks>
        </member>
        <member name="P:ILNumerics.ILCell.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access. Get/set regular subarray. 
            </summary>
            <param name="indices">Address range</param>
            <returns>Reference cell array with subarray addressed by <c>indices</c>. </returns>
            <remarks>Query access: for N-dimensional cell arrays missing trailing dimensions indices will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para>
            <para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements.</para>
            <para>The indexer may also be used for removing parts of the cell. Therefore null must be assigned to the range specified by <c>indices</c> (using the set-access). <c>indices</c> 
            must contain exactly one dimension specification other than 'full' in this case. This may be any vector-sized numeric ILArray of any 
            numeric type. If <c>indices</c> apply to fewer dimensions than the number of dimensions existing, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.
            <example>
            <code>
            ILCell C = new ILCell(4,10); 
            C[":",2] = null;  // &gt;- will remove the third column (index: 2) from the cell.
            C[full,vec(2,5)] = null;  &gt;- will remove columns 3...6
            C[1,1] = null; &gt;- will produce an error. Only one dimension can be specified not full! 
            </code></example></para>
            <para>The general behavior of this access methods is full compatible with the corresponding Matlab/Octave/Scilab access: a(:) = []. </para>
            </remarks>
        </member>
        <member name="T:ILNumerics.ILInArray`1">
            <summary>
            Rectangular array, used as input parameter only 
            </summary>
            <typeparam name="ElementType">Inner type. This will mostly be a system numeric type or a 
            complex floating point type.</typeparam>
            <remarks><para>This class extends the primary <c>ILArray</c> by optimizing its behavior for the case when used as an
            input parameter to functions.</para><para>When writing your own function all <i>input</i> parameters should be of type <c>ILInArray</c>. 
            Similary, all return types should be of type <see cref="T:ILNumerics.ILRetArray`1"/> and all "out" parameters of type <see cref="T:ILNumerics.ILOutArray`1"/>.</para>
            <para>Other than being used to transfer arguments into functions, <c>ILInArray</c> should not be used.</para>
            </remarks>
            <seealso cref="T:ILNumerics.ILArray`1"/>
            <seealso cref="T:ILNumerics.ILRetArray`1"/>
            <seealso cref="T:ILNumerics.ILOutArray`1"/>
        </member>
        <member name="M:ILNumerics.ILInArray`1.#ctor(ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            create new ILInArray, specify (dense) storage
            </summary>
            <param name="storage"></param>
        </member>
        <member name="M:ILNumerics.ILInArray`1.#ctor(ILNumerics.ILSize)">
            <summary>
            create new ILInArray, specify dimensions
            </summary>
            <param name="dimensions"></param>
        </member>
        <member name="M:ILNumerics.ILInArray`1.#ctor(`0[],System.Int32[])">
            <summary>
            create new ILInArray from System.Array
            </summary>
            <param name="elements">System.Array</param>
            <param name="dimensions">dimension specifier</param>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(`0)~ILNumerics.ILInArray{`0}">
            <summary>
            Implicitly convert scalar to array of size 1x1 (scalar).
            </summary>
            <param name="val">System type of size scalar</param>
            <returns>New ILInArray of type ILInArray <![CDATA[<typeof(val)>]]> of size 1x1 
            holding the only element with value of val.
            </returns>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(`0[])~ILNumerics.ILInArray{`0}">
            <summary>
            Implicitly cast one dimensional System.Array to ILNumerics array (vector)
            </summary>
            <param name="A">1-dimensional system array, arbitrary type</param>
            <returns>ILNumerics array of same element type as elements of A. 
            Row vector. If A is null: empty array.</returns>
            <remarks>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion!</remarks>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(System.Array)~ILNumerics.ILInArray{`0}">
            <summary>
            Implicitly convert n-dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">Arbitrarily sized System.Array</param>
            <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
            <remarks>The inner type of input array <paramref name="A"/> must match the requested type
            <typeparamref name="ElementType"/>. The resulting ILInArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of output array (shallow copy).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILCastException"> if type of input does not match 
            ElementType</exception>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(`0[0:,0:])~ILNumerics.ILInArray{`0}">
            <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">2-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(`0[0:,0:,0:])~ILNumerics.ILInArray{`0}">
            <summary>
            Implicitly casts three dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">3-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(ILNumerics.ILInArray{`0})~ILNumerics.ILRetCell">
            <summary>
            Implicitly cast ILInArray to ILRetCell
            </summary>
            <param name="array">Input array</param>
            <returns>1x1 cell holding the array</returns>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(ILNumerics.ILRetArray{`0})~ILNumerics.ILInArray{`0}">
            <summary>
            Convert temporary to input parameter array
            </summary>
            <param name="array">Temp array</param>
            <returns>Input parameter array, will survive the current scope only</returns>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(ILNumerics.ILArray{`0})~ILNumerics.ILInArray{`0}">
            <summary>
            Convert persistent to input parameter array
            </summary>
            <param name="array">Persistent array</param>
            <returns>Input parameter array, will survive the current scope only</returns>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(ILNumerics.ILOutArray{`0})~ILNumerics.ILInArray{`0}">
            <summary>
            Convert output paramter array to input parameter array
            </summary>
            <param name="array">Output parameter array</param>
            <returns>Input parameter array, will survive the current scope only</returns>
        </member>
        <member name="P:ILNumerics.ILInArray`1.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray creation/ manipulation/ deletion
            </summary>
            <param name="range">Range specification, defining the size of the subarray</param>
            <returns>Subarray as copy of this array</returns>
        </member>
        <member name="T:ILNumerics.ILInCell">
            <summary>
            Mathematical container class holding arbitrary array objects as elements 
            </summary>
            <remarks>
            Cells act as general purpose container. Cells store arbitrary arrays of arbitrary element type. 
            Theses elements commonly are cells itself. <c>ILInCell</c> acts as input parameter 
            in function declarations only. 
            Use <see cref="T:ILNumerics.ILCell"/> for local cell variables in your algorithms. 
            <para>More details about cells are found in the <a href="http://ilnumerics.net/$Cells.html">online manual</a>.</para>
            </remarks>
            <seealso cref="T:ILNumerics.ILCell"/>
        </member>
        <member name="M:ILNumerics.ILInCell.#ctor(ILNumerics.Storage.ILStorage[],System.Int32[])">
            <summary>
            Create cell object with pre-created data in specified dimensions 
            </summary>
            <param name="data">Predefined element data array, will be used for new cell (no copy will be made)</param>
            <param name="size">Size of the new cell</param>
            <remarks>Object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)</remarks>
        </member>
        <member name="M:ILNumerics.ILInCell.#ctor(ILNumerics.Storage.ILStorage[],ILNumerics.ILSize)">
            <summary>
            Create cell object with pre-created data in specified dimensions 
            </summary>
            <param name="data">predefined element data array, will be used for new cell (no copy will be made)</param>
            <param name="size">size of the new cell</param>
            <remarks>object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)</remarks>
        </member>
        <member name="M:ILNumerics.ILInCell.#ctor(System.Int32[])">
            <summary>
            create new cell object, elements will be 'null' 
            </summary>
            <param name="size">dimension sizes of the new cell</param>
        </member>
        <member name="M:ILNumerics.ILInCell.op_Implicit(ILNumerics.ILRetCell)~ILNumerics.ILInCell">
            <summary>
            Convert temporary cell to input parameter type cell
            </summary>
            <param name="cell">Temporary cell</param>
            <returns>Input parameter type cell</returns>
        </member>
        <member name="M:ILNumerics.ILInCell.op_Implicit(ILNumerics.ILCell)~ILNumerics.ILInCell">
            <summary>
            Convert temporary cell to input parameter type cell
            </summary>
            <param name="cell">ILCell</param>
            <returns>Input parameter type cell</returns>
        </member>
        <member name="M:ILNumerics.ILInCell.op_Implicit(ILNumerics.ILOutCell)~ILNumerics.ILInCell">
            <summary>
            Convert output parameter type cell to input parameter type cell
            </summary>
            <param name="cell">Output parameter type cell</param>
            <returns>Input parameter type cell</returns>
        </member>
        <member name="P:ILNumerics.ILInCell.Item(System.Int32[])">
            <summary>
            Return single element in a scalar cell 
            </summary> 
            <paramref name="indices" value="Index to element"/>
            <remarks>
            <para>The indexer retrieves a single element from within the cell. It returns the single element 
            in a new (scalar) cell. Use dereferencing functions like GetArray&lt;T>() in order to retrieve 
            the element value (ie. the array addressed) without a cell container.</para>
            <para>Input parameter type cells are immutable! They are not intended to be altered! Therefore, 
            write access on such cells is disabled. In order to alter content of a cell, assign the cell to a regular
            persistent cell of type <see cref="T:ILNumerics.ILCell"/>.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILInCell.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access. Get regular subarray. 
            </summary>
            <param name="indices">Address range</param>
            <returns>Cell array with subcell range from this instance, addressed by <c>indices</c> </returns>
            <remarks>
            <para>The indexer is used to query subcell ranges. All general indexing/ subarray addressing rules apply.
            The elements addressed are returned within a new temporary cell instance.</para>
            <para>Input parameter type cells are immutable! They are not intended to be altered! Therefore, 
            write access on such cells is disabled. In order to alter content of a cell, assign the cell to a regular
            persistent cell of type <see cref="T:ILNumerics.ILCell"/>.</para></remarks>
        </member>
        <member name="T:ILNumerics.ILInLogical">
            <summary>
            Boolean array for high performance relational operations on arbitrary arrays 
            </summary>
            <remarks>
            Logical arrays are derived from <![CDATA[ILArray<byte>]]>. It consumes
            1 byte per element and is the output parameter of all relational comparisons
            as well as the input parameter for all functions consuming <![CDATA[ILArray<byte>]]>.
            The difference between <![CDATA[ILArray<byte>]]> and logical arrays is, the logical array 
            storing a integer value with the number of nonzero elements as additional information. 
            Therefore functions like 'find' are able to determine the lenght of output array to 
            be created omitting the need of multiple walks through the array. Therefore ILLogicalArrays 
            consume (a little) more time while construction but are much more performand on functions like 
            'find'.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILInLogical.#ctor(System.Int32[])">
            <summary>
            constructor - create logical array of specified size
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <remarks>
            The size parameter may not be null or an empty array! An exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILInLogical.#ctor(ILNumerics.ILSize)">
            <summary>
            constructor - create logical array of specified size
            </summary>
            <param name="size">
            dimension object
            </param>
            <remarks>
            The size parameter may not be null. An exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing singleton dimensions). 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILInLogical.#ctor(ILNumerics.Storage.ILLogicalStorage)">
            <summary>
            Constructor creating logical array from dense storage
            </summary>
            <param name="A">input array, the storage of this ILArray will directly be used for 
            storage of the new logical array</param>
        </member>
        <member name="M:ILNumerics.ILInLogical.#ctor(ILNumerics.Storage.ILLogicalStorage,System.Int64)">
            <summary>
            Constructor creating logical array from (dense) storage
            </summary>
            <param name="A">input array storage, the storage will directly be used for 
            storage of the new logical array</param>
            <param name="numberNonZero">number of nonzero elements in A. Must be positive or 0.</param>
            <remarks> Providing this parameter prevents the constructor from having to count the 
            'true' elements in A.</remarks>
        </member>
        <member name="M:ILNumerics.ILInLogical.#ctor(System.Byte[],System.Int32[])">
            <summary>
            constructor - create logical array of specified size 
            from data array
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <param name="data"> byte array matching the size of the dimensions 
            specified. The data will directly be used as storage! No copy will be made!</param>
            <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILInLogical.#ctor(System.Byte[],ILNumerics.ILSize)">
            <summary>
            Constructor creating logical array, provide predefined storage
            </summary>
            <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="dimension">Dimensions specification.</param>
        </member>
        <member name="M:ILNumerics.ILInLogical.#ctor(System.Byte[],ILNumerics.ILSize,System.Int64)">
            <summary>
            Constructor creating logical array, predefined storage (fast version)
            </summary>
            <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="dimension">Dimensions specification.</param>
            <param name="nonZeroCount">number of nonzero elements in <paramref name="data"/>. 
            Providing this parameter prevents from counting the 'true' elements (again). </param>
        </member>
        <member name="M:ILNumerics.ILInLogical.op_LogicalNot(ILNumerics.ILInLogical)">
            <summary>
            Invert values of array elements 
            </summary>
            <param name="A">Input array</param>
            <returns>New logical array, having the element values of A inverted</returns>
        </member>
        <member name="M:ILNumerics.ILInLogical.op_Implicit(ILNumerics.ILInLogical)~System.Boolean">
            <summary>
            Implicitly convert logical array to bool
            </summary>
            <param name="A">logical array</param>
            <returns>true if <b>all</b> elements of A are non-zero, false otherwise 
            </returns>
            <remarks>If A is null or empty, the function returns false. Otherwise allall returns true, 
            if all elements of A are non-zero and returns false, if A contains any zero elements.</remarks>
        </member>
        <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Boolean)~ILNumerics.ILInLogical">
            <summary>
            Implicitly convert scalar byte to logical array of size 1x1 (scalar).
            </summary>
            <param name="val">Byte scalar</param>
            <returns>New logical array of size 1x1 holding the only element of type <c>byte</c>
            with value of val.</returns>
        </member>
        <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Int32)~ILNumerics.ILInLogical">
            <summary>
            Implicitly convert integer scalar to logical array of size 1x1 (scalar).
            </summary>
            <param name="val">Scalar value</param>
            <returns>New logical array of size 1x1 holding the only element of type Byte 
            with value of val.</returns>
        </member>
        <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Byte[])~ILNumerics.ILInLogical">
            <summary>
            implicitly cast one dimensional System.Array to ILNumerics array (vector)
            </summary>
            <param name="A">1 dimensional system array, arbitrary type</param>
            <returns>ILNumerics array of same element type as elements of A. 
            Row vector. If A is null: empty array.</returns>
            <remarks>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion!</remarks>
        </member>
        <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Array)~ILNumerics.ILInLogical">
            <summary>
            Implicitly convert n-dim. System.Array to ILNumerics array
            </summary>
            <param name="A">Arbitrarily sized System.Array</param>
            <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
            <remarks>The inner type of input array <paramref name="A"/> must match the requested type
            <typeparamref name="ElementType"/>. The resulting ILArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of output array (shallow copy).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILCastException">If type of input does not match 
            ElementType</exception>
        </member>
        <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Byte[0:,0:])~ILNumerics.ILInLogical">
            <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">2-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Byte[0:,0:,0:])~ILNumerics.ILInLogical">
            <summary>
            Implicitly cast three dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">3-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="P:ILNumerics.ILInLogical.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access (readonly)
            </summary>
            <param name="range">Range specification</param>
            <returns>Logical array with the elements specified by range</returns>
            <remarks>Query access: for N-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range.
            <para>The indexer may be used for querying any elements 
            in this array. <c>range</c> may contains index specifications for one ... to any 
            dimension. The array returned will have the size specified by range.</para>
            </remarks>
        </member>
        <member name="T:ILNumerics.ILLogical">
            <summary>
            Boolean array for high performance relational operations on arbitrary arrays 
            </summary>
            <remarks>
            Logical arrays are derived from <c><![CDATA[ILArray<byte>]]></c>. It consumes
            1 byte per element and is the output parameter of all relational comparisons
            as well as the input parameter for all functions consuming <c><![CDATA[ILArray<byte>]]></c>.
            The difference between arrays and logical arrays is: the logical array 
            stores a integer value with the number of nonzero elements as additional information. 
            Therefore functions like 'find' are able to determine the lenght of output array to 
            be created omitting the need of multiple walks through the array. Therefore ILLogicalArrays 
            consume (a little) more time while construction but are much more performand on functions like 
            'find'.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILLogical.#ctor(System.Int32[])">
            <summary>
            constructor - create logical array of type <c>Byte</c> of specified size
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an ILArray &lt; byte &gt; of the specified dimensions 
            will be created. The type of storage will be <c>bool</c>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILLogical.#ctor(ILNumerics.ILSize)">
            <summary>
            constructor - create logical array of type <c>Byte</c> of specified size
            </summary>
            <param name="size">
            dimension object
            </param>
            <remarks>
            The size parameter may not be null. An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing singleton dimensions). 
            Depending on the requested size an logical array of the specified dimensions 
            will be created. The element type is be <c>bool</c>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILLogical.#ctor(ILNumerics.Storage.ILLogicalStorage)">
            <summary>
            Constructor creating logical array from dense storage
            </summary>
            <param name="A">input array, the storage of this ILArray will directly be used for 
            storage of the new logical array</param>
        </member>
        <member name="M:ILNumerics.ILLogical.#ctor(ILNumerics.Storage.ILLogicalStorage,System.Int64)">
            <summary>
            Constructor creating logical array from (dense) storage
            </summary>
            <param name="A">input array, the storage of this ILArray will directly be used for 
            storage of the new logical array</param>
            <param name="numberNonZero">number of nonzero elements in A. Must be positive or 0.</param>
            <remarks> Providing this parameter prevents the constructor from having to count the 
            'true' elements in A.</remarks>
        </member>
        <member name="M:ILNumerics.ILLogical.#ctor(System.Byte[],System.Int32[])">
            <summary>
            constructor - create logical array of specified size 
            from data array
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <param name="data"> byte array matching the size of the dimensions 
            specified. The data will directly be used as storage! No copy will be made!</param>
            <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an logical array of the specified size 
            will be created. The type of storage will be <c>byte</c>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILLogical.#ctor(System.Byte[],ILNumerics.ILSize)">
            <summary>
            Constructor creating logical array, provide predefined storage
            </summary>
            <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="dimension">Dimensions specification.</param>
        </member>
        <member name="M:ILNumerics.ILLogical.#ctor(System.Byte[],ILNumerics.ILSize,System.Int64)">
            <summary>
            Constructor creating logical array, predefined storage (fast version)
            </summary>
            <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="dimension">Dimensions specification.</param>
            <param name="nonZeroCount">number of nonzero elements in <paramref name="data"/>. 
            Providing this parameter prevents from counting the 'true' elements (again). </param>
        </member>
        <member name="M:ILNumerics.ILLogical.op_Implicit(System.Boolean)~ILNumerics.ILLogical">
            <summary>
            Implicitly convert boolean scalar to logical array of size 1x1 (scalar).
            </summary>
            <param name="val">Boolean scalar</param>
            <returns>New logical array of size 1x1 holding the only element of type Byte 
            with value of val.</returns>
        </member>
        <member name="M:ILNumerics.ILLogical.op_Implicit(ILNumerics.ILLogical)~System.Boolean">
            <summary>
            Implicitly convert logical array to bool
            </summary>
            <param name="A">logical array</param>
            <returns>true if <b>all</b> elements of A are non-zero, false otherwise 
            </returns>
            <remarks> If A is null or empty, the function returns false. Otherwise allall returns true, 
            if all elements of A are non-zero and returns false, if A contains any zero elements.</remarks>
        </member>
        <member name="M:ILNumerics.ILLogical.op_Implicit(System.Int32)~ILNumerics.ILLogical">
            <summary>
            Implicitly convert integer scalar to logical array of size 1x1 (scalar).
            </summary>
            <param name="val">Scalar value</param>
            <returns>New logical array of size 1x1 holding the only element of type Byte 
            with value of val.</returns>
        </member>
        <member name="M:ILNumerics.ILLogical.op_Implicit(System.Byte[])~ILNumerics.ILLogical">
            <summary>
            Implicitly cast one dimensional System.Array to ILNumerics array (vector)
            </summary>
            <param name="A">1-dimensional system array, arbitrary type</param>
            <returns>ILNumerics array of same element type as elements of A. 
            Row vector. If A is null: empty array.</returns>
            <remarks>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion!</remarks>
        </member>
        <member name="M:ILNumerics.ILLogical.op_Implicit(System.Array)~ILNumerics.ILLogical">
            <summary>
            Implicitly convert n-dim. System.Array to ILNumerics array
            </summary>
            <param name="A">Arbitrarily sized System.Array</param>
            <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
            <remarks>The inner type of input array <paramref name="A"/> must match the requested type
            <typeparamref name="ElementType"/>. The resulting ILArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of output array (shallow copy).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILCastException"> if type of input does not match 
            ElementType</exception>
        </member>
        <member name="M:ILNumerics.ILLogical.op_Implicit(System.Byte[0:,0:])~ILNumerics.ILLogical">
            <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">2D System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILLogical.op_Implicit(System.Byte[0:,0:,0:])~ILNumerics.ILLogical">
            <summary>
            Implicitly cast three dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">3-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILLogical.op_LogicalNot(ILNumerics.ILLogical)">
            <summary>
            Invert values of array elements 
            </summary>
            <param name="in1">Input array</param>
            <returns>New solid logical array, inverted element values</returns>
        </member>
        <member name="M:ILNumerics.ILLogical.SetValue(System.Byte,System.Int32[])">
            <summary>
            Set single value to element at index specified
            </summary>
            <param name="value">New value</param>
            <param name="idx">Index of element to be altered</param>
        </member>
        <member name="M:ILNumerics.ILLogical.SetRange(ILNumerics.ILInLogical,ILNumerics.ILBaseArray[])">
            <summary>
            Alter a range of this array
            </summary>
            <param name="value">Array with new values</param>
            <param name="range">Range specification</param>
        </member>
        <member name="M:ILNumerics.ILLogical.Assign(ILNumerics.ILRetLogical)">
            <summary>
            Replaces storage of this array with new array elements, registers this array for out-of-scope disposal
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="M:ILNumerics.ILLogical.GetArrayForWrite">
            <summary>
            Direct reference to inner System.Array storage for write access - use with care!
            </summary>
            <returns>Reference to inner System.Array</returns>
            <remarks>Altering this array can be done directly. If necessary, the array is detached before 
            returned. Watch the column order format of storages in ILNumerics. Keep in mind, the length 
            of the System.Array may exceed the number of elements of the ILNumerics array.
            <para>Accessing the inner system array directly should be left to ILNumerics experts only. 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T>!</para>
            <para>Unlike (almost) all other member function of an array, this function
            does not keep track of internal memory management. It means, the storage which this array is based 
            upon, will not be set free after the function returns. You (as the user of the array) will have to pay 
            attention yourself, when to call dispose on the array - if necessary. Also, for elements of reference
            types (e.g. ILCell), retrieving and storing elements from/into the System.Array directly does 
            not simulate a value semantic as all other functions do! This means, references are copied. Attention
            must be paid to dereference / clone elements accordingly. </para></remarks>
        </member>
        <member name="P:ILNumerics.ILLogical.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access
            </summary>
            <param name="range">Range specification</param>
            <returns>Reference pointing to the elements of this array specified by range. If used for removal: 
            the array will be changed to a referencing array having the parts requested removed and reshaped accordingly.</returns>
            <remarks>Query access: for N-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range.
            <para>The indexer may be used for querying or altering single/any elements 
            in this array. <c>range</c> may contains index specifications for one ... any 
            dimension. The array returned will have the size specified by range.</para>
            <para>The indexer may also be used for removing parts of the array. Therefore an empty array 
            (of the same type) or 'null' must be assigned to the range specified by <c>range</c> using the set-access. <c>range</c> 
            must contain exactly one dimension specification other than null. This may be any vector-sized numeric ILArray of any 
            type. If <c>range</c> applies 
            to less dimensions than dimensions existing in the array, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.</para>
            <para>In case of removal the ILArray returned will be a reference array.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILLogical.a">
            <summary>
            Replace the elements of this array with another array's elements, preventing memory leaks
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="T:ILNumerics.ILOutArray`1">
            <summary>
            Rectangular array, used as output parameter only 
            </summary>
            <typeparam name="ElementType">Inner type. This will mostly be a system numeric type or a 
            complex floating point type.</typeparam>
            <remarks><para>This class extends the primary <c>ILArray</c> by optimizing its behavior for the case when used as an
            output parameter of functions.</para><para>When writing your own function all <i>output</i> parameters should be of type <c>ILOutArray</c>. Do not
            use <c>out ILArray</c>! Similary, all return types should be of type <see cref="T:ILNumerics.ILRetArray`1"/> and all input parameters of type <see cref="T:ILNumerics.ILInArray`1"/>.</para>
            <para>Other than being used to retrieve results from functions, <c>ILOutArray</c> should not be used.</para>
            </remarks>
            <seealso cref="T:ILNumerics.ILArray`1"/>
            <seealso cref="T:ILNumerics.ILRetArray`1"/>
            <seealso cref="T:ILNumerics.ILInArray`1"/>
        </member>
        <member name="M:ILNumerics.ILOutArray`1.#ctor(ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Create new output parameter array
            </summary>
            <param name="storage">Dense storage for the new array</param>
        </member>
        <member name="M:ILNumerics.ILOutArray`1.op_Implicit(ILNumerics.ILArray{`0})~ILNumerics.ILOutArray{`0}">
            <summary>
            Creates an output parameter type array from regular array
            </summary>
            <param name="A">Original array</param>
            <returns>Output parameter type array, references the original array</returns>
        </member>
        <member name="M:ILNumerics.ILOutArray`1.Assign(ILNumerics.ILRetArray{`0})">
            <summary>
            Replaces storage of this array with new array elements, registers this array for out-of-scope disposal
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="M:ILNumerics.ILOutArray`1.GetArrayForWrite">
            <summary>
            Direct reference to inner System.Array storage for write access - use with care!
            </summary>
            <returns>Reference to inner System.Array</returns>
            <remarks>Altering this array can be done directly. If necessary, the array is detached before 
            returned. Watch the column order format of storages in ILNumerics. Keep in mind, the length 
            of the System.Array may exceed the number of elements of the ILNumerics array.
            <para>Accessing the inner system array directly should be left to ILNumerics experts only. 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T>!</para>
            <para>For elements of reference types (e.g. ILCell), retrieving and storing elements from/into the System.Array directly 
            obviously does not simulate a value semantic as all other common API methods do! This means, references are copied. Attention
            must be paid to dereference / clone elements accordingly or (recommended) prevent from using this 
            function with reference element types.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILOutArray`1.SetValue(`0,System.Int32[])">
            <summary>
            Set single value to element at index specified
            </summary>
            <param name="value">New value</param>
            <param name="idx">Index of element to be altered</param>
        </member>
        <member name="M:ILNumerics.ILOutArray`1.SetRange(ILNumerics.ILInArray{`0},ILNumerics.ILBaseArray[])">
            <summary>
            Alter range of this array
            </summary>
            <param name="value">Array with new values</param>
            <param name="range">Range specification</param>
        </member>
        <member name="P:ILNumerics.ILOutArray`1.a">
            <summary>
            Replace the elements of this array with another array's elements, preventing memory leaks
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="P:ILNumerics.ILOutArray`1.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray creation/manipulation/deletion
            </summary>
            <param name="range">Range specification, defining the size of the subarray</param>
            <returns>Subarray as copy of this array</returns>
        </member>
        <member name="T:ILNumerics.ILOutLogical">
            <summary>
            Boolean array for high performance relational operations on arbitrary arrays 
            </summary>
            <remarks>
            Logical arrays store true/false conditions as elements. Each element consumes
            one byte. Logical arrays are the output parameter of all relational comparisons.</remarks>
        </member>
        <member name="M:ILNumerics.ILOutLogical.#ctor(System.Int32[])">
            <summary>
            Constructor - create logical array of type <c>Byte</c> of specified size
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an ILArray &lt; byte &gt; of the specified dimensions 
            will be created. The type of storage will be <c>bool</c>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILOutLogical.#ctor(ILNumerics.ILSize)">
            <summary>
            Constructor - create logical array of type <c>byte</c> of specified size
            </summary>
            <param name="size">
            Size descriptor
            </param>
            <remarks>
            The size parameter may not be null. An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing singleton dimensions). 
            Depending on the requested size an logical array of the specified dimensions 
            will be created. The element type is be <c>bool</c>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILOutLogical.#ctor(ILNumerics.Storage.ILLogicalStorage)">
            <summary>
            Constructor creating logical array from dense storage
            </summary>
            <param name="A">Input array, the storage of this ILArray will directly be used for 
            storage of the new logical array</param>
        </member>
        <member name="M:ILNumerics.ILOutLogical.#ctor(ILNumerics.Storage.ILLogicalStorage,System.Int64)">
            <summary>
            Constructor creating logical array from (dense) storage
            </summary>
            <param name="A">Input array, the storage of this ILArray will directly be used for 
            storage of the new logical array</param>
            <param name="numberNonZero">Number of nonzero elements in A. Must be positive or 0.</param>
            <remarks>Providing this parameter prevents the constructor from having to count the 
            'true' elements in A.</remarks>
        </member>
        <member name="M:ILNumerics.ILOutLogical.#ctor(System.Byte[],System.Int32[])">
            <summary>
            Constructor - create logical array of specified size from data array
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <param name="data">byte array matching the size of the dimensions 
            specified. The data will directly be used as storage! No copy will be made!</param>
            <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an logical array of the specified size 
            will be created. The type of storage will be <c>byte</c>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILOutLogical.#ctor(System.Byte[],ILNumerics.ILSize)">
            <summary>
            Constructor creating logical array, provide predefined storage
            </summary>
            <param name="data">Predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="size">Dimensions specification.</param>
        </member>
        <member name="M:ILNumerics.ILOutLogical.#ctor(System.Byte[],ILNumerics.ILSize,System.Int64)">
            <summary>
            Constructor creating logical array, predefined storage (fast version)
            </summary>
            <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="size">Dimensions specification.</param>
            <param name="nonZeroCount">number of nonzero elements in <paramref name="data"/>. 
            Providing this parameter prevents from counting the 'true' elements (again). </param>
        </member>
        <member name="M:ILNumerics.ILOutLogical.op_Implicit(ILNumerics.ILLogical)~ILNumerics.ILOutLogical">
            <summary>
            Convert logical array to output parameter type array
            </summary>
            <param name="A">Source logical array</param>
            <returns>Output parameter type array</returns>
        </member>
        <member name="M:ILNumerics.ILOutLogical.SetValue(System.Byte,System.Int32[])">
            <summary>
            Set single value to element at index specified
            </summary>
            <param name="value">New value</param>
            <param name="idx">Index of element to be altered</param>
        </member>
        <member name="M:ILNumerics.ILOutLogical.SetRange(ILNumerics.ILInLogical,ILNumerics.ILBaseArray[])">
            <summary>
            Alter a range of this array
            </summary>
            <param name="value">Array with new values</param>
            <param name="range">Range specification</param>
        </member>
        <member name="M:ILNumerics.ILOutLogical.Assign(ILNumerics.ILRetLogical)">
            <summary>
            Replaces storage of this array with new array elements, registers this array for out-of-scope disposal
            </summary>
            <param name="value">new array</param>
        </member>
        <member name="M:ILNumerics.ILOutLogical.GetArrayForWrite">
            <summary>
            Direct reference to inner System.Array storage for write access - use with care!
            </summary>
            <returns>Reference to inner System.Array</returns>
            <remarks>Altering this array can be done directly. If necessary, the array is detached before 
            returned. Watch the column order format of storages in ILNumerics. Keep in mind, the length 
            of the System.Array may exceed the number of elements of the ILNumerics array.
            <para>Accessing the inner system array directly should be left to ILNumerics experts only. 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T>!</para>
            <para>Unlike (almost) all other member function of an array, this function
            does not keep track of internal memory management. It means, the storage which this array is based 
            upon, will not be set free after the function returns. You (as the user of the array) will have to pay 
            attention yourself, when to call dispose on the array - if necessary. Also, for elements of reference
            types (e.g. ILCell), retrieving and storing elements from/into the System.Array directly does 
            not simulate a value semantic as all other functions do! This means, references are copied. Attention
            must be paid to dereference / clone elements accordingly. </para></remarks>
        </member>
        <member name="P:ILNumerics.ILOutLogical.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access
            </summary>
            <param name="range">Range specification</param>
            <returns>Reference pointing to the elements of this array specified by range. If used for removal: 
            the array will be changed to a referencing array having the parts requested removed and reshaped accordingly.</returns>
            <remarks>Query access: for N-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range.
            <para>The indexer may be used for querying or altering single/any elements 
            in this array. <c>range</c> may contains index specifications for one ... any 
            dimension. The array returned will have the size specified by range.</para>
            <para>The indexer may also be used for removing parts of the array. Therefore an empty array 
            (of the same type) or 'null' must be assigned to the range specified by <c>range</c> using the set-access. <c>range</c> 
            must contain exactly one dimension specification other than null. This may be any vector-sized numeric ILArray of any 
            type. If <c>range</c> applies 
            to less dimensions than dimensions existing in the array, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.</para>
            <para>In case of removal the ILArray returned will be a reference array.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILOutLogical.a">
            <summary>
            Replace the elements of this array with another array's elements, preventing memory leaks
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="T:ILNumerics.ILRetArray`1">
            <summary>
            N-dimensional, generic array class, temporary variant, is disposed after first use
            </summary>
            <typeparam name="ElementType">Inner element type</typeparam>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(`0)~ILNumerics.ILRetArray{`0}">
            <summary>
            Implicitly convert scalar to array of size 1x1 (scalar).
            </summary>
            <param name="val">Single element of ElementType type</param>
            <returns>New array of of size 1x1 holding the only element with value of val.
            </returns>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(`0[])~ILNumerics.ILRetArray{`0}">
            <summary>
            Implicitly cast one dimensional System.Array to ILNumerics array (vector)
            </summary>
            <param name="A">1-dimensional system array, arbitrary type</param>
            <returns>ILNumerics array of same element type as elements of A. 
            Row vector. If A is null: empty array.</returns>
            <remarks>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion!</remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(System.Array)~ILNumerics.ILRetArray{`0}">
            <summary>
            Implicitly convert n-dim. System.Array to ILNumerics array
            </summary>
            <param name="A">Arbitrarily sized System.Array</param>
            <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
            <remarks>The inner type of input array <paramref name="A"/> must match the requested type
            <typeparamref name="ElementType"/>. The resulting ILArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of output array (shallow copy).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILCastException">If type of input does not match 
            ElementType</exception>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(`0[0:,0:])~ILNumerics.ILRetArray{`0}">
            <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">2-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(`0[0:,0:,0:])~ILNumerics.ILRetArray{`0}">
            <summary>
            Implicitly cast three dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">3-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(ILNumerics.ILRetArray{`0})~ILNumerics.ILRetCell">
            <summary>
            Convert array to temporary cell 
            </summary>
            <param name="A">Source array</param>
            <returns>Temporary scalar cell, having the only element with a clone of A</returns>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(ILNumerics.ILArray{`0})~ILNumerics.ILRetArray{`0}">
            <summary>
            'Clone' conversion
            </summary>
            <param name="A">Source array</param>
            <returns>Temporary ILArray, will be disposed after next operation</returns>
            <remarks>This conversion is for convenient reasons only. It enables the direct 
            use of (persistent) ILArray objects in situations where (temporary) ILRetArray 
            is required. A (fast) clone will be made. This is an alias for A.C.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(ILNumerics.ILInArray{`0})~ILNumerics.ILRetArray{`0}">
            <summary>
            'Clone' conversion
            </summary>
            <param name="A">Source array</param>
            <returns>Temporary ILArray, will be disposed after next operation</returns>
            <remarks>This conversion is for convenient reasons only. It enables the direct 
            use of (persistent) ILArray objects in situations where (temporary) ILRetArray 
            is required. One example is the conversion of ILArray as return type. 
            A (fast) clone will be made. This is an alias for A.C.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(ILNumerics.ILOutArray{`0})~ILNumerics.ILRetArray{`0}">
            <summary>
            'Clone' conversion
            </summary>
            <param name="A">Source array</param>
            <returns>temporary ILArray, will be disposed after next operation</returns>
            <remarks>This conversion is for convenient reasons only. It enables the direct 
            use of (persistent) ILArray objects in situations where (temporary) ILRetArray 
            is required. One example is the conversion of ILArray as return type. 
            A (fast) clone will be made. This is an alias for A.C.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.Clone">
            <summary>
            Clone of this array
            </summary>
            <remarks><para>
            Clones of all arrays in ILNumerics are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays 
            on write access.</para>
            <para>The clone returned will be of the same type as this instance.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.Concat(ILNumerics.ILInArray{`0},System.Int32)">
            <summary>
            Concatenate this array 
            </summary>
            <param name="A">n-dimensional storage</param>
            <param name="dim">Dimension index along which to concatenate the arrays.</param>
            <returns>New array with copy elements of this array and A</returns>
            <remarks>The array returned will be a copy of both arrays involved. None 
            of the input arrays will be altered. If <paramref name="dim"/> is larger than 
            the number of dimensions of one of the arrays its value will be used in modulus. 
            <para>The resulting array has the size of both input arrays, laid beside one 
            another along the <paramref name="dim"/> dimension.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.Equals(System.Object)">
            <summary>
            Compare elements and shape of this array with another array
            </summary>
            <param name="A">Other array</param>
            <returns>true if shape and element values of both arrays match, false otherwise</returns>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.ExportValues(`0[]@)">
            <summary>
            Copy values of all elements into System.Array.
            </summary>
            <param name="outArray">[Output] System.Array, holding all element values of this ILDenseStorage.</param>
            <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            its leading elements will be overwritten when function returns. If 'outArray' is null or has too few elements, 
            it will be recreated from the ILNumerics memory pool.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.GetEnumerator">
            <summary>
            Enumerator returning elements as ElementType
            </summary>
            <returns>Enumerator</returns>
            <remarks>This method enables the use of ILNumerics arrays in foreach loops.
            <para>The iterator is returned, if arrays are directly used in foreach statements. The iterator 
            is compatible with ILNumerics memory management.</para></remarks>
            <example><code>ILArray&lt;double&gt; A = rand(5,4,6);
            foreach (double element in A) {
                // all elements are scalar double values
                String.Format("Element: {0} ", element);
                // Note: 'element' cannot be used to alter the collection! 
            } </code>
            </example> 
        </member>
        <member name="M:ILNumerics.ILRetArray`1.GetHashCode">
            <summary>
            Generate a hash code based on the current arrays values
            </summary>
            <returns>Hash code</returns>
            <remarks>The hashcode is generated by taking the values currently stored in the array into account.
            Therefore, the function must iterate over all elements in the array - which makes it somehow a costly 
            operation. Take this into account, if you consider using large arrays in collections like dictionaries 
            or hashtables, which make great use of hash codes.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.GetLimits(`0@,`0@)">
            <summary>
            Get minimum and maximum value of all elements - if any
            </summary>
            <param name="min">[Output] Minimum value</param>
            <param name="max">[Output] Maximum value</param>
            <returns>true if the limits exists and could be computed, false otherwise</returns>
            <remarks>Empty arrays will return false. In this case the output parameter will be: default(ElementType).
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.GetValue(System.Int32[])">
            <summary>
            Get single element from this array
            </summary>
            <param name="idx">Indices, location of element</param>
            <returns>The requested element</returns>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.Repmat(System.Int32[])">
            <summary>
            Create replication of this array
            </summary>
            <param name="dims">Dimensions specifier. If the number of elements in <paramref name="dims"/> is 
            less than the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
            <returns>Array being created by multiple replications of this array along 
            arbitrary dimensions according to <paramref name="dims"/></returns>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.Reshape(ILNumerics.ILSize)">
            <summary>
            Reshaped copy of this array
            </summary>
            <param name="dimensions">New dimensions of the array</param>
            <returns>Reshaped copy of the array</returns>
            <remarks><para>The current instance will not be changed. A new storage is created, having 
            the elements of this array and a shape as determined by <paramref name="dimensions"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in <paramref name="dimensions"/>
            do not match the number of elements in this array.</exception>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.Serialize(System.IO.Stream)">
            <summary>
             Serialize this ILArray into a binary stream.
            </summary>
            <param name="outStream">System.IO.Stream to receive the byte stream 
            for this ILBaseArray</param>
            <returns>True on success, false on error.</returns>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.Shifted(System.Int32)">
            <summary>
            Create array from this array and shift dimensions
            </summary>
            <param name="shift">Number of dimensions to shift</param>
            <returns>Shifted version of this array</returns>
            <remarks><para>The shift is done 'to the left':</para>
            <example><code>ILArray&lt;double&gt; A = zeros(2,4);
            ILArray&lt;double&gt; B = A.Shifted(1);
            // B is now: &lt;double&gt; [4,2]
            
            ILArray&lt;double&gt; C = zeros(2,4,3);
            ILArray&lt;double&gt; D = C.Shifted(1); 
            // D is now: &lt;double&gt; [4,3,2] 
            </code></example>
            <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style.</para>
            <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T"/> property for readability.</para>
            <para><paramref name="shift"/> must be positive. It is taken modulus the number of dimensions.</para>
            <seealso cref="P:ILNumerics.ILDenseArray`1.T"/></remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray creation
            </summary>
            <param name="size">Range specification, defining the size of the subarray</param>
            <returns>Subarray as copy of a part of this array</returns>
            <remarks>Consult the ILNumerics subarray documentation for all subarray indexing rules.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
            <summary>
            Send values of this instance to stream. 
            </summary>
            <param name="stream">Stream to write the values into.</param>
            <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)"/> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
            <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags"/>. Specifies the way in which
            the values will be serialized.</param>
            <remarks><para>If the 'Formatted' method is used, any occurences of the NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style of the output.</para>
            <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as the
            array name for writing. This array instance will be the only array in the .mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.C">
            <summary>
            Clone of this array (fast, cheap and shallow)
            </summary>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.S">
            <summary>
            Size descriptor shortcut
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.Size">
            <summary>
            Size descriptor 
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.IsColumnVector">
            <summary>
            Test if this array instance is a column vector
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.IsRowVector">
            <summary>
            Test if this array instance is a row vector
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.IsComplex">
            <summary>
            Determine if this array has complex elements.
            </summary>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.IsEmpty">
            <summary>
            Test if this instance is an empty array (number of elements stored = 0)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.IsMatrix">
            <summary>
            Test if this instance is a matrix
            </summary>
            <remarks>In order for an array to be a matrix the number of <b>non singleton</b> 
            dimensions must equal 2. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.IsNumeric">
            <summary>
            Determine if this array holds numeric values.
            </summary>
            <remarks>An ILArray is numeric as long as its elements are one of the 
            following types: 
            <list type="table">
            <listheader>
                <term>inner type</term>
            </listheader>
            <item>
                <term>System.double</term>
                <description>floating point, real, 8 bytes </description>
            </item>
            <item>
                <term>System.float</term>
                <description>floating point real, 4 bytes</description>
            </item>
            <item>
                <term>ILNumerics.complex</term>
                <description>floating point complex, 16 bytes</description>
            </item>
            <item>
                <term>ILNumerics.fcomplex</term>
                <description>floating point complex, 8 bytes</description>
            </item>
            <item>
                <term>System.char</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.byte</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.Int16</term>
                <description>integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.Int32</term>
                <description>integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.Int64</term>
                <description>integer, real, 8 byte</description>
            </item>
            <item>
                <term>System.UInt16</term>
                <description>unsigned integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.UInt32</term>
                <description>unsigned integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.UInt64</term>
                <description>unsigned integer, real, 8 byte</description>
            </item>
            </list>
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.IsScalar">
            <summary>
            Test if this instance is a scalar
            </summary>
            <remarks>This attribute is readonly. It returns: Size.NumberOfElements == 1.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.IsVector">
            <summary>
            Test if this array is a vector
            </summary>
            <remarks>In order for an array to be a vector the number of <b>non singleton</b> 
            dimensions must equal 1. Keep in mind that all ILArrays have at least 2 dimensions. Therefore 
            it is not sufficient to test for the number of dimensions, but to take the number of 
            <b>non singleton</b> dimensions into account. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.Length">
            <summary>
            Length of the longest dimension of this instance
            </summary>
            <remarks>This property is readonly.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.T">
            <summary>
            Return transposed version of this array
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.Name">
            <summary>
            Gets the name of this array (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray creation
            </summary>
            <param name="range">Range specification, defining the size of the subarray</param>
            <returns>Subarray as copy of a part of this array</returns>
            <remarks>Consult the ILNumerics subarray documentation for all subarray indexing rules.</remarks>
        </member>
        <member name="T:ILNumerics.ILRetCell">
            <summary>
            Mathematical container class holding arbitrary array objects as elements 
            </summary>
            <remarks>
            Cells act as general purpose container. Cells store arbitrary arrays of arbitrary element type. 
            Theses elements commonly are cells itself. <c>ILRetCell</c> acts as return type 
            in function declarations when a cell needs to be returned from a function. 
            Use <see cref="T:ILNumerics.ILCell"/> for local cell variables in your algorithms. 
            <para>More details about cells are found in the <a href="http://ilnumerics.net/$Cells.html">online manual</a>.</para>
            </remarks>
            <seealso cref="T:ILNumerics.ILCell"/>
        </member>
        <member name="M:ILNumerics.ILRetCell.#ctor(ILNumerics.Storage.ILStorage[],System.Int32[])">
            <summary>
            Create cell object with pre-created data in specified dimensions 
            </summary>
            <param name="data">Predefined element data array, will be used for new cell (no copy will be made)</param>
            <param name="size">Size of the new cell</param>
            <remarks>Object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)</remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.#ctor(ILNumerics.Storage.ILStorage[],ILNumerics.ILSize)">
            <summary>
            Create cell object with pre-created data in specified dimensions 
            </summary>
            <param name="data">Predefined element data array, will be used for new cell (no copy will be made)</param>
            <param name="size">Size of the new cell</param>
            <remarks>Object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)</remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.#ctor(System.Int32[])">
            <summary>
            Create new cell object, elements will be 'null' 
            </summary>
            <param name="size">Size descriptor of the new cell</param>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(System.Int32)~ILNumerics.ILRetCell">
            <summary>
            Convert primitive integer to a scalar temporary cell
            </summary>
            <param name="value">Primitive scalar int value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(System.Double)~ILNumerics.ILRetCell">
            <summary>
            Convert primitive double to a scalar temporary cell
            </summary>
            <param name="value">Primitive scalar double value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(System.Single)~ILNumerics.ILRetCell">
            <summary>
            Convert primitive float to a scalar temporary cell
            </summary>
            <param name="value">Primitive scalar float value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(System.Byte)~ILNumerics.ILRetCell">
            <summary>
            Convert primitive byte to a scalar temporary cell
            </summary>
            <param name="value">Primitive byte int value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(System.Int32[])~ILNumerics.ILRetCell">
            <summary>
            Encapsulate integer System.Array into a scalar temporary cell
            </summary>
            <param name="value">Primitive System.Int32 value - no copy will be made!</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(System.String)~ILNumerics.ILRetCell">
            <summary>
            Convert string to a scalar temporary cell
            </summary>
            <param name="value">String value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(System.String[])~ILNumerics.ILRetCell">
            <summary>
            Encapsulate array of strings into a scalar temporary cell
            </summary>
            <param name="value">String array - no copy will be made!</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(ILNumerics.ILCell)~ILNumerics.ILRetCell">
            <summary>
            Convert cell to temporary cell
            </summary>
            <param name="A">Cell</param>
            <returns>Temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(ILNumerics.ILInCell)~ILNumerics.ILRetCell">
            <summary>
            Convert input parameter cell to temporary cell
            </summary>
            <param name="A">Input parameter cell</param>
            <returns>Temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(ILNumerics.ILOutCell)~ILNumerics.ILRetCell">
            <summary>
            Convert output parameter cell to temporary cell
            </summary>
            <param name="A">Output parameter cell</param>
            <returns>Temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(ILNumerics.ILBaseLogical)~ILNumerics.ILRetCell">
            <summary>
            Wrap single logical array into a new scalar temporary cell
            </summary>
            <param name="A">Logical array</param>
            <returns>Scalar cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.Clone">
            <summary>
            Clone of this array
            </summary>
            <remarks><para>
            Clones of all arrays in ILNumerics are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays 
            on write access.</para>
            <para>The clone returned will be of the same type as this instance.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.Concat(ILNumerics.ILInCell,System.Int32)">
            <summary>
            Concatenate this cell 
            </summary>
            <param name="A">Cell to concatenate this cell with</param>
            <param name="dim">Dimension index along which to concatenate the cells.</param>
            <returns>new cell with concatenation of all elements of both cells</returns>
            <remarks>The array returned will be a copy of both cells involved. 
            If <paramref name="dim"/> is larger than 
            the number of dimensions of one of the arrays its value will be used in modulus. 
            <para>The resulting cell has the size of both input cells, laid beside one 
            another along the <paramref name="dim"/> dimension.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.Equals(System.Object)">
            <summary>
            Compare elements and shape of this array with another array
            </summary>
            <param name="A">Other array</param>
            <returns>true if shape and element values of both arrays match, false otherwise</returns>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.ExportValues(ILNumerics.Storage.ILStorage[]@)">
            <summary>
            Copy values of all elements into System.Array.
            </summary>
            <param name="outArray">[Output] System.Array, holding all element values of this ILDenseStorage.</param>
            <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            its leading elements will be overwritten when function returns. If 'outArray' is null or has too few elements, 
            it will be recreated from the ILNumerics memory pool.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.GetArray``1(ILNumerics.ILBaseArray[])">
            <summary>
            Retrieve a single array of a known type from a cell position
            </summary>
            <typeparam name="T">Element type of the array</typeparam>
            <param name="indices">Position of the array within this cell</param>
            <returns>Lazy, shallow clone of the array found at the given position</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.GetBaseArray(ILNumerics.ILBaseArray[])">
            <summary>
            Retrieve a single element from the given position
            </summary>
            <param name="indices">Position of the element to retrieve, must evaluate to a scalar position</param>
            <returns>A clone of the scalar element found</returns>
            <remarks>
            <para>The method returns a lazy, shallow clone of the content of the cell element specified by <paramref name="indices"/>. 
            However, the return type (<code>ILBaseArray</code>) is not strongly typed and may contain <b>any</b> element. According to the 
            true element stored in the cell, this might be an array of arbitrary type, null or even another cell. Moreover, handling 
            <code>ILBaseArray</code> directly is not recommended for ILNumerics, since this would hinder the memory management from proper 
            functioning. Therefore: <b>The use of this method is not recommended and left to ILNumerics experts - for very 
            specific and rare situations.</b></para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.GetCell(ILNumerics.ILBaseArray[])">
            <summary>
            Retrieve a subcell of this cell
            </summary>
            <param name="indices">Subcell definition, arbitrary size</param>
            <returns>A cell with a lazy, shallow clone of the elements of this cell, addressed by <paramref name="indices"/></returns>
            <remarks>The cell returned will have the size and shape specified by <paramref name="indices"/>.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.GetEnumerator">
            <summary>
            Enumerator returning elements as scalar cells
            </summary>
            <returns>Enumerator</returns>
            <remarks>This method enables the use of cells in foreach loops.
            <para>The iterator is returned, if arrays are directly used in foreach statements. The iterator 
            is compatible with ILNumerics memory management.</para></remarks>
            <example><code>ILDenseStorage&lt;T&gt; A = ILMath.rand(5,4,6);
            foreach (double element in A) {
            // all elements are scalar double values
            String.Format("Element: {0} ",element);
            // Note: 'element' cannot be used to alter the collection! 
            } 
            </code></example> 
        </member>
        <member name="M:ILNumerics.ILRetCell.GetHashCode">
            <summary>
            Generate a hash code based on the current arrays values
            </summary>
            <returns>Hash code</returns>
            <remarks>The hashcode is generated by taking the values currently stored in the array into account.
            Therefore, the function must iterate over all elements in the array - which makes it somehow a costly 
            operation. Take this into account, if you consider using large arrays in collections like dictionaries 
            or hashtables, which make great use of hash codes.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.GetLimits(ILNumerics.Storage.ILStorage@,ILNumerics.Storage.ILStorage@)">
            <summary>
            Get minimum and maximum value of all elements - if any
            </summary>
            <param name="min">[Output] Minimum value</param>
            <param name="max">[Output] Maximum value</param>
            <returns>true if the limits exists and could be computed, false otherwise</returns>
            <remarks>Empty arrays will return false. In this case the output parameter will be: default(ElementType).
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.GetValue(System.Int32[])">
            <summary>
            Retrieve single element from this cell
            </summary>
            <param name="idx">Position of the element</param>
            <returns>Lazy, shallow clone of the element to retrieve or null, if there is no element at this place</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.GetValue``1(System.Int32[])">
            <summary>
            Retrieve a typed single element from within the cell, supports deep indexing
            </summary>
            <typeparam name="T">Expected type of the value to be returned</typeparam>
            <param name="indices">Location of the single element addressed</param>
            <returns>A clone of the single element addressed by <paramref name="indices"/></returns>
            <remarks>The element returned will have the type given by <typeparamref name="T"/>. It is an error to specify 
            a different type as the true type of the element specified. An exception is thrown if both types differ.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.IsTypeOf``1(ILNumerics.ILBaseArray[])">
            <summary>
            Test if an element of the cell is an array of the given element type
            </summary>
            <typeparam name="T">The array element type to check the cell element against</typeparam>
            <param name="position">Position of the cell element to be tested</param>
            <returns>true if the element found at the given position is an array of the element type <typeparamref name="T"/>, false otherwise</returns>
            <remarks>The method is helpful in order to investigate the contents of a cell array. If you are not sure about the 
            types of elements in the cell, this function can be used to make sure, elements are of the expected type before retrieving them as such.
            <para>In most situations, elements of a cell are stored arrays of a distinct element type. That element type is given to IsTypeOf as 
            typeparameter <typeparamref name="T"/>. That means, in order to find out, if the first cell element stores an array of int (<code>ILArray&lt;int></code>), 
            one may use <code>cell.IsTypeOf&lt;int>(0)</code></para>
            <para>In order to test, if a cell element is of type <code>ILCell</code>, one can provide the type <code>ILCell</code> as type parameter: 
            <code>cell.IsTypeOf&lt;ILCell>(0)</code>. Note the different semantic when checking for cell elements of type cell. Here we do not test for the 
            element type but for the array type itself, ie. <code>ILCell</code>. The reason of this is: the type of elements of <code>ILCell</code> is 
            an implementation detail and therefore hidden to the user.</para>
            </remarks>
            <example>
            <para>In the following example a ILCell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
            <code>ILCell cell = ILMath.cell(new ILSize(3, 2) 
                                 , "first element"
                                 , 2.0
                                 , ILMath.cell(Math.PI, 100f)
                                 , ILMath.create&lt;short>(1, 2, 3, 4, 5, 6)
                                 , new double[] {-1.4, -1.5, -1.6});
            </code>
            The cell is now: 
            <code>ILCell [3,2]
                     &lt;String>      first element  &lt;Int16> [2,3,4,5,6] 
                     &lt;Double>          2          ILCell [1,3]           
                     ILCell [2,1]                                    (null)	
            </code>
            We test the element type of every element in the cell: 
            <code>
            Console.Out.WriteLine("cell[0,0] is of type 'string': {0}", cell.IsTypeOf&lt;string>(0));
            Console.Out.WriteLine("cell[0,0] is of type 'double': {0}", cell.IsTypeOf&lt;double>(0));
                                                 
            Console.Out.WriteLine("cell[1,0] is of type 'double': {0}", cell.IsTypeOf&lt;double>(1));
            Console.Out.WriteLine("cell[2,0] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell>(2));
                                                                                    
            Console.Out.WriteLine("cell[0,1] is of type 'short': {0}", cell.IsTypeOf&lt;short>(0, 1));
            Console.Out.WriteLine("cell[1,1] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell>(1, 1));
            Console.Out.WriteLine("cell[2,1] is of type 'double': {0}", cell.IsTypeOf&lt;double>(2, 1));
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'ILCell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'ILCell': True
            cell[2,1] is element type 'double': False  // element is null, IsTypeOf&lt;> never gives true
            </code></example>
        </member>
        <member name="M:ILNumerics.ILRetCell.Repmat(System.Int32[])">
            <summary>
            Create replication of this cell
            </summary>
            <param name="dims">Dimensions specifier. If the number of elements in <paramref name="dims"/> is 
            less than the number of dimensions in this cell, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
            <returns>Array being created by multiple replications of this array along 
            arbitrary dimensions according to <paramref name="dims"/></returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.Reshape(ILNumerics.ILSize)">
            <summary>
            Create reshaped copy of this cell
            </summary>
            <param name="dimensions">New dimensions of the cell</param>
            <returns>Reshaped copy of the cell</returns>
            <remarks><para>The current instance will not be changed! A new cell is created, having 
            the elements of this cell and a shape as determined by <paramref name="dimensions"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="dimensions"/> do not match the number of elements in this cell.</exception>
        </member>
        <member name="M:ILNumerics.ILRetCell.Serialize(System.IO.Stream)">
            <summary>
             Serialize this ILArray into a binary stream.
            </summary>
            <param name="outStream">System.IO.Stream to receive the byte stream 
            for this ILBaseArray</param>
            <returns>True on success, false on error.</returns>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.Shifted(System.Int32)">
            <summary>
            Dimension shifted cell from this cell
            </summary>
            <param name="shift">Number of dimensions to shift</param>
            <returns>Shifted version of this cell</returns>
            <remarks><para>The shift is done 'to the left':</para>
            <example><code>ILCell A = cell(2,4); 
            ILCell B = A.Shifted(1);
            // B is now: ILCell [4,2] 
            
            ILCell C = cell(2,4,3);
            ILCell D = C.Shifted(1);
            // D is now: ILCell [4,3,2]
            </code></example>
            <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style. </para>
            <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T"/> property for readability.</para>
            <para><paramref name="shift"/> must be positive. It is taken modulus the number of dimensions.</para>
            <seealso cref="P:ILNumerics.ILDenseArray`1.T"/></remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access (readonly) 
            </summary>
            <param name="indices">Address range</param>
            <returns>Reference cell array with subarray addressed by <c>indices</c>. </returns>
            <remarks>Query access: for N-dimensional cell arrays missing trailing dimensions indices will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para>
            <para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements stored in the cell.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
            <summary>
            Send values of this instance to stream
            </summary>
            <param name="stream">Stream to write the values into.</param>
            <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)"/> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
            <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags"/>. Specifies the way in which
            the values will be serialized.</param>
            <remarks><para>If the 'Formatted' method is used, any occurences of the NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style of the output.</para>
            <para>Writing cells to *.mat files is NOT SUPPORTED yet! </para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.C">
            <summary>
            Clone of this cell
            </summary>
            <remarks><para>
            Clones of all arrays in ILNumerics are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays on write access.</para>
            <para>Cells profit from the same efficient clone creation process. However, since a cell may store an arbitrarily deep 
            hierarchy of other cells and arrays, in order to clone a cell, the cell elements have to be cloned as well - in an 
            recursive manner. Clones play an important role for ILNumerics cells. They are used to implement value semantics for cell
            elements. I.e.: the cloned cell returned cannot not be used to alter elements of the original cell in any way.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.S">
            <summary>
            Size descriptor shortcut
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetCell.Size">
            <summary>
            Size descriptor
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetCell.IsColumnVector">
            <summary>
            Test if this array instance is a column vector
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetCell.IsRowVector">
            <summary>
            Test if this array instance is a row vector
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetCell.IsComplex">
            <summary>
            Determine if this array has complex elements.
            </summary>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.IsEmpty">
            <summary>
            Test if this instance is an empty array (number of elements stored = 0)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetCell.IsMatrix">
            <summary>
            Test if this instance is a matrix
            </summary>
            <remarks>In order for an array to be a matrix the number of <b>non singleton</b> 
            dimensions must equal 2. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.IsNumeric">
            <summary>
            Determine if this array holds numeric values.
            </summary>
            <remarks>An ILArray is numeric as long as its elements are one of the 
            following types: 
            <list type="table">
            <listheader>
                <term>inner type</term>
            </listheader>
            <item>
                <term>System.double</term>
                <description>floating point, real, 8 bytes </description>
            </item>
            <item>
                <term>System.float</term>
                <description>floating point real, 4 bytes</description>
            </item>
            <item>
                <term>ILNumerics.complex</term>
                <description>floating point complex, 16 bytes</description>
            </item>
            <item>
                <term>ILNumerics.fcomplex</term>
                <description>floating point complex, 8 bytes</description>
            </item>
            <item>
                <term>System.char</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.byte</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.Int16</term>
                <description>integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.Int32</term>
                <description>integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.Int64</term>
                <description>integer, real, 8 byte</description>
            </item>
            <item>
                <term>System.UInt16</term>
                <description>unsigned integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.UInt32</term>
                <description>unsigned integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.UInt64</term>
                <description>unsigned integer, real, 8 byte</description>
            </item>
            </list>
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.IsScalar">
            <summary>
            Test if this instance is a scalar
            </summary>
            <remarks>This attribute is readonly. It returns: Dimension.NumberOfElements == 1.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.IsVector">
            <summary>
            Test if this array is a vector
            </summary>
            <remarks>In order for an array to be a vector the number of <b>non singleton</b> 
            dimensions must equal 1. Keep in mind that all ILArrays have at least 2 dimensions. Therefore 
            it is not sufficient to test for the number of dimensions, but to take the number of 
            <b>non singleton</b> dimensions into account. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.Length">
            <summary>
            Length of the longest dimension of this instance
            </summary>
            <remarks>This property is readonly.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.T">
            <summary>
            Transposed version of this ILCell
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetCell.Name">
            <summary>
            Gets the name of this array (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetCell.Storage">
            <summary>
            Access to the more specialized version (ILCellStorage) of this storage
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetCell.Item(System.Int32[])">
            <summary>
            Get/set/remove single element 
            </summary> 
            <paramref name="indices" value="Index to element"/>
            <value>Inner element, new inner element or null</value>
            <remarks>The type of access depends on the length of indices. If indices contains only one element, 
            the array will be accessed via sequential index access. This is sometimes called referred to as 'linear' 
            index addressing. 
            Sequential index access reflects the index of internal storage the way the data are actually organized 
            in memory. This access method is mainly convinient for vectors where you are not interested of orientation.
            The following example demonstrates sequential index access for ILArray's (which also holds for ILCells): 
            <example><code>
            ILArray&lt;double&gt; A = ILMath.counter(1,12);
            A[2] gives: 3.0
            </code>But the transpose 
            <code>
            A.T[2] gives also: 3.0
            </code> 
            For matrices and N-dimensional arrays this holds as well: 
            <code>
            ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,3,2,2);
            A = 
            [1.0 4.0
             2.0 5.0 
             3.0 6.0 
            
             7.0 10.0
             8.0 11.0
             9.0 12.0]
            
            A = ILMath.Reshape(A,3,2,2); 
            A[10] gives 11.0
            A[10,1] gives ILArgumentException -> out of range
            A[2,1,1] gives 12.0
            A[2,1] gives 6.0 (set trailing dimension to '0')</code></example>
            <para>If the element addressed is a ILCell itself, a deep reference to this element will be returned instead. 
            I.e. all elements of the ILCell will be recursively replaced with references to itself. Therefore, altering the 
            elements returned will not alter the elements contained in the cell.</para>
            <para>
            <list type="bullet">
            <listheader>The type of the element returned depends on the type of the element addressed:</listheader>
            <item>For ILArray&lt;ElementType&gt; the array returned will be a clone of the original array.</item> 
            <item>For ILCell the ILBaseArray returned is a deep reference of the original elements stored.</item>
            <item>For other types the behavior is undefined. (since other types are not implemented yet ;)</item>
            </list> </para>
            <para>This indexer may also be used for direct access to inner elements of (elements of elements of ...) this cell:
            <example>
            <code>
            ILCell innerCell = new ILCell(2,1); 
            innerCell[0] = ILMath.vec(10,200); 
            innerCell[1] = new int[] {-10,-20,-30};
            ILCell cell = new ILCell(2,1); 
            cell[0] = innerCell; 
            cell[1] = new string[] {"foobla"}; 
            // cell is now: 
            // [ILCell,(1x2)] 
            //      [innerCell[0], ILArray&lt;double&gt;(1x181)]
            //      [innerCell[0], ILArray&lt;double&gt;(1x3)]
            // [ILArray&lt;string&gt;,(1x1)]
            
            cell[0,0] -&gt; will give innerCell eq. ILCell (1x2)
            cell[0,1] -&gt; will give ILArray&lt;string&gt;
            cell[0,0,0,1] -&gt; will give innerCell[1] eq. ILArray&lt;int&gt;(1x3)
            </code>
            </example> 
            In the last example above the trailing indices specified make the indexer walk down into the ILCell element and retrieve 
            the content of this element. This kind of index access may be done as deep as you want. Just 
            append the inner indices into inner elements to the right side of index specification. Addressing inner elements 
            this way is the only way to alter elements <b>directly</b> inside the ILCell. </para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access. Get/set regular subarray. 
            </summary>
            <param name="indices">Address range</param>
            <returns>Reference cell array with subarray addressed by <c>indices</c>. </returns>
            <remarks>Query access: for N-dimensional cell arrays missing trailing dimensions indices will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para>
            <para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements.</para>
            <para>The indexer may also be used for removing parts of the cell. Therefore null must be assigned to the range specified by <c>indices</c> (using the set-access). <c>indices</c> 
            must contain exactly one dimension specification other than 'full' in this case. This may be any vector-sized numeric ILArray of any 
            numeric type. If <c>indices</c> apply to fewer dimensions than the number of dimensions existing, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.
            <example>
            <code>
            ILCell C = new ILCell(4,10); 
            C[":",2] = null;  // &gt;- will remove the third column (index: 2) from the cell.
            C[full,vec(2,5)] = null;  &gt;- will remove columns 3...6
            C[1,1] = null; &gt;- will produce an error. Only one dimension can be specified not full! 
            </code></example></para>
            <para>The general behavior of this access methods is full compatible with the corresponding Matlab/Octave/Scilab access: a(:) = []. </para>
            </remarks>
        </member>
        <member name="T:ILNumerics.ILRetLogical">
            <summary>
            Boolean array for high performance relational operations on arbitrary arrays 
            </summary>
            <remarks>
            Logical arrays store true/false conditions as elements. Each element consumes
            one byte. Logical arrays are the output parameter of all relational comparisons.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.#ctor(ILNumerics.Storage.ILLogicalStorage)">
            <summary>
            Constructor creating ILRetLogical from dense storage
            </summary>
            <param name="A">input array, the storage given will directly be used for 
            storage of the new logical array</param>
        </member>
        <member name="M:ILNumerics.ILRetLogical.#ctor(ILNumerics.Storage.ILLogicalStorage,System.Int64)">
            <summary>
            create temporary logical from predefined storage
            </summary>
            <param name="A">the storage will directly be used as storage of the new logical array</param>
            <param name="numberNonZero">number of nonzero elements in A. Must be positive or 0.</param>
            <remarks> Providing this parameter prevents the constructor from having to count the 
            'true' elements in A.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.#ctor(ILNumerics.ILSize)">
            <summary>
            create temporary logical array of specified size
            </summary>
            <param name="size">
            variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <remarks>
            The size parameter may not be null or an empty array. An exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size a logical temporary array of the specified size 
            will be created. </remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.#ctor(System.Byte[],System.Int32[])">
            <summary>
            Constructor - create ILRetLogical of specified size 
            from data array
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <param name="data">byte array matching the size of the dimensions 
            specified. The data will directly be used as storage! No copy will be made!</param>
            <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an ILRetLogical of the specified size 
            will be created. The type of storage will be <code>byte</code>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.#ctor(System.Byte[],ILNumerics.ILSize)">
            <summary>
            Constructor creating ILRetLogical, provide predefined storage
            </summary>
            <param name="data">Predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="size">Size descriptor</param>
        </member>
        <member name="M:ILNumerics.ILRetLogical.#ctor(System.Byte[],ILNumerics.ILSize,System.Int64)">
            <summary>
            Constructor creating ILRetLogical, predefined storage (fast version)
            </summary>
            <param name="data">Predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="size">Size descriptor</param>
            <param name="nonZeroCount">Number of nonzero elements in <paramref name="data"/>. 
            Providing this parameter prevents from counting the 'true' elements (again). </param>
        </member>
        <member name="M:ILNumerics.ILRetLogical.Clone">
            <summary>
            Clone of this array
            </summary>
            <remarks><para>
            Clones of all arrays in ILNumerics are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays 
            on write access.</para>
            <para>The clone returned will be of the same type as this instance.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.Concat(ILNumerics.ILInLogical,System.Int32)">
            <summary>
            Concatenate this array
            </summary>
            <param name="A">N-dimensional array. Except for dimensions <paramref name="dim"/>
            the dimensions of A must match the dimensions of this storage</param>
            <param name="dim">Index of dimension to concatenate arrays along.
            If dim is larger than the number of dimensions of any of the arrays,
            its value will be used in modulus the number of dimensions.</param>
            <returns>New array having the size 
            of both input arrays layed behind each other along the dim's-dimension</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.Equals(System.Object)">
            <summary>
            Compare elements and shape of this array with another array
            </summary>
            <param name="A">Other array</param>
            <returns>true if shape and element values of both arrays match, false otherwise</returns>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.ExportValues(System.Byte[]@)">
            <summary>
            Copy values of all elements into System.Array.
            </summary>
            <param name="outArray">[Output] System.Array, holding all element values of this ILDenseStorage.</param>
            <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            its leading elements will be overwritten when function returns. If 'outArray' is null or has too few elements, 
            it will be recreated from the ILNumerics memory pool.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.GetEnumerator">
            <summary>
            Enumerator returning elements as ElementType
            </summary>
            <returns>Enumerator</returns>
            <remarks>This method enables the use of ILNumerics arrays in foreach loops.
            <para>The iterator is returned, if arrays are directly used in foreach statements. The iterator 
            is compatible with ILNumerics memory management.</para></remarks>
            <example><code>ILDenseStorage&lt;T&gt; A = ILMath.rand(5,4,6);
            foreach (double element in A) {
            // all elements are scalar double values
            String.Format("Element: {0} ",element);
            // Note: 'element' cannot be used to alter the collection! 
            } 
            </code></example> 
        </member>
        <member name="M:ILNumerics.ILRetLogical.GetHashCode">
            <summary>
            Generate a hash code based on the current arrays values
            </summary>
            <returns>Hash code</returns>
            <remarks>The hashcode is generated by taking the values currently stored in the array into account.
            Therefore, the function must iterate over all elements in the array - which makes it somehow a costly 
            operation. Take this into account, if you consider using large arrays in collections like dictionaries 
            or hashtables, which make great use of hash codes.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.GetLimits(System.Byte@,System.Byte@)">
            <summary>
            Get minimum and maximum value of all elements - if any
            </summary>
            <param name="min">[Output] Minimum value</param>
            <param name="max">[Output] Maximum value</param>
            <returns>true if the limits exists and could be computed, false otherwise</returns>
            <remarks>Empty arrays will return false. In this case the output parameter will be: default(ElementType).
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.GetValue(System.Int32[])">
            <summary>
            Get single element from this array
            </summary>
            <param name="idx">Indices, location of element</param>
            <returns>The requested element</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.Reshape(ILNumerics.ILSize)">
            <summary>
            Create reshaped copy of this logical array
            </summary>
            <param name="size">New dimensions of the array</param>
            <returns>Reshaped copy of this array</returns>
            <remarks><para>The current instance will not be changed! A new array is created, having 
            the elements of this array and a shape as determined by <paramref name="size"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="size"/> do not match the number of elements in this array.</exception>
        </member>
        <member name="M:ILNumerics.ILRetLogical.Repmat(System.Int32[])">
            <summary>
            Create replication of this array
            </summary>
            <param name="dims">Dimensions specifier. If the number of elements in <paramref name="dims"/> is 
            less than the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
            <returns>Array being created out of multiple replications of this array along 
            arbitrary dimensions according to <paramref name="dims"/></returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.Serialize(System.IO.Stream)">
            <summary>
             Serialize this ILArray into a binary stream.
            </summary>
            <param name="outStream">System.IO.Stream to receive the byte stream 
            for this ILBaseArray</param>
            <returns>True on success, false on error.</returns>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.Shifted(System.Int32)">
            <summary>
            Create logical array from this logical and shift dimensions
            </summary>
            <param name="shift">Number of dimensions to shift</param>
            <returns>Shifted version of this array</returns>
            <remarks><para>The shift is done 'to the left':</para>
            <example><code>ILArray&lt;double&gt; A = zeros(2,4);
            ILArray&lt;double&gt; B = A.Shifted(1); 
            // B is now: &lt;double&gt; [4,2] 
            
            ILArray&lt;double&gt; C = zeros(2,4,3);
            ILArray&lt;double&gt; D = C.Shifted(1); 
            // D is now: &lt;double&gt; [4,3,2] 
            </code></example>
            <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style.</para>
            <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T"/> property for readability.</para>
            <para><paramref name="shift"/> must be positive. It is taken modulus the number of dimensions.</para>
            <seealso cref="P:ILNumerics.ILDenseArray`1.T"/></remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray from this array
            </summary>
            <param name="range">Arrays specifying the ranges to create subarray from</param>
            <returns>Subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
            <summary>
            Send values of this instance to stream. 
            </summary>
            <param name="stream">Stream to write the values into.</param>
            <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)"/> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
            <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags"/>. Specifies the way in which
            the values will be serialized.</param>
            <remarks><para>If the 'Formatted' method is used, any occurences of the NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style of the output.</para>
            <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as the
            array name for writing. This array instance will be the only array in the .mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Byte[])~ILNumerics.ILRetLogical">
            <summary>
            Implicitly cast one dimensional System.Array to ILNumerics array (vector)
            </summary>
            <param name="A">1-dimensional system array, arbitrary type</param>
            <returns>ILNumerics array of same element type as elements of A. 
            Row vector. If A is null: empty array.</returns>
            <remarks>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion!</remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Array)~ILNumerics.ILRetLogical">
            <summary>
            Implicitly convert n-dim. System.Array to ILNumerics array
            </summary>
            <param name="A">Arbitrarily sized System.Array</param>
            <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
            <remarks>The resulting ILArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of output array (shallow copy).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILCastException">If type of input does not match 
            ElementType</exception>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Byte[0:,0:])~ILNumerics.ILRetLogical">
            <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">2D System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Byte[0:,0:,0:])~ILNumerics.ILRetLogical">
            <summary>
            Implicitly cast three dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">3D System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Boolean)~ILNumerics.ILRetLogical">
            <summary>
            Implicitly convert boolean System.Byte to scalar logical array
            </summary>
            <param name="val">System.Byte</param>
            <returns>Scalar logical array with value of val.</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILRetLogical)~System.Boolean">
            <summary>
            Implicitly convert logical array to System.Boolean
            </summary>
            <param name="A">Logical array</param>
            <returns>true if elements of A are non-zero, false otherwise 
            </returns>
            <remarks>If A is null or empty, the function returns false. Otherwise returns true, 
            if all elements of A are non-zero and returns false, if A contains zero elements.
            <para>The behavior depends on the setting of the ILSettings.LogicalArrayToBoolConversion switch.
            Per default, only scalar arrays are allowed to be converted implicitely. This can be changed 
            to implicitely convert non-scalar arrays by using ILMath.any on the array.</para>
            <seealso cref="P:ILNumerics.Settings.LogicalArrayToBoolConversion"/>
            <seealso cref="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Double},System.Int32)"/>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Int32)~ILNumerics.ILRetLogical">
            <summary>
            Implicitly convert integer scalar to logical array of size 1x1 (scalar).
            </summary>
            <param name="val">Scalar value</param>
            <returns>New logical array of size 1x1 holding the only element of type Byte 
            with value of val.</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILLogical)~ILNumerics.ILRetLogical">
            <summary>
            Convert logical to temporary logical array
            </summary>
            <param name="a">Original logical array</param>
            <returns>Temporary logical array</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILInLogical)~ILNumerics.ILRetLogical">
            <summary>
            Convert logical input parameter type array to temporary logical array
            </summary>
            <param name="a">Logical input parameter type</param>
            <returns>Temporary logical array</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILOutLogical)~ILNumerics.ILRetLogical">
            <summary>
            Convert logical output parameter type array to temporary logical array
            </summary>
            <param name="a">Logical output parameter type</param>
            <returns>Temporary logical array</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILRetLogical)~ILNumerics.ILArray{System.Byte}">
            <summary>
            Implicitly cast to ILArray&lt;byte&gt;
            </summary>
            <param name="a">A ILRetLogical</param>
            <returns>ILArray&lt;byte&gt;</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILArray{System.Byte})~ILNumerics.ILRetLogical">
            <summary>
            Implicitly cast from ILArray&lt;byte&gt;
            </summary>
            <param name="a">An ILArray&lt;byte&gt;</param>
            <returns>logical return array</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILRetLogical)~ILNumerics.ILInArray{System.Byte}">
            <summary>
            Implicitly cast from ILInArray&lt;byte&gt;
            </summary>
            <param name="a">An ILInArray&lt;byte&gt;</param>
            <returns>logical return array</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILInArray{System.Byte})~ILNumerics.ILRetLogical">
            <summary>
            Implicitly cast from ILInArray&lt;byte&gt;
            </summary>
            <param name="a">An ILInArray&lt;byte&gt;</param>
            <returns>logical return array</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_LogicalNot(ILNumerics.ILRetLogical)">
            <summary>
            Invert values of array elements 
            </summary>
            <param name="in1">Input array</param>
            <returns>New logical array, inverted element values</returns>
        </member>
        <member name="P:ILNumerics.ILRetLogical.NumberNonZero">
            <summary>
            Number of 'true' elements in this array
            </summary>
            <remarks>This value caches the number of 'true' elements in this logical array. 
            It may be used for information purposes but is actually needed internally for performance 
            reasons.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetLogical.T">
            <summary>
            Shift the dimensions of this array by one (transpose for matrix)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetLogical.C">
            <summary>
            Create clone of this array 
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetLogical.S">
            <summary>
            Size descriptor shortcut
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetLogical.Size">
            <summary>
            Size descriptor
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetLogical.IsColumnVector">
            <summary>
            Test if this array instance is a column vector (e.g. n x 1)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetLogical.IsRowVector">
            <summary>
            Test if this array instance is a row vector (e.g. 1 x n)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetLogical.IsComplex">
            <summary>
            Determine if this array has complex elements.
            </summary>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetLogical.IsEmpty">
            <summary>
            Test if this instance is an empty array (number of elements stored = 0)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetLogical.IsMatrix">
            <summary>
            Test if this instance is a matrix
            </summary>
            <remarks>In order for an array to be a matrix the number of <b>non singleton</b> 
            dimensions must equal 2. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetLogical.IsNumeric">
            <summary>
            Determine if this array holds numeric values.
            </summary>
            <remarks>An ILArray is numeric as long as its elements are one of the 
            following types: 
            <list type="table">
            <listheader>
                <term>inner type</term>
            </listheader>
            <item>
                <term>System.double</term>
                <description>floating point, real, 8 bytes </description>
            </item>
            <item>
                <term>System.float</term>
                <description>floating point real, 4 bytes</description>
            </item>
            <item>
                <term>ILNumerics.complex</term>
                <description>floating point complex, 16 bytes</description>
            </item>
            <item>
                <term>ILNumerics.fcomplex</term>
                <description>floating point complex, 8 bytes</description>
            </item>
            <item>
                <term>System.char</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.byte</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.Int16</term>
                <description>integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.Int32</term>
                <description>integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.Int64</term>
                <description>integer, real, 8 byte</description>
            </item>
            <item>
                <term>System.UInt16</term>
                <description>unsigned integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.UInt32</term>
                <description>unsigned integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.UInt64</term>
                <description>unsigned integer, real, 8 byte</description>
            </item>
            </list>
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILRetLogical.IsScalar">
            <summary>
            Test if this instance is a scalar
            </summary>
            <remarks>This attribute is readonly. It returns: Size.NumberOfElements == 1.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetLogical.IsVector">
            <summary>
            Test if this array is a vector
            </summary>
            <remarks>In order for an array to be a vector the number of <b>non singleton</b> 
            dimensions must equal 1. Keep in mind that all ILArrays have at least 2 dimensions. Therefore 
            it is not sufficient to test for the number of dimensions, but to take the number of 
            <b>non singleton</b> dimensions into account. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetLogical.Length">
            <summary>
            Length of the longest dimension of this instance
            </summary>
            <remarks>This property is readonly.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetLogical.Name">
            <summary>
            Gets the name of this array (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetLogical.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access (readonly)
            </summary>
            <param name="range">Range specification</param>
            <returns>Logical array with the elements specified by range</returns>
            <remarks>Query access: for N-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range.
            <para>The indexer may be used for querying any elements 
            in this array. <c>range</c> may contains index specifications for one ... to any 
            dimension. The array returned will have the size specified by range.</para>
            </remarks>
        </member>
        <member name="T:ILNumerics.ILOutCell">
            <summary>
            Mathematical container class holding arbitrary array objects as elements 
            </summary>
            <remarks>
            Cells act as general purpose container. Cells store arbitrary arrays of arbitrary element type. 
            Theses elements commonly are cells itself. <c>ILOutCell</c> acts as output parameter 
            in function declarations when a function needs to return multiple (cell) arrays. 
            Use <see cref="T:ILNumerics.ILCell"/> for local cell variables in your algorithms. 
            <para>More details about cells are found in the <a href="http://ilnumerics.net/$Cells.html">online manual</a>.</para>
            </remarks>
            <seealso cref="T:ILNumerics.ILCell"/>
        </member>
        <member name="M:ILNumerics.ILOutCell.#ctor(ILNumerics.Storage.ILCellStorage)">
            <summary>
            do not use this constructor! Out arrays are to be created implicitely only!
            </summary>
            <param name="cellStorage">storage of source cell</param>
        </member>
        <member name="M:ILNumerics.ILOutCell.op_Implicit(ILNumerics.ILCell)~ILNumerics.ILOutCell">
            <summary>
            Implicitely convert persistent cell to output parameter type cell 
            </summary>
            <param name="A">Original cell</param>
            <returns>Output parameter cell</returns>
        </member>
        <member name="M:ILNumerics.ILOutCell.Assign(ILNumerics.ILRetCell)">
            <summary>
            Replaces storage of this array with new array elements, registers this array for out-of-scope disposal
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="M:ILNumerics.ILOutCell.SetValue(ILNumerics.ILBaseArray,System.Int32[])">
            <summary>
            Set single element of the cell
            </summary>
            <param name="value">The new value</param>
            <param name="idx">Indices specifying the location to set the element to</param>
            <remarks>The function supports the following features: 
            <list type="bullet">
            <item>Automatic expansion of the cell, when addressing an element outside of the cells size limits.</item>
            <item>Before storing the new element into the cell, an old element may existing on the same location gets disposed.</item>
            <item>A clone of the new value is stored, therefore, none of the source and the stored element are altered, whenever the other cell is altered (value semantics).</item>
            <item>The function supports deep index addressing. This is the only way of altering array elements inside the cell - without recreation.</item>
            </list>
            <para>Removal of parts of the cell is <b>not</b> supported. If null or an empty array is provided as <paramref name="value"/>, the corresponding 
            element is overwritten or removed.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILOutCell.SetValue(ILNumerics.Storage.ILStorage,System.Int32[])">
            <summary>
            Set single element of the cell
            </summary>
            <param name="value">The new value</param>
            <param name="idx">Indices specifying the location to set the element to</param>
            <remarks>The function supports the following features: 
            <list type="bullet">
            <item>Automatic expansion of the cell, when addressing an element outside of the cells size limits.</item>
            <item>Before storing the new element into the cell, an old element may existing on the same location gets disposed.</item>
            <item>A clone of the new value is stored, therefore, none of the source and the stored element are altered, whenever the other cell is altered (value semantics).</item>
            <item>The function supports deep index addressing. This is the only way of altering array elements inside the cell - without recreation.</item>
            </list>
            <para>Removal of parts of the cell is <b>not</b> supported. If null or an empty array is provided as <paramref name="value"/>, the corresponding 
            element is overwritten or removed.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILOutCell.GetArrayForWrite">
            <summary>
            Direct reference to inner System.Array storage for write access - use with care!
            </summary>
            <returns>Reference to inner System.Array</returns>
            <remarks>Altering this array can be done directly. If necessary, the array is detached before 
            returned. Watch the column order format of storages in ILNumerics. Keep in mind, the length 
            of the System.Array may exceed the number of elements of the ILNumerics array.
            <para>Accessing the inner system array directly should be left to ILNumerics experts only. 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T>!</para>
            <para>Unlike (almost) all other member function of an array, this function
            does not keep track of internal memory management. It means, the storage which this array is based 
            upon, will not be set free after the function returns. You (as the user of the array) will have to pay 
            attention yourself, when to call dispose on the array - if necessary. Also, for elements of reference
            types (e.g. ILCell), retrieving and storing elements from/into the System.Array directly does 
            not simulate a value semantic as all other functions do! This means, references are copied. Attention
            must be paid to dereference / clone elements accordingly. </para></remarks>
        </member>
        <member name="P:ILNumerics.ILOutCell.a">
            <summary>
            Replace the elements of this array with another array's elements, preventing memory leaks
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="P:ILNumerics.ILOutCell.Item(System.Int32[])">
            <summary>
            Get/set/remove single element 
            </summary> 
            <paramref name="indices" value="index to element"/>
            <value>Inner element, new inner element or null</value>
            <remarks>The type of access depends on the length of indices. If indices contains only one element, 
            the array will be accessed via sequential index access. This is sometimes called referred to as 'linear' 
            index addressing. 
            Sequential index access reflects the index of internal storage the way the data are actually organized 
            in memory. This access method is mainly convinient for vectors where you are not interested of orientation.
            The following example demonstrates sequential index access for ILArray's (which also holds for ILCells): 
            <example>For <c>ILArray&lt;double&gt; A = ILMath.counter(1,12);</c>, <c>A[2]</c> gives: 3.0.
            But the transpose 
            <c>A.T[2]</c> gives also: 3.0.
            For matrices and N-dimensional arrays this holds as well: 
            <code>
            ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,3,2,2);
            A = 
            [1.0 4.0
             2.0 5.0 
             3.0 6.0 
            
             7.0 10.0
             8.0 11.0
             9.0 12.0]
            
            A = ILMath.Reshape(A,3,2,2); 
            A[10] gives 11.0
            A[10,1] gives ILArgumentException -> out of range
            A[2,1,1] gives 12.0
            A[2,1] gives 6.0 (set trailing dimension to '0')</code></example>
            <para>If the element addressed is a ILCell itself, a deep reference to this element will be returned instead. 
            I.e. all elements of the ILCell will be recursively replaced with references to itself. Therefore, altering the 
            elements returned will not alter the elements contained in the cell.</para>
            <para>
            <list type="bullet">
            <listheader>The type of the element returned depends on the type of the element addressed:</listheader>
            <item>For ILArray&lt;ElementType&gt; the array returned will be a clone of the original array.</item> 
            <item>For ILCell the ILBaseArray returned is a deep reference of the original elements stored.</item>
            <item>For other types the behavior is undefined. (since other types are not implemented yet ;)</item>
            </list> </para>
            <para>This indexer may also be used for direct access to inner elements of (elements of elements of ...) this cell:
            <example>
            <code>
            ILCell innerCell = new ILCell(2,1); 
            innerCell[0] = ILMath.vec(10,200); 
            innerCell[1] = new int[] {-10,-20,-30};
            ILCell cell = new ILCell(2,1); 
            cell[0] = innerCell; 
            cell[1] = new string[] {"foobla"}; 
            // cell is now: 
            // [ILCell,(1x2)] 
            //      [innerCell[0], ILArray&lt;double&gt;(1x181)]
            //      [innerCell[0], ILArray&lt;double&gt;(1x3)]
            // [ILArray&lt;string&gt;,(1x1)]
            
            cell[0,0] -&gt; will give innerCell eq. ILCell (1x2)
            cell[0,1] -&gt; will give ILArray&lt;string&gt;
            cell[0,0,0,1] -&gt; will give innerCell[1] eq. ILArray&lt;int&gt;(1x3)
            </code>
            </example> 
            In the last example above the trailing indices specified make the indexer walk down into the ILCell element and retrieve 
            the content of this element. This kind of index access may be done as deep as you want. Just 
            append the inner indices into inner elements to the right side of index specification. Addressing inner elements 
            this way is the only way to alter elements <b>directly</b> inside the ILCell. </para>
            <para>Output parameter type cell carry a reference to the original array they were created from. 
            Modifications of outpur parameter type cells are immediately applied to the original array also.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILOutCell.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access. Get/set regular subarray. 
            </summary>
            <param name="indices">Address range</param>
            <returns>Reference cell array with subarray addressed by <c>indices</c>. </returns>
            <remarks>Query access: for N-dimensional cell arrays missing trailing dimensions indices will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para>
            <para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements.</para>
            <para>The indexer may also be used for removing parts of the cell. Therefore null must be assigned to the range specified by <c>indices</c> (using the set-access). <c>indices</c> 
            must contain exactly one dimension specification other than 'full' in this case. This may be any vector-sized numeric ILArray of any 
            numeric type. If <c>indices</c> apply to fewer dimensions than the number of dimensions existing, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.
            <example>
            <code>
            ILCell C = new ILCell(4,10); 
            C[":",2] = null;  // &gt;- will remove the third column (index: 2) from the cell.
            C[full,vec(2,5)] = null;  &gt;- will remove columns 3...6
            C[1,1] = null; &gt;- will produce an error. Only one dimension can be specified not full! 
            </code></example></para>
            <para>The general behavior of this access methods is full compatible with the corresponding Matlab/Octave/Scilab access: a(:) = []. </para>
            <para>Output parameter type cell carry a reference to the original array they were created from. 
            Modifications of outpur parameter type cells are immediately applied to the original array also.</para></remarks>
        </member>
        <member name="T:ILNumerics.Data.ILAVLTree">
            <summary>
            AVL balanced search tree
            </summary>
            <remarks>The tree stores unique keys (type:System.Int64, configurable via build) in a balanced search tree.
            <para>The implementation is optimized for random seek access and consecutive write access - if no matching key found. 
            Also, the next higher key for a given query can be returned in O(1).</para>
            <para>The AVL tree class is not intended to be used directly. It supports the ILNumerics infrastructure (ILMemoryPool) 
            internally.</para></remarks>
        </member>
        <member name="M:ILNumerics.Data.ILAVLTree.Add(System.Int64)">
            <summary>
            Check and add a key to the collection
            </summary>
            <param name="key">Key</param>
            <remarks>The function makes sure, the key is stored in the tree.</remarks>
        </member>
        <member name="M:ILNumerics.Data.ILAVLTree.Remove(System.Int64)">
            <summary>
            Remove key from tree
            </summary>
            <param name="key">Key to be removed</param>
            <remarks>The function makes sure, the tree does not contain a node with the given key.</remarks>
        </member>
        <member name="M:ILNumerics.Data.ILAVLTree.Next(System.Int64)">
            <summary>
            Find next higher key
            </summary>
            <param name="key">Key to find</param>
            <returns>The key with the next higher value compared with <paramref name="key"/>, or -1 if no such key exists</returns>
        </member>
        <member name="M:ILNumerics.Data.ILAVLTree.Clear">
            <summary>
            Clear the tree from all keys
            </summary>
        </member>
        <member name="M:ILNumerics.Data.ILAVLTree.CheckTree">
            <summary>
            check the consistency of the tree
            </summary>
            <returns></returns>
        </member>
        <member name="P:ILNumerics.Data.ILAVLTree.Count">
            <summary>
            Return number of keys currently existing in the tree
            </summary>
        </member>
        <member name="T:ILNumerics.Data.ILAVLTree.ILAVLTreeNode">
            <summary>
            an AVL tree node 
            </summary>
        </member>
        <member name="F:ILNumerics.Data.ILAVLTree.ILAVLTreeNode.key">
            <summary>
            Key
            </summary>
        </member>
        <member name="F:ILNumerics.Data.ILAVLTree.ILAVLTreeNode.right">
            <summary>
            Right child
            </summary>
        </member>
        <member name="F:ILNumerics.Data.ILAVLTree.ILAVLTreeNode.left">
            <summary>
            Left child
            </summary>
        </member>
        <member name="F:ILNumerics.Data.ILAVLTree.ILAVLTreeNode.balance">
            <summary>
            Balance factor for the node
            </summary>
        </member>
        <member name="M:ILNumerics.Data.ILAVLTree.ILAVLTreeNode.ToString">
            <summary>
            String representation of the node 
            </summary>
            <returns>String representation of the node</returns>
        </member>
        <member name="T:ILNumerics.Data.BSPPrimitive`1">
            <summary>
            Primitive struct for BSP tree nodes; may refer to labels, points, lines or triangles
            </summary>
        </member>
        <member name="M:ILNumerics.Data.BSPPrimitive`1.Interpolate(System.Int32,System.Int32,System.Single,ILNumerics.Data.Vertex@)">
            <summary>
            Derive a new vertex on an edge of this primitive by interpolating from vertices at both ends
            </summary>
            <param name="a">first vertex ID</param>
            <param name="b">second vertex ID</param>
            <param name="t">fraction between a and b; range [0..1]</param>
            <param name="storage">target vertex struct to store the results into</param>
        </member>
        <member name="M:ILNumerics.Data.BSPPrimitive`1.GetVertexAt(System.Int32)">
            <summary>
            Retrieve individual vertex from the primitive by index
            </summary>
            <param name="idx">index; range 0 .. VertexCount</param>
            <returns>Vertex with position, color and normal information. If colors or normals are not defined in the original shape, default values are returned.</returns>
        </member>
        <member name="M:ILNumerics.Data.BSPPrimitive`1.GetPlane">
            <summary>
            Create plane from this primitive Positions
            </summary>
            <returns>Plane</returns>
        </member>
        <member name="M:ILNumerics.Data.BSPPrimitive`1.ToString">
            <summary>
            String representation for this primitive
            </summary>
            <returns>Primitive description</returns>
        </member>
        <member name="T:ILNumerics.Data.ILBSPNode`1">
            <summary>
            A node within the BSP tree
            </summary>
        </member>
        <member name="M:ILNumerics.Data.ILBSPNode`1.ToString">
            <summary>
            Create string representation of this node
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Data.ILBSPNode`1.Count">
            <summary>
            Compute the number of primitives within the node and subtree 
            </summary>
            <returns>Primitives count</returns>
        </member>
        <member name="P:ILNumerics.Data.ILBSPNode`1.Front">
            <summary>
            Collection of front primitives
            </summary>
        </member>
        <member name="P:ILNumerics.Data.ILBSPNode`1.Back">
            <summary>
            Collection of back primitives
            </summary>
        </member>
        <member name="P:ILNumerics.Data.ILBSPNode`1.Plane">
            <summary>
            Dividing plane
            </summary>
        </member>
        <member name="P:ILNumerics.Data.ILBSPNode`1.Primitives">
            <summary>
            Collection of on-plane primitives
            </summary>
        </member>
        <member name="T:ILNumerics.Data.BSPTreeHint">
            <summary>
            Possible values, influencing the BSP tree creation
            </summary>
        </member>
        <member name="M:ILNumerics.Data.ILBSPTreeSettings.#ctor">
            <summary>
            Creates a new settings instance with default paramters.
            </summary>
        </member>
        <member name="P:ILNumerics.Data.ILBSPTreeSettings.PlaneThickness">
            <summary>
            Split planes are considered 'thick' in order to handle floating point inaccuracies. Default: single precision eps 
            </summary>
        </member>
        <member name="P:ILNumerics.Data.ILBSPTreeSettings.Hint">
            <summary>
            Determines if the tree favors balancing and runtime speed over creation speed. Default: fast creation
            </summary>
        </member>
        <member name="P:ILNumerics.Data.ILBSPTreeSettings.BalanceSplitRatio">
            <summary>
            For Hint.FastRunning mode: the ratio between a balanced tree and minimal necessary primitive splits. Default: 0.86
            </summary>
        </member>
        <member name="T:ILNumerics.Data.ILBSPTree`1">
            <summary>
            Binary Space Partioning (BSP) tree class
            </summary>
            <typeparam name="T">Data type for BSP tree nodes</typeparam>
            <remarks>The class is used on several places withing ILNumerics. One example is the preparation of scenes for rendering in SVG driver.</remarks>
        </member>
        <member name="M:ILNumerics.Data.ILBSPTree`1.#ctor(System.Collections.Generic.IEnumerable{ILNumerics.Data.BSPPrimitive{`0}},ILNumerics.Data.ILBSPTreeSettings)">
            <summary>
            Create new BSP tree, given the list of primitives 
            </summary>
            <param name="primitives">individual, prebuild primitives </param>
            <param name="settings">[optional] settings for tuning the tree creation. Default: default instance</param>
        </member>
        <member name="M:ILNumerics.Data.ILBSPTree`1.GetSorted(ILNumerics.Drawing.Vector3,System.Boolean)">
            <summary>
            Retrieve all primitives from the BSP tree, spatially sorted order; for use in foreach loops
            </summary>
            <param name="cameraPosition">Current camera position</param>
            <param name="back2Front">[optional] Flag determining the sort order: back to front (default) or front to back</param>
            <returns>individual sorted primitives</returns>
        </member>
        <member name="P:ILNumerics.Data.ILBSPTree`1.Random">
            <summary>
            Thread static random generator
            </summary>
        </member>
        <member name="P:ILNumerics.Data.ILBSPTree`1.Root">
            <summary>
            Root node of the tree
            </summary>
        </member>
        <member name="M:ILNumerics.Data.ILIntList.GetArray">
            <summary>
            caution! This may bring the ILIntList in inconsistent state! 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Animation.ILBlendAnimation.Reset">
            <summary>
            Resets the local clock to the end of the blendin ramp 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Animation.ILInterpolator`1.InterpolateInternal(System.Int32,System.Int64)">
            <summary>
            the actual interpolation between two keyframes, concrete class can rely on ms laying between two existing keyframes
            </summary>
            <param name="keyframeStartIDX">the index of the keyframe _before_ ms </param>
            <param name="ms">current time</param>
            <returns>interpolated value for ms</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClock.#ctor">
            <summary>
            Creates a new clock and start it running 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClock.TimeMilliseconds">
            <summary>
            Gets or sets the current time of the clock in milliseconds or sets
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClock.Running">
            <summary>
            Gets the current running state of the clock or sets it
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILBufferBase.Disposing">
            <summary>
            Fires before the buffer gets disposed
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILBufferBase.Changed">
            <summary>
            Fires once the buffer has been changed
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILBufferBase.DataLength">
            <summary>
            Dimensionality of a single date in this buffer (number of rows or length of each vector)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILBuffer`1.#ctor(System.Int32)">
            <summary>
            Creates a new empty buffer.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILBuffer`1.Storage">
            <summary>
            returns a copy(!) of the buffers array storage, using a lazy-copy-on-write scheme. Use Update() for modifications! 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILBuffer`1.DataCount">
            <summary>
            Number of data vectors (columns)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILBuffer`1.DataLength">
            <summary>
            Dimensionality of a single date in this buffer (number of rows or length of each vector)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILBuffer`1.ReferenceCount">
            <summary>
            Number of objects currently using this buffer
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILBufferSet.Copy">
            <summary>
            Creates (lazy) copy of this buffer set which allows local changes without affecting referenced buffer sets 
            </summary>
            <remarks>Buffer sets are copied only, if a copy is explicitely requested. This happens once the user calls ILShape.Detach().</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILBufferSet.ID">
            <summary>
            Globally unique ID for the buffer set 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.IILDriver">
            <summary>
            Interface for all driver implementations, most common implementor is System.Drawing.ILDriver
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.IILDriver.Configure">
            <summary>
            Configures the scene
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.IILDriver.Render(System.Int64)">
            <summary>
            Trigger a frame rendering at a specific point in time
            </summary>
            <param name="timeMs"></param>
        </member>
        <member name="M:ILNumerics.Drawing.IILDriver.GetCurrentScene(System.Int64)">
            <summary>
            Return a scene which reflects the rendering result, including all local compositions and modifications
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.IILDriver.Supports(ILNumerics.Drawing.Capabilities)">
            <summary>
            Reserved for future use
            </summary>
            <param name="Capability"></param>
            <returns>True if the driver is able to support the requested capability</returns>
        </member>
        <member name="M:ILNumerics.Drawing.IILDriver.PickAt(System.Drawing.Point,System.Int64)">
            <summary>
            Performs picking on the current local scene
            </summary>
            <param name="screenCoords">position in screen coordinates (pixels)</param>
            <param name="timeMS">the time at which the scene is picked at</param>
            <returns>If an object is visible at the given position, its ID is returned. Otherwise null is returned.</returns>
        </member>
        <member name="E:ILNumerics.Drawing.IILDriver.BeginRenderFrame">
            <summary>
            Must fire befor a frame is rendered
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.IILDriver.EndRenderFrame">
            <summary>
            Must fire after the frame was rendered
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.IILDriver.RenderingFailed">
            <summary>
            Fires, when an unrecoverable error occoured during rendering
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.IILDriver.FPSChanged">
            <summary>
            Fires when the current framerate has changed. 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILControlBridge.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILControlBridge.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILControlBridge.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILGDIControl.GetCurrentScene(System.Int64)">
            <summary>
            Return a scene which reflects the rendering result, including all local compositions and modifications
            </summary>
            <param name="ms">[optional] time of render frame</param>
            <returns>scene composition as copies of local and global scene with user interaction</returns>
        </member>
        <member name="F:ILNumerics.Drawing.ILGDIControl.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILGDIControl.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILGDIControl.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILGDIControl.Clock">
            <summary>
            Gets the clock which provides the time base for animations
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILMouseEventArgs">
            <summary>
            Extends common MouseEventArgs for event processing for ILNumerics scenes
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILMouseEventArgs.Cancel">
            <summary>
            True: event processing will be canceled after this node and not get populated further down or up.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILMouseEventArgs.ShiftPressed">
            <summary>
            Determines if the SHIFT key is currently pressed (ignored on Mac)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILMouseEventArgs.ControlPressed">
            <summary>
            Determines if the CTRL key is currently pressed (ignored on Mac)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILMouseEventArgs.AltPressed">
            <summary>
            Determines if the ALT key is currently pressed (ignored on Mac)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILMouseEventArgs.TimeMS">
            <summary>
            The global scene time when the event was raised
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILMouseEventArgs.Refresh">
            <summary>
            Signals the driver to redraw the scene after processing the event; default: false
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILMouseEventArgs.LocationF">
            <summary>
            The mouse position relative to the current viewport; range [0...1] 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILMouseEventArgs.Target">
            <summary>
            The final target node for the event, commonly the node under the mouse cursor
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILMouseEventArgs.DirectionUp">
            <summary>
            Gives the direction of event; false: capture (down), true: bubbling (up) 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILMouseEventArgs.Empty">
            <summary>
            Creates an empty ILMouseEventArgs instance
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILOGLControl.GetCurrentScene(System.Int64)">
            <summary>
            Return a scene which reflects the rendering result, including all local compositions and modifications
            </summary>
            <param name="ms">[optional] time of render frame</param>
            <returns>scene composition as copies of local and global scene with user interaction</returns>
        </member>
        <member name="P:ILNumerics.Drawing.ILOGLControl.Clock">
            <summary>
            Gets the clock which provides the time base for animations
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILPanel">
            <summary>
            The main Windows.Forms rendering panel in ILNumerics, supports various drivers
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Render(System.Int64)">
            <summary>
            Trigger the rendering of a complete frame
            </summary>
            <param name="timeMs"></param>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Configure">
            <summary>
            Configure panel and scene after modifications to any buffers
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Supports(ILNumerics.Drawing.Capabilities)">
            <summary>
            [Reserved for future use]
            </summary>
            <param name="Capability">Capability to query</param>
            <returns>True if this driver supports the capability requested, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.GetCurrentScene(System.Int64)">
            <summary>
            Returns a scene which reflects the rendering result, including all local compositions and modifications
            </summary>
            <param name="ms">[optional] time of render frame</param>
            <returns>scene composition as copies of local and global scene, including user interactions and auto generated shapes (ticks, camera etc.)</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.PickAt(System.Drawing.Point,System.Int64)">
            <summary>
            Determines the ID of the shape according to a specific pixel position inside the Rectangle output area at a specific point in time
            </summary>
            <param name="screenCoords">pixel coords, (0,0) is at upper left corner</param>
            <param name="timeMs">the point in time for rendering</param>
            <returns>the id of the shape which exists at the given screen coordinates, null if no such shape exists</returns>
        </member>
        <member name="F:ILNumerics.Drawing.ILPanel.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILPanel.FPSChanged">
            <summary>
            Fires when the number of rendered frames per second changes
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILPanel.BeginRenderFrame">
            <summary>
            Fires when the rendering of a frame was started
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILPanel.EndRenderFrame">
            <summary>
            Fires when the rendering of a frame was finished
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILPanel.RenderingFailed">
            <summary>
            Fires when the rendering of a frame failed
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.ShowUIControls">
            <summary>
            [Reserved for future use] Determines if extended interactive UI controls are shown at runtime
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.Editor">
            <summary>
            [Reserved for future use]
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.FPS">
            <summary>
            Gets the current frame rate (frames per second) when the clock is running
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.BackColor">
            <summary>
            Get the back color of the control or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.Camera">
            <summary>
            Get a reference to the default camera of the scene
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.Rectangle">
            <summary>
            Gets the rectangular area which this panel occupies inside its container control or sets that rectangle
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.ViewTransform">
            <summary>
            Get the rectangular area as fraction of the area defined by Rectangle, which is used to render the scene to. ViewTransform Matrix4.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.Driver">
            <summary>
            Gets the driver used to render the scene to the rendering surface or sets it. Default: OpenGL, fallback: GDI
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.LocalScene">
            <summary>
            Gets the scene which is only maintained by this panel and not shared between multiple drivers.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.SceneSyncRoot">
            <summary>
            Gets the rendering scene which is constantly synchronized/derived with/from the (global) Scene 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.LocalSceneSyncRoot">
            <summary>
            Get the rendering scene which is constantly synchronized/derived with/from the LocalScene  
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPlotPanel.#ctor">
            <summary>
            Create a new plot panel with an empty plot cube 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Controls.ILPlotPanel.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPlotPanel.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Controls.ILPlotPanel.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPlotPanel.PlotCube">
            <summary>
            The default plot cube object for this plot panel
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Controls.ILPlotPanel.Scene">
            <summary>
            Gets a reference to the global scene of this panel or sets it
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILXMLDriver">
            <summary>
            Serializing driver for XML output
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILDriver">
            <remarks>Abstract driver base class for all output driver implementations</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILDriver.DrawNode(ILNumerics.Drawing.ILDrawable,ILNumerics.Drawing.ILRenderParameter)">
            <summary>
            Default implementation, simply print out a copy of all shapes data
            </summary>
            <param name="node">the shape to draw</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILDriver.ComputeLight(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector3,ILNumerics.Drawing.Vector3,System.Single,System.Drawing.Color,System.Drawing.Color,ILNumerics.Drawing.ILRenderParameter)">
            <summary>
            vertex based lighting equations (Lambert' + Gauss) 
            </summary>
            <param name="col">Diffuse color</param>
            <param name="pos">position (camera coords)</param>
            <param name="normal">normal (camera coords, properly scaled)</param>
            <param name="Emission">emissive color</param>
            <param name="Shininess">shininess exponent</param>
            <param name="Specular">specular color</param>
            <param name="parameters">render parameter</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILDriver.BeginRender(ILNumerics.Drawing.ILRenderParameter)">
            <summary>
            Fires the OnBeginRenderFrame event
            </summary>
            <param name="renderParams"></param>
            <remarks>This is not guaranteed to be called in certain scenarios. Do not rely on this function to be called for important driver setups! Use BeginRenderPass instead. </remarks>
        </member>
        <member name="F:ILNumerics.Drawing.ILXMLDriver.m_writer">
             Some notes on the functioning of ILXMLDriver. We refused to utilize one of the common .NET serialization methods. 
             Reasons: They all either force (break) a specific design (XML Serializer: publicity of properties, the 
             need of XMLIncludeAttributes on base classes, huge hassle to get inheritance working) or do not give enough
             flexibility by determining the resulting XML layout (DataContract Serializer). Hence, we do it that way: 
             (1) (removed)
             (2) Some basic types are known to the serializer, e.g. ILGroup. These types are 'manually' serialized, utilizing the 'knowledge' of ILXMLDriver. 
             (3) When the driver receives a node which it does not know, it first inspects the type, if it implements a ToXML(XMLWriter) method. If 
                 such method is found, it will be used to serialize the instance. Otherwise, reflection is used to serialize the object. 
             (4) Only properties are serialized. Common XMLAttributes on a property are used to indicate special handling: XMLIgnore, XMLAttribute, XMLElement. 
                 If no attribute exists for a public property it will be serialized as XML element by default.  
            
        </member>
        <member name="T:ILNumerics.Drawing.ILXmlSerializeAsAttribute">
            <summary>
            Attribute used to determine the format of members for serialization
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILXmlSerializeAsAttribute.Format">
            <summary>
            Format for serializing members of marked types: "{membername} ..."; also valid: {this}
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILXmlSerializer">
            <summary>
            Serializer class for serializing ILNumerics scenes 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILXmlSerializer.#ctor(System.Xml.XmlWriter)">
            <summary>
            Create a new ILXmlSerializer and provide the xml writer which receives the data
            </summary>
            <param name="writer">xml writer as target for the data</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILXmlSerializer.Serialize(System.Object)">
            <summary>
            Convert the given object and all its subobjects / subtree into XML representation
            </summary>
            <param name="obj">ILNumerics object, mostly ILScene</param>
        </member>
        <member name="M:ILNumerics.Drawing.Matrix4.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            create new matrix ROW MAJOR definition! 
            </summary>
            <param name="m11"></param>
            <param name="m12"></param>
            <param name="m13"></param>
            <param name="m14"></param>
            <param name="m21"></param>
            <param name="m22"></param>
            <param name="m23"></param>
            <param name="m24"></param>
            <param name="m31"></param>
            <param name="m32"></param>
            <param name="m33"></param>
            <param name="m34"></param>
            <param name="m41"></param>
            <param name="m42"></param>
            <param name="m43"></param>
            <param name="m44"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Matrix4.Invert(ILNumerics.Drawing.Matrix4)">
            <summary>
            Calculate the inverse of the given matrix
            </summary>
            <param name="mat">The matrix to invert</param>
            <returns>The inverse of the given matrix if it has one, or the input if it is singular</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the Matrix4 is singular.</exception>
        </member>
        <member name="M:ILNumerics.Drawing.Matrix4.CreatePerspectiveFieldOfView(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a perspective projection matrix.
            </summary>
            <param name="fovy">Angle of the field of view in the y direction (in radians)</param>
            <param name="aspect">Aspect ratio of the view (width / height)</param>
            <param name="zNear">Distance to the near clip plane</param>
            <param name="zFar">Distance to the far clip plane</param>
            <param name="result">A projection matrix that transforms camera space to raster space</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown under the following conditions:
            <list type="bullet">
            <item>fovy is zero, less than zero or larger than Math.PI</item>
            <item>aspect is negative or zero</item>
            <item>zNear is negative or zero</item>
            <item>zFar is negative or zero</item>
            <item>zNear is larger than zFar</item>
            </list>
            </exception>
        </member>
        <member name="M:ILNumerics.Drawing.Matrix4.CreatePerspectiveOffCenter(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,ILNumerics.Drawing.Matrix4@)">
            <summary>
            Creates an perspective projection matrix.
            </summary>
            <param name="left">Left edge of the view frustum</param>
            <param name="right">Right edge of the view frustum</param>
            <param name="bottom">Bottom edge of the view frustum</param>
            <param name="top">Top edge of the view frustum</param>
            <param name="zNear">Distance to the near clip plane</param>
            <param name="zFar">Distance to the far clip plane</param>
            <param name="result">A projection matrix that transforms camera space to raster space</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown under the following conditions:
            <list type="bullet">
            <item>zNear is negative or zero</item>
            <item>zFar is negative or zero</item>
            <item>zNear is larger than zFar</item>
            </list>
            </exception>
        </member>
        <member name="M:ILNumerics.Drawing.Matrix4.Rotation(ILNumerics.Drawing.Vector3,System.Double)">
            <summary>
            Build a rotation matrix from the specified axis/angle rotation.
            </summary>
            <param name="axis">The axis to rotate about.</param>
            <param name="angle">Angle in radians to rotate counter-clockwise (looking in the direction of the given axis).</param>
            <param name="result">A matrix instance.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Matrix4.Mult(ILNumerics.Drawing.Matrix4@,ILNumerics.Drawing.Matrix4@,ILNumerics.Drawing.Matrix4@)">
            <summary>
            Multiplies two instances.
            </summary>
            <param name="left">The left operand of the multiplication.</param>
            <param name="right">The right operand of the multiplication.</param>
            <param name="result">A new instance that is the result of the multiplication</param>
        </member>
        <member name="M:ILNumerics.Drawing.Matrix4.ViewTransformWithPerspDivide(ILNumerics.Drawing.Matrix4,ILNumerics.ILInArray{System.Single})">
            <summary>
            Transforms clip positions into view coordinates, includes perspective divide
            </summary>
            <param name="ViewTransform">View Transformation Matrix</param>
            <param name="A">clip positions matrix, 3xn or 4xn</param>
            <returns>view coordinates</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Matrix4.CreateFromQuaternion(ILNumerics.Drawing.Quaternion@,ILNumerics.Drawing.Matrix4@)">
            <summary>
            Build a rotation matrix from the specified quaternion.
            </summary>
            <param name="q">Quaternion to translate.</param>
            <param name="m">Matrix result.</param>
        </member>
        <member name="P:ILNumerics.Drawing.ILClipParams.Infinity">
            <summary>
            A set of clipping planes which does apply clipping at infinity; effectively causes no clipping
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.LegendMode">
            <summary>
            Modes determining how a legend collects its items
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LegendMode.Auto">
            <summary>
            Automatically collect and add all items found
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LegendMode.Manual">
            <summary>
            Complete manual configuration for legends
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Units">
            <summary>
            Unit scales for lengths
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Units.Pixels">
            <summary>
            The length/ coordinate is measured in screen pixels 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Units.Points">
            <summary>
            The length/ coordinate is measured in points 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Units.Viewport">
            <summary>
            The length/ coordinate is measured relative to the current viewport size, range [0...1]
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.AspectRatioMode">
            <summary>
            modes for projecting the rendering output to the available client area
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AspectRatioMode.StretchToFill">
            <summary>
            plots fill available rendering area of the PlotCubeScreenRectF rectangle
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AspectRatioMode.MaintainRatios">
            <summary>
            plots will be shrinked to fit inside PlotCubeScreeRectF but maintain data aspect ratio
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ZoomModes">
            <summary>
            transition from current to new zoom setting
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ZoomModes.Jump">
            <summary>
            No ramp, jump to new zoom setting
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ZoomModes.RollSoft">
            <summary>
            morph softly to new zoom setting
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ZoomModes.RollHard">
            <summary>
            morph faster to new setting
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ZoomModes.RollOverride">
            <summary>
            morph to new setting by 'going over the limit'
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Colormaps">
            <summary>
            predefined colormaps
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.SortingMode.None">
            <summary>
            No sorting
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.SortingMode.BackToFront">
            <summary>
            BackToFront
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.SortingMode.FrontToBack">
            <summary>
            FrontToBack
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.AxisNames">
            <summary>
            Names for all axes 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AxisNames.XAxis">
            <summary>
            The X axis
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AxisNames.YAxis">
            <summary>
            The Y axis
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AxisNames.ZAxis">
            <summary>
            The Z axis
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AxisNames.CAxis">
            <summary>
            Custom axis or color scale
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.AxisScale">
            <summary>
            Axis ticks spacing type: linear, logarithmic
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AxisScale.Linear">
            <summary>
            Linear axis tick spacing
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AxisScale.Logarithmic">
            <summary>
            Logarithmic axis tick spacing
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.TickMode">
            <summary>
            TickModes - automatic or manual axis tick positioning
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickMode.Auto">
            <summary>
            find tick positions automatically 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickMode.Manual">
            <summary>
            manually create ticks 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.PlotBoxScreenSizeMode">
            <summary>
            options for the sizing of the projection of the plot cube onto the 2D screen client area of the control
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.PlotBoxScreenSizeMode.Maximum">
            <summary>
            the projection of the plot cube drawing area fills the whole controls space (labels may be hidden) 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.PlotBoxScreenSizeMode.Optimal">
            <summary>
            the size of plot cube projection rectangle is automatically determined, taking labels size into account
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.PlotBoxScreenSizeMode.StrictOptimal">
            <summary>
            more pixel exact positioning, strictly only the place really needed for labels is used (slower)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.PlotBoxScreenSizeMode.Manual">
            <summary>
            No automatic resizing for the cube projection size, values from PlotCubeScreenRect are taken
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Projection">
            <summary>
            projection types
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Projection.Perspective">
            <summary>
            3D graphs will be distorted for opotimized 3D impression
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Projection.Orthographic">
            <summary>
            graphs will not be distorted. objects in the front will get the same size as objects in the back
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.MarkerStyle">
            <summary>
            valid marker styles (partially supported)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Dot">
            <summary>
            draw markers as dots
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Circle">
            <summary>
            draw markers as circle
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Diamond">
            <summary>
            draw markers as diamonds
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Square">
            <summary>
            draw markers as square
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Rectangle">
            <summary>
            draw markers as a flat rectangle
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.TriangleUp">
            <summary>
            draw markers as up pointing triangles
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.TriangleDown">
            <summary>
            draw markers as up pointing triangles
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.TriangleLeft">
            <summary>
            draw markers as up pointing triangles
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.TriangleRight">
            <summary>
            draw markers as up pointing triangles
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Plus">
            <summary>
            draw markers as plus
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Cross">
            <summary>
            draw markers as cross
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Custom">
            <summary>
            user defined marker shape
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.CameraQuadrant">
            <summary>
            Possible positions of the camera
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.DashStyle">
            <summary>
            line style
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.DashStyle.Solid">
            <summary>
            solid line
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.DashStyle.Dashed">
            <summary>
            dashed line
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.DashStyle.PointDash">
            <summary>
            point dashed line
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.DashStyle.Dotted">
            <summary>
            dotted line
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.DashStyle.UserPattern">
            <summary>
            use user stipple pattern 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.InteractiveModes">
            <summary>
            modes of mouse interaction with ILPanel
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.RenderTarget">
            <summary>
            Target coordinate system for objects like labels 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.RenderTarget.Screen2DNear">
            <summary>
            The object is rendered above Screen2DFar and World3D objects; 2D screen coordinate system: [0,0,-1] -> [1,1,1]
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.RenderTarget.Screen2DFar">
            <summary>
            The object is rendered above Screen2DFar and World3D objects; 2D screen coordinate system: [0,0,-1] -> [1,1,1]
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.RenderTarget.World3D">
            <summary>
             (default) The object is rendered as regular 3D object; coordinate system range: [-1,-1,-1] -> [1,1,1]
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.RenderItemType">
            <summary>
            possible types of renderable items 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.RenderItemType.Character">
            <summary>
            the item defines a character 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.RenderItemType.Bitmap">
            <summary>
            the item defines a bitmap
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.CullFaces">
            <summary>
            Options for face culling (specific drivers only)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.CullFaces.CW">
            <summary>
            Faces defined in clockwise order are culled 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.CullFaces.CCW">
            <summary>
            Faces defined in counter-clockwise order are culled
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.CullFaces.None">
            <summary>
            No faces are culled
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.SceneTypes">
            <summary>
            Scene types, used to determine, where a node is hosted.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.SceneTypes.Global">
            <summary>
            The global scene holds the main shapes and plots and is shareable between drivers/controls.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.SceneTypes.Local">
            <summary>
            Adresses the local part of a scene, which is 'private' to every driver
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILBackBuffer.Stride">
            <summary>
            storage between adjacent pixels of two rows in number of pixels; valid only when the buffer is locked!
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILCamera">
            <summary>
            This class specifies the camera's positioning and orientation
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILGroup">
            <summary>
            ILGroup holds and manages arbitrary nodes and serves as base class for custom visual object implementations
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILNode.GetRoot">
            <summary>
            Find the root of the current node in this scene
            </summary>
            <returns>The root node of the current scene node or the node itself, if it is a group node</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILNode.Copy">
            <summary>
            copy of the structure of this node, for general use in the tree description
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILNode.BeginVisit(ILNumerics.Drawing.ILRenderParameter)">
            <summary>
            handle transformations before visiting the node 
            </summary>
            <param name="parameter">render parameter instance</param>
            <returns>true if the node requires further processing, false: skip this node for the current rendering attempt</returns>
        </member>
        <member name="E:ILNumerics.Drawing.ILNode.PropertyChanged">
            <summary>
            Fires on any property state changes
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILNode.Disposing">
            <summary>
            Fires, before the node is getting disposed
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILNode.MouseEnter">
            <summary>
            Fires when the mouse enters the object region
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILNode.MouseLeave">
            <summary>
            Fires when the mouse leaves the object region
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILNode.MouseClick">
            <summary>
            Fires when the object is clicked
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILNode.MouseDoubleClick">
            <summary>
            Fires when the object was double clicked
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILNode.MouseDown">
            <summary>
            Fires when a mouse button was pressed over the object
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILNode.MouseUp">
            <summary>
            Fires when a mouse button was released over the object
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILNode.MouseMove">
            <summary>
            Fires when the mouse was moved over the object
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILNode.MouseWheel">
            <summary>
            Fires when the mouse wheel was moved over the object
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILNode.SourceID">
            <summary>
            The source node ID when this node was created by Copy()
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILNode.SynchedVersion">
            <summary>
            The version of the sync source from the last synchronization.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILNode.Version">
            <summary>
            Modification version of this node, gets incremented at every change
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILNode.PickingID">
            <summary>
            If set to a valid shape ID, that shape will be marked in picking operations insted of this shape. 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILNode.Parent">
            <summary>
            Get the parent of this node or null, if this node is a root node
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILNode.Visible">
            <summary>
            Determines, if this node is visible or sets the visible state
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILNode.Tag">
            <summary>
            Object tag used to identify the node within the scene 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILNode.ID">
            <summary>
            Unique ID for the node within the scene
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILNode.Marked">
            <summary>
            Marked state for the node
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILNode.Markable">
            <summary>
            Determines, if this node can be marked by the user
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.#ctor(System.Object,System.Nullable{ILNumerics.Drawing.Vector3},System.Double,System.Nullable{ILNumerics.Drawing.Vector3},System.Nullable{ILNumerics.Drawing.Vector3})">
            <summary>
            Creates a new empty group
            </summary>
            <param name="tag">tag object, used to identify the node within the scene</param>
            <param name="angle">rotation angle for groups children</param>
            <param name="rotateAxis">rotation axis for groups children</param>
            <param name="scale">X, Y and Z scale for groups children</param>
            <param name="translate">translation for groups children</param>
            <remarks>If specified, the transformations are applied in that order: scale, translate, rotate.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.#ctor(ILNumerics.Drawing.ILGroup)">
            <summary>
             create a new group as shallow copy of a subtree, shared buffers
            </summary>
            <param name="source">source subtree</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Find(System.Object,System.Nullable{ILNumerics.Drawing.Primitives})">
            <summary>
            Searches the subtree for nodes with matching tag and (optional) primitive type
            </summary>
            <param name="tag">tag filter</param>
            <param name="kind">kind (optional)</param>
            <returns>collection of matching nodes</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.First``1(System.Object,System.Predicate{``0})">
            <summary>
            Gets first node with matching criteria from subtree
            </summary>
            <typeparam name="T">node type to filter for</typeparam>
            <param name="tag">tag filter (optional); if omitted, all tags are accepted</param>
            <param name="predicate">arbitrary predicate function (optional); if omitted, all nodes are accepted</param>
            <returns>first node, which matches all given criteria</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Find``1(System.Object,System.Predicate{``0})">
            <summary>
            Searches the subtree for all nodes with matching criteria
            </summary>
            <typeparam name="T">node type to filter for</typeparam>
            <param name="tag">tag filter (optional); if omitted, all tags are accepted</param>
            <param name="predicate">arbitrary predicate function (optional); if omitted, all nodes are accepted</param>
            <returns>all nodes, with matching criteria or null</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.FirstUp``1(System.Object,System.Predicate{``0})">
            <summary>
            Finds a group node on the path up to root
            </summary>
            <typeparam name="T">The concrete type of the node</typeparam>
            <param name="key">tag filter, leave null to match all tags</param>
            <param name="predicate">arbitrary predicate, leave null to match any node</param>
            <returns>the first node matching the filter creteria or null, if none exists</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.FindById``1(System.Int32)">
            <summary>
            Finds a typed node in this subtree, filter by ID 
            </summary>
            <param name="id">ID filter</param>
            <returns>matching node or null</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Configure(System.Boolean,System.Boolean)">
            <summary>
            Configure the subtree after changes to any buffer
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Dispose">
            <summary>
            Dispose the complete subtree (this is rarely needed)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Rotate(ILNumerics.Drawing.Quaternion)">
            <summary>
            Rotate this subtree by quaternion
            </summary>
            <param name="offset">Quaternion, describing the target orientation</param>
            <returns>this group</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Rotate(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Rotate this subtree by rotation axis and angle
            </summary>
            <param name="directionX">rotation axis X coordinate</param>
            <param name="directionY">rotation axis Y coordinate</param>
            <param name="directionZ">rotation axis Z coordinate</param>
            <param name="angle">angle in radians</param>
            <returns>this group</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Rotate(ILNumerics.Drawing.Vector3,System.Double)">
            <summary>
            Rotate this subtree by rotation axis and angle
            </summary>
            <param name="direction">rotation axis</param>
            <param name="angle">angle in radians</param>
            <returns>this group</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Translate(System.Double,System.Double,System.Double)">
            <summary>
            Translates this subtree
            </summary>
            <param name="x">Offset in X direction</param>
            <param name="y">Offset in Y direction</param>
            <param name="z">Offset in Z direction</param>
            <returns>this group</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Translate(ILNumerics.Drawing.Vector3)">
            <summary>
            Translates this subtree
            </summary>
            <param name="vec">Offset vector</param>
            <returns>this group</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Scale(System.Double,System.Double,System.Double)">
            <summary>
            Scales this subtree
            </summary>
            <param name="x">scale factor in X direction</param>
            <param name="y">scale factor in Y direction</param>
            <param name="z">scale factor in Z direction</param>
            <returns>this group</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Scale(ILNumerics.Drawing.Vector3)">
            <summary>
            Scales this subtree
            </summary>
            <param name="vec">vector with scale factors in X, Y and Z direction</param>
            <returns>this group</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.BeginVisit(ILNumerics.Drawing.ILRenderParameter)">
            <summary>
            pushes the transform, alpha and color overrides of this node to the render parameter stack
            </summary>
            <param name="parameter"></param>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.EndVisit(ILNumerics.Drawing.ILRenderParameter)">
            <summary>
            pops the render parameter from render parameter stack
            </summary>
            <param name="parameter"></param>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Add(ILNumerics.Drawing.ILNode)">
            <summary>
            Add a node to the end of this groups child collection
            </summary>
            <typeparam name="T">node type</typeparam>
            <param name="node">node object</param>
            <param name="tag">tag for the newly added node (optional)</param>
            <param name="shareBuffers">[optional] if adding creates a clone, determines, if its buffer are shared. Default: true</param>
            <returns>the newly added node</returns>
            <remarks>If the <paramref name="node"/> given is already used within any scene graph a (shallow, lazy) copy is made and the copy is added to the group instead. Such copies are 
            individually configurable in most scalar properties. However, they (by default) share the buffer sets - i.e. vertices, indices, normals and interpolating colors buffers.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Add``1(``0,System.Object,System.Boolean)">
            <summary>
            Add a node to the end of this groups child collection
            </summary>
            <typeparam name="T">node type</typeparam>
            <param name="node">node object</param>
            <param name="tag">tag for the newly added node (optional)</param>
            <param name="shareBuffers">[optional] if adding creates a clone, determines, if its buffer are shared. Default: true</param>
            <returns>the newly added node</returns>
            <remarks>If the <paramref name="node"/> given is already used within any scene graph a (shallow, lazy) copy is made and the copy is added to the group instead. Such copies are 
            individually configurable in most scalar properties. However, they (by default) share the buffer sets - i.e. vertices, indices, normals and interpolating colors buffers.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Insert``1(System.Int32,``0,System.Object)">
            <summary>
            Insert a node into the child collection at predefined index 
            </summary>
            <typeparam name="T">node type</typeparam>
            <param name="index">index to place the new node at</param>
            <param name="node">node object</param>
            <param name="tag">tag for the newly added node (optional)</param>
            <returns>the newly added node</returns>
            <remarks>If the <paramref name="node"/> given is already used within any scene graph a (shallow, lazy) copy is made and the copy is added to the group instead. Such copies are 
            individually configurable in most scalar properties. However, they (by default) share the buffer sets - i.e. vertices, indices, normals and interpolating colors buffers.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Remove(ILNumerics.Drawing.ILNode)">
            <summary>
            Remove a node from this subtree
            </summary>
            <param name="node">node to remove</param>
            <returns>true if the node was found and successfully removed, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Detach">
            <summary>
            Detach all shapes from this subtree for individual configurations
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.GetLimits(System.Nullable{ILNumerics.Drawing.Vector3})">
            <summary>
            Compute the 3D limits (extent) of this subtree
            </summary>
            <param name="lowerBound">The lower limit of the search.</param>
            <returns>Limits of the bounding box of all nodes in this subtree</returns>
            <remarks>The function walks the complete subtree and computes the extent for every shape contained. 
            Group node transformations are taken into account and the limits of the bounding box for all nodes is returned.
            <para>For every axis, only those positions 
            from shape vertices are considered, which lay <i>above</i> the bound determined by <paramref name="lowerBound"/>. 
            This parameter is usefull for working with logarithmic axes scales. If ommited, all data are taken into account [Default].</para></remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.ToString">
            <summary>
            String representation of the group node
            </summary>
            <returns>string summarizing this group node</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILGroup.Copy">
            <summary>
            Create a shallow copy of this subtree
            </summary>
            <returns>copy of this subtree</returns>
        </member>
        <member name="P:ILNumerics.Drawing.ILGroup.InternalChildren">
            <summary>
            Access to direct children, safe even for derived classes
            </summary>
            <remarks>This property gives safe access to the internal node collection of children. Since a derived class 
            may change the Children property semantic, this property ensures the access to the original collection.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILGroup.Target">
            <summary>
            If set, determines the target for rendering: world (3D) or screen (2D) on top. Default: not set (derive from parent)
            </summary>
            <remarks>Screen components are drawn <b>on top</b> of World (3D) content. Per default, nodes derive the target setting from their parent. The root node of a scene graph is set to World (3D), so by default, all nodes are drawn as World targets.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILGroup.Clipping">
            <summary>
            Gets all 6 available clipping planes for the group or sets it. Null: derive clipping from parent node (default)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILGroup.Transform">
            <summary>
            [4x4] matrix with the affine transforms which this node applies to all children
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILGroup.Children">
            <summary>
            Collection of child for this group
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILGroup.Childs">
            <summary>
            Collection of child for this group
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILGroup.Alpha">
            <summary>
            Alpha value, range [0...1],  if set, this value modifies the alpha values for ALL nodes of this subtree. Use for blend effects only!
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILGroup.ColorOverride">
            <summary>
            If set, this color will override all individual colors in this subtree
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILCamera.Default">
            <summary>
            Default camera instance 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.OnPropertyChanged(System.String)">
            <summary>
            Fires a Changed event
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.#ctor(ILNumerics.Drawing.ILCamera)">
            <summary>
            Create new camera with settings from existing camera
            </summary>
            <param name="source">source camera</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.#ctor(System.Object)">
            <summary>
            Creates a new camera
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.ToString">
            <summary>
            Convert all camera parameter to string
            </summary>
            <returns>string display: polar coordinates, position, lookat points and top vector</returns>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.ScreenRect">
            <summary>
            Screen rectangle identifying the area this object is using inside its container (0..1/0..1, get/set)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.IsGlobal">
            <summary>
            Determine if this camera is acting on the global scene. Changes made to one driver will affect all instances of the same scene in all drivers. 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Projection">
            <summary>
            Get the type of projection (orthographic/ perspective) or sets it 
            </summary> 
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.ZNear">
            <summary>
            Near clipping limit (Z axis) 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.ZFar">
            <summary>
            Far clipping limit (Z axis)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.LookAt">
            <summary>
            point, the camera is aiming at (world coords)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Position">
            <summary>
            get/set camera position, absolute cartesian coordinates
            </summary>
            <remarks>Keep in mind, the angle for phi points towards negative Y axis! The cartesian property 
            <paramref name="Position"/> handles the camera position in absolute world coordinates, while the 
            polar coordinates (Rho, Phi, Distance) supress the camera position by means of coordinates 
            relative to the LookAt point (i.e. usually the center of the viewing cube)!</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Top">
            <summary>
            orientation of the camera, normalized, readonly
            </summary>
            <remarks>This vector is readonly always points 'upwards'.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.m_phiDebugDisp">
            <summary>
            debugger helper: display phi in degrees (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.m_rhoDebugDisp">
            <summary>
            debugger helper: display rho in degrees
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Polar">
            <summary>
            spherical coordinates relative to the look at point
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Is2DView">
            <summary>
            true, when looking from top on the un-rotated scene (common for 2D plots)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.AspectRatioMode">
            <summary>
            Determines, if objects keep their shape, regardless from the windows aspect ratio. Default: keep shape
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.FieldOfView">
            <summary>
            Determines the field of view for perspective projection. Small: more fish eye effect, large: more overview. Default: 10
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.PositionTransform">
            <summary>
            Get position transform matrix (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.ProjectionTransform">
            <summary>
            Get projection transform matrix (readonly)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILTextureStorage">
            <summary>
            The class provides texture storage for a single class of texures (e.g. one font)
            </summary>
            <remarks>The texture items are stored in a single texture sheet 
            and organized via a simple binary tree.</remarks>
        </member>
        <member name="F:ILNumerics.Drawing.ILTextureStorage.m_disposed">
            <summary>
             cache, which texture has been bound at last
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILTextureStorage.#ctor(System.Drawing.Size)">
            <summary>
            construct new storage
            </summary>
            <param name="height">absolute height (permanent)</param>
            <param name="width">absolute width (permanent)</param>
            <remarks>Suggested size parameter will be increased to the next power of two.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILTextureStorage.Get(System.String)">
            <summary>
            fetch texture item from storage
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILTextureStorage.TryGetTextureItem(System.String,ILNumerics.Drawing.ILTextureData@)">
            <summary>
            try to fetch item by key
            </summary>
            <param name="key">unique key</param>
            <param name="item">[output] item found</param>
            <returns>true: item was found, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILTextureStorage.Exists(System.String)">
            <summary>
            test, if a key exists in the texture storage
            </summary>
            <param name="key">unique key to be tested for</param>
            <returns>true if a texture item associated with that key exists, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILTextureStorage.Store(System.String,System.Drawing.Bitmap,System.Drawing.Rectangle,System.Drawing.RectangleF,System.Drawing.SizeF)">
            <summary>
            store bitmap into texture sheet
            </summary>
            <param name="key">unique key for item</param>
            <param name="data">item bitmap data</param>
            <param name="textureStorageSize">used rectangle in data bitmap</param>
            <param name="itemScreenSize">actual size of the glyph on screen</param>
            <param name="textureGlyphRect">actual size of the glyph within the texture</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILTextureStorage.InitTexture">
            <summary>
            initialize texture sheet 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILTextureStorage.Store(System.Drawing.Bitmap,System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            store item in texture sheet in GL
            </summary>
            <param name="data">new item bitmap data</param>
            <param name="location">area in bitmap data to be stored</param>
            <param name="rect">rectangle specifying area to store the data into,
            texture coords: range from 0...1.0</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILTextureStorage.MakeCurrent">
            <summary>
            select the texture storage as current in the GL
            </summary>
            <remarks>Calling this function before an storage / render operation is 
            obligatory in specific rendering machines (e.g. OpenGL). For GL's, where 
            it is not neccessary, the implementation must ignore any calls to this function.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILTextureStorage.Dispose">
            <summary>
            Dispose off any texture storage's ressources
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILTextureStorage.Dispose(System.Boolean)">
            <summary>
            Dispose off manually
            </summary>
            <param name="manual"></param>
            <remarks>The true disposing is done in the concrete implementation.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILTextureStorage.Finalize">
            <summary>
            Finalizer, disposing ressources
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILTextureStorage.Cleared">
            <summary>
            Fires, when the managed texture sheets are cleared. Registrars must rebuild needed items afterwards
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILTextureStorage.Height">
            <summary>
            overall height of the internal texture sheet
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILTextureStorage.Width">
            <summary>
            current width of the internal texture sheet
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILTextureStorage.Node">
            <summary>
            class representing a binary tree, used to manage the items on the texture sheet
            </summary>
            <remarks>This code is a slightly modified version of the OpenTK.Utilities framework
            TextPrinter/TextureStorage classes. See http://opentk.com for details.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILHelper.EnsurePlotCubeExtend(System.Single,System.Single@,System.Single@)">
            <summary>
            ensures a non-zero range between min .. max, according to a and floating point options
            </summary>
            <param name="a">base number</param>
            <param name="min">min range</param>
            <param name="max">max range</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILHelper.SortIndices(ILNumerics.Drawing.ILShape,ILNumerics.Drawing.Matrix4)">
            <summary>
            sort the shape elements for transparent rendering
            </summary>
            <param name="shape">shape</param>
            <param name="transform">model to clip transform</param>
        </member>
        <member name="M:ILNumerics.Drawing.Lighting.ILMaterial.#ctor">
            <summary>
            construct new material object, initialize default values
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Lighting.ILMaterial.LightingEnabled">
            <summary>
            Switch light support for the material/shape on/off. Default: on
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Lighting.ILMaterial.Shininess">
            <summary>
            shape/intensity for specular reflection, range: 1...128
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Lighting.ILMaterial.Specular">
            <summary>
            color for specular reflection
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Lighting.ILMaterial.Emission">
            <summary>
            color for emissive reflection
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILPreprocessedShape.RecallStateFor(System.Action{ILNumerics.Drawing.ILDrawable,ILNumerics.Drawing.ILRenderParameter},ILNumerics.Drawing.ILRenderParameter)">
            <summary>
            temporarly recall the state stored in this instance forr running the specified action 
            </summary>
            <param name="action">action to run in the stored state</param>
            <param name="renderParams">current render parameters</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILRenderParameter.PushClipping(ILNumerics.Drawing.ILClipParams,System.Boolean)">
            <summary>
            takes model coord clipping planes, stores them in camera coords
            </summary>
            <param name="clipping"></param>
        </member>
        <member name="M:ILNumerics.Drawing.ILRenderParameter.GetClipping(System.Int32)">
            <summary>
            returns custom clip planes from stack (if any) or frustum planes  
            </summary>
            <param name="planeID">plane index: 0..5 -> frustum planes; 6 ... 12 (currently) -> custom planes from stack</param>
            <returns></returns>
        </member>
        <member name="P:ILNumerics.Drawing.ILRenderParameter.FrustumPlanes">
            <summary>
            Frustum planes for the current projection matrix, camera coords
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILSVGDriver.#ctor(System.IO.Stream,System.Int32,System.Int32,ILNumerics.Drawing.ILScene,System.Nullable{System.Drawing.Color})">
            <summary>
            Create SVG driver 
            </summary>
            <param name="outStream">output stream to write SVG data into</param>
            <param name="width">the SVG artwork width</param>
            <param name="height">the SVG artwork height</param>
            <param name="scene">[optional] the scene to render. If null: a new scene will be created</param>
            <param name="BackColor">[optional] background color. On null: System.Drawing.Color.White is used.</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILSVGDriver.RenderTriangleSVG(ILNumerics.Drawing.ILRenderParameter,System.Text.StringBuilder,ILNumerics.Drawing.Triangle,ILNumerics.Drawing.ILTriangles)">
            <summary>
            compute ligthing and do recursive subdivisioning for a single triangle for rendering
            </summary>
            <param name="parameters">current render parameters</param>
            <param name="sb">string builder for writing output to</param>
            <param name="tri">triangle</param>
            <param name="triangles">original triangles shape (for color computations)</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILOGLDriver.GetGLViewport(System.Drawing.RectangleF)">
            <summary>
            get the _OpenGL_ viewport according to ClientSize, Rectangle and innerRect
            </summary>
            <param name="innerRect"></param>
            <returns></returns>
        </member>
        <member name="P:ILNumerics.Drawing.ILOGLDriver.ActualVersion">
            <summary>
            Get the actual version of the current OpenGL graphics context
            </summary>
            <remarks><para>The actual version may differs from the requested version if the graphics card / driver does not support the version requested. 
            This provides an efficient way of checking the actual version and exit rendering in a failsafe, deterministic way. 
            </para>
            <para>Querying this property successfully requires an OpenGL context to be created and set current. Therefore, if the property is queried too early, 
            this requirement may not be met yet. A version number of 0.0 is returned in this case.</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILOGLDriver.GLViewport">
            <summary>
            get/set the _OpenGL_ viewport, expects rectangles origin at UPPER left corner 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILOGLLightsBuffer">
            <summary>
            an uniform buffer object, holds and synchronizes all light data 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILOGLTextureStorage">
            <summary>
            OpenGL implementation of ILTextureStorage
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILOGLTextureStorage.MakeCurrent">
            <summary>
            Select this storage to be current in GL
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILOGLTextureStorage.InitTexture">
            <summary>
            initialize texture sheet 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILOGLTextureStorage.Store(System.Drawing.Bitmap,System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            store item in texture sheet in GL
            </summary>
            <param name="bmp">new item bitmap data, ARGB format</param>
            <param name="bmpRect">rectangle used in bitmap</param>
            <param name="texRect">rectangle specifying area to store the data into the texture sheet, 
            integer pixels coords: range from 0...m_width|m_height (e.g. '512')</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILOGLTextureStorage.Dispose(System.Boolean)">
            <summary>
            dispose off the texture storage's ressources
            </summary>
            <param name="manual"></param>
        </member>
        <member name="M:ILNumerics.Drawing.ILOGLProgram.CreateFor(ILNumerics.Drawing.ILOGLShape,ILNumerics.Drawing.ILRenderParameter)">
            <summary>
            Create or reuse program for a specific shape. 
            </summary>
            <param name="shape">the shape</param>
            <returns>true: program was newly created, false: program was reused (no need to recreate VAO)</returns>
        </member>
        <member name="T:ILNumerics.Drawing.IILTextInterpreter">
            <summary>
            interface for classes capable of transforming text 
            expressions into visual output representation
            </summary>
            <seealso cref="!:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter"/>
        </member>
        <member name="M:ILNumerics.Drawing.IILTextInterpreter.Transform(ILNumerics.Drawing.ILLabel,ILNumerics.Drawing.ILTextureStorage)">
            <summary>
            transform the label element into bitmap representation for rendering
            </summary>
            <remarks>The implementations changes the (texture) representation of the label 
            into a render queue.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.ILHashCreator">
            <summary>
            Helper class used to create hashes for renderable items (currently text only)
            </summary>
            <remarks>This class should be used to retrieve an (unique) key for any 
            renderable items used in ILNumerics.Drawing renderer classes. This way on can 
            ensure not to create hash conflicts between different cached items.
             </remarks>
        </member>
        <!-- Ung端ltiger XML-Kommentar wurde f端r den Member "M:ILNumerics.Drawing.ILHashCreator.Hash(System.String,System.Drawing.Font)" ignoriert -->
        <member name="T:ILNumerics.Drawing.ILRenderQueue">
            <summary>
            the class collects renderable items which define 
            the graphical output for a render expression
            </summary>
            <remarks>ILRenderQueues are semi-immutable. Instances - once created - can only be cleared and 
            re-created, but not altered. Therefore, they keep the size of the output cached over their livetime.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILRenderQueue.#ctor(System.String,System.Collections.Generic.List{ILNumerics.Drawing.ILRenderQueueItem},System.Drawing.SizeF)">
            <summary>
             constructor, creates a new render queue with content
            </summary>
            <param name="expression">expression, which led to this queue</param>
            <param name="queue">prepared queue</param>
            <param name="size">size of content after rendering</param>
        </member>
        <member name="P:ILNumerics.Drawing.ILRenderQueue.Size">
            <summary>
            overall size of content of this render queue in pixels
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILRenderQueue.Expression">
            <summary>
            Expression which led to this queue
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILRenderQueueItem">
            <summary>
            Single item with rendering instructions, used in ILRenderQueues
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderQueueItem.Key">
            <summary>
            unique key, identifies the item in the render cache
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderQueueItem.Rect">
            <summary>
            Layout rectangle to render the item into, includes size and offsets for sub/superscript rendering
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderQueueItem.Color">
            <summary>
            Individual color for the item 
            </summary>
            <remarks>If this property is set to Color.Empty, the item will 
            be drawn with the color assigned to hosting element.</remarks>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderQueueItem.TextureRect">
            <summary>
            [optional] Area of the item within the corresponding texture storage
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderQueueItem.Text">
            <summary>
            The transformed text of the item 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILRenderQueueItem.#ctor(System.String,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.Color)">
            <summary>
            construct a new ILRenderQueueItem
            </summary>
            <param name="key">unique key</param>
            <param name="offset">offset</param>
            <param name="color">individual color</param>
        </member>
        <member name="T:ILNumerics.Drawing.ILSimpleInterpreter">
            <summary>
            Transforms characters into bitmaps (1:1)
            </summary>
            <remarks>this is the base class for most IILTextInterpreter implementations</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILSimpleInterpreter.#ctor">
            <summary>
            create a new instance of this text interpreter
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILSimpleInterpreter.TransformItem(System.String,System.Drawing.Font,System.Drawing.Rectangle@,System.Drawing.RectangleF@,System.Drawing.SizeF@,System.Boolean)">
            <summary>
            Render a string onto a bitmap and measure exact size
            </summary>
            <param name="item">item to be rendered</param>
            <param name="font">font used for rendering</param>
            <param name="textureStorageSize">[output] size of the rendered item</param>
            <returns>bitmap containing the item</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILSimpleInterpreter.transformItem(System.String,System.Drawing.Font,System.Drawing.Rectangle@,System.Drawing.RectangleF@,System.Drawing.SizeF@,System.Boolean)">
            <summary>
            Render a string onto a bitmap and measure exact size
            </summary>
            <param name="item">item to be rendered</param>
            <param name="font">font used for rendering</param>
            <param name="textureStorageSize">[output] size of the rendered item</param>
            <returns>bitmap containing the item</returns>
        </member>
        <member name="T:ILNumerics.Drawing.ILSimpleTexInterpreter">
            <summary>
            Simple, (partial) tex symbol interpreter 
            </summary>
            <remarks>this is the default interpreter for all ILLabelingElements</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILSimpleTexInterpreter.#ctor">
            <summary>
            create a new instance of a simple text interpreter
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILSimpleTexInterpreter.matchSymbol(System.String,System.Int32@)">
            <summary>
            extract TextSymbol from text 
            </summary>
            <param name="text">text to extract symbol from</param>
            <param name="pos">current text character position</param>
            <returns>one of TextSymbol enumeration values</returns>
            <remarks>if one symbol was found, its enum representation is 
            returned and pos is increased by the corresponding number of 
            characters. If no matching symbol was found, pos is not altered 
            and TextSymbols.nothing will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILSimpleTexInterpreter.TranslateSymbol(ILNumerics.Drawing.ILSimpleTexInterpreter.TextSymbols)">
            <summary>
             translates TextSymbol enum value to unicode character
            </summary>
            <param name="symbol">enum representation</param>
            <returns>unicode character</returns>
            <remarks>refers to: http://www.decodeunicode.org/ (e.g.)</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.ILSimpleTexInterpreter.ILKeywords">
            <summary>
            available keywords, supported by this IILInterpreter
            </summary>
            <remarks><para>The static instance ILSimpleTexInterpreter. These properties give the option 
            to alter the configuring keywords for font styles etc.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILSimpleTexInterpreter.ILKeywords.Fontname">
            <summary>
            placeholder for font name control sequence
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILSimpleTexInterpreter.ILKeywords.Fontsize">
            <summary>
            placeholder for font size control sequence
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILSimpleTexInterpreter.ILKeywords.Italic">
            <summary>
            placeholder for italic font control sequence
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILSimpleTexInterpreter.ILKeywords.Bold">
            <summary>
            placeholder for bold font control sequence
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILSimpleTexInterpreter.ILKeywords.Color">
            <summary>
            placeholder for font color control sequence
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILSimpleTexInterpreter.ILKeywords.Reset">
            <summary>
            placeholder for text control sequence 'reset to initial value' 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILSimpleTexInterpreter.TextSymbols">
            <summary>
            all symbols (e.g. \\Alpha ) which are supported by this interpreter
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILTextureData">
            <summary>
            class encapsulating texture item definitions
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILTextureData.TextureRectangle">
            <summary>
            the item's rectangle area in the texture sheet (texture coordinates) 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILTextureData.Width">
            <summary>
            Width of the stored item in pixels
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILTextureData.Height">
            <summary>
            Height of the stored item in pixels
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ChangeQueueActions">
            <summary>
            Valid change queue actions
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILLabeledTickProvider">
            <summary>
            tick provider function delegate definition
            </summary>
            <param name="min">minimum axis limit</param>
            <param name="max">maximum axis limit</param>
            <param name="maxCount">maximum number of ticks to create</param>
            <returns>list of tick position to be drawn</returns>
            <remarks>User defined tick providers must fulfill this delegates signature. 
            </remarks>
        </member>
        <member name="T:ILNumerics.Drawing.ILClippingDataChangedEvent">
            <summary>
            Occours if the clipping data for an subfigure have changed
            </summary>
            <param name="sender">object which changed the data</param>
            <param name="e">arguments containing the new clipping data</param>
        </member>
        <member name="T:ILNumerics.Drawing.MeasureTextDelegate">
            <summary>
            delegate used to measure text, device dependent
            </summary>
            <param name="text">text to be measured</param>
            <param name="font">Font used for rendering</param>
            <returns>Size in screen coords</returns>
        </member>
        <member name="T:ILNumerics.Drawing.ClippingChangedEventArgs">
            <summary>
            Arguments on ClippingChanged events
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ClippingChangedEventArgs.#ctor(ILNumerics.Drawing.ILLimits)">
            <summary>
            Creates a new ClippingChangedEventArgs object
            </summary>
            <param name="clippingData"></param>
        </member>
        <member name="F:ILNumerics.Drawing.ClippingChangedEventArgs.ClippingData">
            <summary>
            The current clipping data
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILGraphicsDeviceResetEvent">
            <summary>
            occours if a graphics device has been reset by the underlying graphics framework
            </summary>
            <param name="sender">objects who hosts the graphics device</param>
            <param name="eventArgs"></param>
        </member>
        <member name="T:ILNumerics.Drawing.ILGraphicsDeviceCreatedEvent">
            <summary>
            occours if a graphics device has been (re)created by an output panel
            </summary>
            <param name="sender">objects who hosts the graphics device</param>
            <param name="eventArgs"></param>
        </member>
        <member name="T:ILNumerics.Drawing.ILGraphChangedEventArgs">
            <summary>
            arguments to communicate changes on graphs 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILGraphChangedEventArgs.Source">
            <summary>
            string description of the changed parameter
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILLabeledTickAddingArgs">
            <summary>
            Event handler handling LabeledTickAdding events 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.LabeledTickAddingHandler">
            <summary>
            Delegate definition for function handling LabeledTickAdding events
            </summary>
            <param name="sender">the sender of the event (e.g. ILTickCollection)</param>
            <param name="args">arguments </param>
        </member>
        <member name="T:ILNumerics.Drawing.ILAxisChangedEventArgs">
            <summary>
            Event arguments for axis changed events
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILAxisChangedEventArgs.AxisName">
            <summary>
            Name of changed axis (X-,Y-,ZAxis)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxisChangedEventArgs.#ctor(ILNumerics.Drawing.AxisNames)">
            <summary>
            construct a new instance 
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:ILNumerics.Drawing.AxisChangedEventHandler">
            <summary>
            delegate for functions handling AxisChanged events
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:ILNumerics.Drawing.ILLimits">
            <summary>
            Class holding and managing limits for a 3 dimensional cube
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILLimits.OnChange">
            <summary>
            called if the limits have changed
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILLimits.EventingSuspend">
            <summary>
            suspend the firing of events until EventingResume has been called
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILLimits.EventingResume">
            <summary>
            Resume previously suspended eventing. Start sending events again.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILLimits.EventingStart">
            <summary>
            enable eventing, discarding pending events
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILLimits.Update(ILNumerics.Drawing.ILLimits)">
            <summary>
            update ranges for this object with union of both ranges. 
            </summary>
            <param name="clipData">clipping ranges to create union with</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILLimits.Update(ILNumerics.Drawing.Vector3,System.Int32)">
            <summary>
            update ranges for this object with point coords for specific axes
            </summary>
            <param name="point">point with coords to update ranges with</param>
            <param name="updateBitFlags">bitflag combination to specify axis to be recognized: 1,2,4 -> x,y,z</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILLimits.Update(ILNumerics.Drawing.Vector3,ILNumerics.Drawing.Vector3)">
            <summary>
            update clipping data for this object with union of this and rectangle specified
            </summary>
            <param name="luCorner">left upper corner</param>
            <param name="rbCorner">right lower corner</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILLimits.Set(ILNumerics.Drawing.Vector3,ILNumerics.Drawing.Vector3)">
            <summary>
            Set clipping limits to volume inside the box specified 
            </summary>
            <param name="lunCorner">left-upper-near corner of the volume box</param>
            <param name="rbfCorner">right-bottom-far corner of the volume box</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILLimits.CopyFrom(ILNumerics.Drawing.ILLimits)">
            <summary>
            copy this from other clipping data
            </summary>
            <param name="m_clippingData"></param>
        </member>
        <member name="M:ILNumerics.Drawing.ILLimits.Clone">
            <summary>
            creates clone of this clipping data
            </summary>
            <returns>clone</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILLimits.op_Equality(ILNumerics.Drawing.ILLimits,ILNumerics.Drawing.ILLimits)">
            <summary>
            Equalty operator overload, true if both cubes span the same region in 3D space 
            </summary>
            <param name="limit1">cube 1</param>
            <param name="limit2">cube 2</param>
            <returns>true if both cubes span the same 3D space, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILLimits.op_Inequality(ILNumerics.Drawing.ILLimits,ILNumerics.Drawing.ILLimits)">
            <summary>
            unequalty operator
            </summary>
            <param name="limit1">cube 1</param>
            <param name="limit2">cube 2</param>
            <returns>false if both cubes span the same 3D space, true otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILLimits.GetHashCode">
            <summary>
            Returns hash code for this ILClippingData
            </summary>
            <returns>hash code</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILLimits.Equals(System.Object)">
            <summary>
            Compares to cube objects
            </summary>
            <param name="obj"></param>
            <returns>true if obj references this class instance, false otherwise</returns>
        </member>
        <member name="E:ILNumerics.Drawing.ILLimits.Changed">
            <summary>
            fires if the data range have changed
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLimits.SphereRadius">
            <summary>
            the radius of a sphere tightly enclosing the box determined by this clipping data limits (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLimits.XMin">
            <summary>
            minimum value for x axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLimits.YMin">
            <summary>
            minimum value for y axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLimits.ZMin">
            <summary>
            minimum value for z axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLimits.XMax">
            <summary>
            maximum value for x axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLimits.YMax">
            <summary>
            maximum value for y axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLimits.ZMax">
            <summary>
            maximum value for z axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLimits.Min">
            <summary>
            minimum (coordinate)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLimits.Max">
            <summary>
            maximum (coordinate)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLimits.CenterF">
            <summary>
            get center of this clipping range
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLimits.WidthF">
            <summary>
            get width (x-direction) of this clipping range
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLimits.HeightF">
            <summary>
            get height (y-direction) of this clipping range
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLimits.DepthF">
            <summary>
            get depth (z-direction) of this clipping range
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLimits.IsDirty">
            <summary>
            marks the limits as altered, without having fired a changed event yet
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLimits.AllowZeroVolume">
            <summary>
            true: this clipping data always ensures a non-zero volume
            </summary>
            <remarks>'NonZeroVolumne' means, non of Depth,Width nor Heigth are allowed to be zero. If some edge of the cube is set to zero, the class expands this edge by 1 in each direction.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILLimits.IsEmpty">
            <summary>
            Gets if this limits object marks an empty volume [readonly]
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Light">
            <summary>
            Properties for a single light definition
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Light.Position">
            <summary>
            the position in CAMERA coords
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Light.Color">
            <summary>
            Color for the light in ranges of [0...1]
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Light.Intensity">
            <summary>
            possible values: 0 (invisible) ... float.MaxValue
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Quaternion">
            <summary>
            Represents a Quaternion.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.#ctor(ILNumerics.Drawing.Vector3,System.Double)">
            <summary>
            Construct a new Quaternion from vector and w components
            </summary>
            <param name="v">The vector part</param>
            <param name="w">The w part</param>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Construct a new Quaternion
            </summary>
            <param name="x">The x component</param>
            <param name="y">The y component</param>
            <param name="z">The z component</param>
            <param name="w">The w component</param>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.ToAxisAngle(ILNumerics.Drawing.Vector3@,System.Single@)">
            <summary>
            Convert the current quaternion to axis angle representation
            </summary>
            <param name="axis">The resultant axis</param>
            <param name="angle">The resultant angle</param>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.ToAxisAngle">
            <summary>
            Convert this instance to an axis-angle representation.
            </summary>
            <returns>A Vector4 that is the axis-angle representation of this quaternion.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Normalize">
            <summary>
            Scales the Quaternion to unit length.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Conjugate">
            <summary>
            Convert this quaternion to its conjugate
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Quaternion.Identity">
            <summary>
            Defines the identity quaternion.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Add(ILNumerics.Drawing.Quaternion,ILNumerics.Drawing.Quaternion)">
            <summary>
            Add two quaternions
            </summary>
            <param name="left">The first operand</param>
            <param name="right">The second operand</param>
            <returns>The result of the addition</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Add(ILNumerics.Drawing.Quaternion@,ILNumerics.Drawing.Quaternion@,ILNumerics.Drawing.Quaternion@)">
            <summary>
            Add two quaternions
            </summary>
            <param name="left">The first operand</param>
            <param name="right">The second operand</param>
            <param name="result">The result of the addition</param>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Sub(ILNumerics.Drawing.Quaternion,ILNumerics.Drawing.Quaternion)">
            <summary>
            Subtracts two instances.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result of the operation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Sub(ILNumerics.Drawing.Quaternion@,ILNumerics.Drawing.Quaternion@,ILNumerics.Drawing.Quaternion@)">
            <summary>
            Subtracts two instances.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <param name="result">The result of the operation.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Mult(ILNumerics.Drawing.Quaternion,ILNumerics.Drawing.Quaternion)">
            <summary>
            Multiplies two instances.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <returns>A new instance containing the result of the calculation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Mult(ILNumerics.Drawing.Quaternion@,ILNumerics.Drawing.Quaternion@,ILNumerics.Drawing.Quaternion@)">
            <summary>
            Multiplies two instances.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <param name="result">A new instance containing the result of the calculation.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Multiply(ILNumerics.Drawing.Quaternion,ILNumerics.Drawing.Quaternion)">
            <summary>
            Multiplies two instances.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <returns>A new instance containing the result of the calculation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Multiply(ILNumerics.Drawing.Quaternion@,ILNumerics.Drawing.Quaternion@,ILNumerics.Drawing.Quaternion@)">
            <summary>
            Multiplies two instances.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <param name="result">A new instance containing the result of the calculation.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Multiply(ILNumerics.Drawing.Quaternion@,System.Single,ILNumerics.Drawing.Quaternion@)">
            <summary>
            Multiplies an instance by a scalar.
            </summary>
            <param name="quaternion">The instance.</param>
            <param name="scale">The scalar.</param>
            <param name="result">A new instance containing the result of the calculation.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Multiply(ILNumerics.Drawing.Quaternion,System.Single)">
            <summary>
            Multiplies an instance by a scalar.
            </summary>
            <param name="quaternion">The instance.</param>
            <param name="scale">The scalar.</param>
            <returns>A new instance containing the result of the calculation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Conjugate(ILNumerics.Drawing.Quaternion)">
            <summary>
            Get the conjugate of the given quaternion
            </summary>
            <param name="q">The quaternion</param>
            <returns>The conjugate of the given quaternion</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Conjugate(ILNumerics.Drawing.Quaternion@,ILNumerics.Drawing.Quaternion@)">
            <summary>
            Get the conjugate of the given quaternion
            </summary>
            <param name="q">The quaternion</param>
            <param name="result">The conjugate of the given quaternion</param>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Invert(ILNumerics.Drawing.Quaternion)">
            <summary>
            Get the inverse of the given quaternion
            </summary>
            <param name="q">The quaternion to invert</param>
            <returns>The inverse of the given quaternion</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Invert(ILNumerics.Drawing.Quaternion@,ILNumerics.Drawing.Quaternion@)">
            <summary>
            Get the inverse of the given quaternion
            </summary>
            <param name="q">The quaternion to invert</param>
            <param name="result">The inverse of the given quaternion</param>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Normalize(ILNumerics.Drawing.Quaternion)">
            <summary>
            Scale the given quaternion to unit length
            </summary>
            <param name="q">The quaternion to normalize</param>
            <returns>The normalized quaternion</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Normalize(ILNumerics.Drawing.Quaternion@,ILNumerics.Drawing.Quaternion@)">
            <summary>
            Scale the given quaternion to unit length
            </summary>
            <param name="q">The quaternion to normalize</param>
            <param name="result">The normalized quaternion</param>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.FromAxisAngle(ILNumerics.Drawing.Vector3,System.Double)">
            <summary>
            Build a quaternion from the given axis and angle
            </summary>
            <param name="axis">The axis to rotate about</param>
            <param name="angle">The rotation angle in radians</param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Slerp(ILNumerics.Drawing.Quaternion,ILNumerics.Drawing.Quaternion,System.Single)">
            <summary>
            Do Spherical linear interpolation between two quaternions 
            </summary>
            <param name="q1">The first quaternion</param>
            <param name="q2">The second quaternion</param>
            <param name="blend">The blend factor</param>
            <returns>A smooth blend between the given quaternions</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.CreateFromMatrix(ILNumerics.Drawing.Matrix4@,ILNumerics.Drawing.Quaternion@)">
            <summary>
            Build a quaternion from the specified rotation matrix.
            </summary>
            <param name="m">Matrix to translate</param>
            <param name="q">Quaternion result</param>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.CreateFromMatrix(ILNumerics.Drawing.Matrix4@)">
            <summary>
            Build a quaternion from the specified rotation matrix.
            </summary>
            <param name="m">Matrix to translate.</param>
            <returns>A quaternion</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.op_Addition(ILNumerics.Drawing.Quaternion,ILNumerics.Drawing.Quaternion)">
            <summary>
            Adds two instances.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <returns>The result of the calculation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.op_Subtraction(ILNumerics.Drawing.Quaternion,ILNumerics.Drawing.Quaternion)">
            <summary>
            Subtracts two instances.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <returns>The result of the calculation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.op_Multiply(ILNumerics.Drawing.Quaternion,ILNumerics.Drawing.Quaternion)">
            <summary>
            Multiplies two instances.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <returns>The result of the calculation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.op_Multiply(ILNumerics.Drawing.Quaternion,System.Single)">
            <summary>
            Multiplies an instance by a scalar.
            </summary>
            <param name="quaternion">The instance.</param>
            <param name="scale">The scalar.</param>
            <returns>A new instance containing the result of the calculation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.op_Multiply(System.Single,ILNumerics.Drawing.Quaternion)">
            <summary>
            Multiplies an instance by a scalar.
            </summary>
            <param name="quaternion">The instance.</param>
            <param name="scale">The scalar.</param>
            <returns>A new instance containing the result of the calculation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.op_Equality(ILNumerics.Drawing.Quaternion,ILNumerics.Drawing.Quaternion)">
            <summary>
            Compares two instances for equality.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <returns>True, if left equals right; false otherwise.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.op_Inequality(ILNumerics.Drawing.Quaternion,ILNumerics.Drawing.Quaternion)">
            <summary>
            Compares two instances for inequality.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <returns>True, if left does not equal right; false otherwise.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.ToString">
            <summary>
            Returns a System.String that represents the current Quaternion.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Equals(System.Object)">
            <summary>
            Compares this object instance to another object for equality. 
            </summary>
            <param name="other">The other object to be used in the comparison.</param>
            <returns>True if both objects are Quaternions of equal value. Otherwise it returns false.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.GetHashCode">
            <summary>
            Provides the hash code for this object. 
            </summary>
            <returns>A hash code formed from the bitwise XOR of this objects members.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Quaternion.Equals(ILNumerics.Drawing.Quaternion)">
            <summary>
            Compares this Quaternion instance to another Quaternion for equality. 
            </summary>
            <param name="other">The other Quaternion to be used in the comparison.</param>
            <returns>True if both instances are equal; false otherwise.</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Quaternion.Xyz">
            <summary>
            Gets or sets an OpenTK.Vector3 with the X, Y and Z components of this instance.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Quaternion.X">
            <summary>
            Gets or sets the X component of this instance.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Quaternion.Y">
            <summary>
            Gets or sets the Y component of this instance.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Quaternion.Z">
            <summary>
            Gets or sets the Z component of this instance.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Quaternion.W">
            <summary>
            Gets or sets the W component of this instance.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Quaternion.Length">
            <summary>
            Gets the length (magnitude) of the quaternion.
            </summary>
            <seealso cref="P:ILNumerics.Drawing.Quaternion.LengthSquared"/>
        </member>
        <member name="P:ILNumerics.Drawing.Quaternion.LengthSquared">
            <summary>
            Gets the square of the quaternion length (magnitude).
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Vector3">
            <summary>
            single precision 3D point structure
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Vector3.m_x">
            <summary>
            X coordinate
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Vector3.m_y">
            <summary>
            Y coordinate
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Vector3.m_z">
            <summary>
            Z coordinate
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            create vector explicitly
            </summary>
            <param name="x">X coord</param>
            <param name="y">Y coord</param>
            <param name="z">Z coord</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            create explicitly
            </summary>
            <param name="x">X coord</param>
            <param name="y">Y coord</param>
            <param name="z">Z coors</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.ToString">
            <summary>
            convert this point to string representation
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.op_Multiply(System.Single,ILNumerics.Drawing.Vector3)">
            <summary>
            Multiplies an instance by a scalar.
            </summary>
            <param name="scale">The scalar.</param>
            <param name="vec">The instance.</param>
            <returns>The result of the calculation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.Dot(ILNumerics.Drawing.Vector3,ILNumerics.Drawing.Vector3)">
            <summary>
            Calculate the dot (scalar) product of two vectors
            </summary>
            <param name="left">First operand</param>
            <param name="right">Second operand</param>
            <returns>The dot product of the two inputs</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.Pow(ILNumerics.Drawing.Vector3,System.Single)">
            <summary>
            elementwise power for vector elements 
            </summary>
            <param name="vec">vector</param>
            <param name="exp">exponent</param>
            <returns>new vector with elementwise power of 'vec's elements</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.op_Multiply(ILNumerics.Drawing.Matrix4,ILNumerics.Drawing.Vector3)">
            <summary>
            Vector transformation and perspective divide
            </summary>
            <param name="mat">transformation matrix</param>
            <param name="vec">vector</param>
            <returns>transformed vector in normalized device coordinates</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.op_Multiply(ILNumerics.Drawing.Vector3,ILNumerics.Drawing.Matrix4)">
            <summary>
            Vector transformation (left side)
            </summary>
            <param name="mat">transformation matrix</param>
            <param name="vec">vector</param>
            <returns>transformed vector in normalized device coordinates</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.Cross(ILNumerics.Drawing.Vector3,ILNumerics.Drawing.Vector3)">
            <summary>
            cross product
            </summary>
            <param name="a">vector 1</param>
            <param name="b">vector 2</param>
            <returns>normalized cross product between a x b</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.CrossN(ILNumerics.Drawing.Vector3,ILNumerics.Drawing.Vector3)">
            <summary>
            normalized cross product
            </summary>
            <param name="a">vector 1</param>
            <param name="b">vector 2</param>
            <returns>normalized cross product: a x b</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.InverseSqrtFast(System.Single)">
            <summary>
            Returns an approximation of the inverse square root of left number.
            </summary>
            <param name="x">A number.</param>
            <returns>An approximation of the inverse square root of the specified number, with an upper error bound of 0.001</returns>
            <remarks>
            This is an improved implementation of the the method known as Carmack's inverse square root
            which is found in the Quake III source code. This implementation comes from
            http://www.codemaestro.com/reviews/review00000105.html. For the history of this method, see
            http://www.beyond3d.com/content/articles/8/
            </remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.Spin(ILNumerics.Drawing.Vector3,System.Single)">
            <summary>
            rotate the vector, keep length
            </summary>
            <param name="normal">axis as rotation normal</param>
            <param name="angleDeg">angle to move (radian)</param>
            <returns>rotated version of this vector, does not change original vector</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.Normalize">
            <summary>
            Scales the Vector3 to unit length.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.NormalizeFast">
            <summary>
            Scales the Vector3 to approximately unit length.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.Equals(System.Object)">
            <summary>
            Compares obj's coordinate values to those of this class instance
            </summary>
            <param name="obj">Vector3 to compare</param>
            <returns>true, if X,Y and Z coordinates are equal</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.GetHashCode">
            <summary>
            get a hash code for this Vector3 object
            </summary>
            <returns>hash code</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector3.ToXMLAttrString">
            <summary>
            Convert this vector into a short string representation, suitable for xml attribute serialization
            </summary>
            <returns>short string representing this vectors content</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Vector3.X">
            <summary>
            X coordinate
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Vector3.Y">
            <summary>
            Y coordinate
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Vector3.Z">
            <summary>
            Z coordinate
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Vector3.Item(System.Int32)">
            <summary>
            Access to coords by index
            </summary>
            <param name="index">index number: 0=x, 1=y, 2=z</param>
            <returns>float value of coord specified</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Vector3.Length">
            <summary>
            Gets the length (magnitude) of the vector.
            </summary>
            <see cref="P:ILNumerics.Drawing.Vector3.LengthFast"/>
            <seealso cref="P:ILNumerics.Drawing.Vector3.LengthSquared"/>
        </member>
        <member name="P:ILNumerics.Drawing.Vector3.LengthFast">
            <summary>
            Gets an approximation of the vector length (magnitude).
            </summary>
            <remarks>
            This property uses an approximation of the square root function to calculate vector magnitude, with
            an upper error bound of 0.001.
            </remarks>
            <see cref="P:ILNumerics.Drawing.Vector3.Length"/>
            <seealso cref="P:ILNumerics.Drawing.Vector3.LengthSquared"/>
        </member>
        <member name="P:ILNumerics.Drawing.Vector3.LengthSquared">
            <summary>
            Gets the square of the vector length (magnitude).
            </summary>
            <remarks>
            This property avoids the costly square root operation required by the Length property. This makes it more suitable
            for comparisons.
            </remarks>
            <see cref="P:ILNumerics.Drawing.Vector3.Length"/>
            <seealso cref="P:ILNumerics.Drawing.Vector3.LengthFast"/>
        </member>
        <member name="T:ILNumerics.Drawing.Vector4">
            <summary>Represents a 4D vector using four single-precision floating-point numbers.</summary>
            <remarks>
            The Vector4 structure is suitable for interoperation with unmanaged code requiring four consecutive floats.
            </remarks>
        </member>
        <member name="F:ILNumerics.Drawing.Vector4.X">
            <summary>
            The X component of the Vector4.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Vector4.Y">
            <summary>
            The Y component of the Vector4.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Vector4.Z">
            <summary>
            The Z component of the Vector4.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Vector4.W">
            <summary>
            The W component of the Vector4.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Vector4.UnitX">
            <summary>
            Defines a unit-length Vector4 that points towards the X-axis.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Vector4.UnitY">
            <summary>
            Defines a unit-length Vector4 that points towards the Y-axis.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Vector4.UnitZ">
            <summary>
            Defines a unit-length Vector4 that points towards the Z-axis.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Vector4.UnitW">
            <summary>
            Defines a unit-length Vector4 that points towards the W-axis.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Vector4.Zero">
            <summary>
            Defines a zero-length Vector4.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Vector4.One">
            <summary>
            Defines an instance with all components set to 1.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Vector4.SizeInBytes">
            <summary>
            Defines the size of the Vector4 struct in bytes.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructs a new Vector4.
            </summary>
            <param name="x">The x component of the Vector4.</param>
            <param name="y">The y component of the Vector4.</param>
            <param name="z">The z component of the Vector4.</param>
            <param name="w">The w component of the Vector4.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.#ctor(ILNumerics.Drawing.Vector3)">
            <summary>
            Constructs a new Vector4 from the given Vector3.
            </summary>
            <param name="v">The Vector3 to copy components from.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.#ctor(ILNumerics.Drawing.Vector3,System.Single)">
            <summary>
            Constructs a new Vector4 from the specified Vector3 and w component.
            </summary>
            <param name="v">The Vector3 to copy components from.</param>
            <param name="w">The w component of the new Vector4.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.#ctor(ILNumerics.Drawing.Vector4)">
            <summary>
            Constructs a new Vector4 from the given Vector4.
            </summary>
            <param name="v">The Vector4 to copy components from.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Add(ILNumerics.Drawing.Vector4)">
            <summary>Add the Vector passed as parameter to this instance.</summary>
            <param name="right">Right operand. This parameter is only read from.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Add(ILNumerics.Drawing.Vector4@)">
            <summary>Add the Vector passed as parameter to this instance.</summary>
            <param name="right">Right operand. This parameter is only read from.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Sub(ILNumerics.Drawing.Vector4)">
            <summary>Subtract the Vector passed as parameter from this instance.</summary>
            <param name="right">Right operand. This parameter is only read from.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Sub(ILNumerics.Drawing.Vector4@)">
            <summary>Subtract the Vector passed as parameter from this instance.</summary>
            <param name="right">Right operand. This parameter is only read from.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Mult(System.Single)">
            <summary>Multiply this instance by a scalar.</summary>
            <param name="f">Scalar operand.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Div(System.Single)">
            <summary>Divide this instance by a scalar.</summary>
            <param name="f">Scalar operand.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Normalize">
            <summary>
            Scales the Vector4 to unit length.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Scale(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Scales the current Vector4 by the given amounts.
            </summary>
            <param name="sx">The scale of the X component.</param>
            <param name="sy">The scale of the Y component.</param>
            <param name="sz">The scale of the Z component.</param>
            <param name="sw">The scale of the Z component.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Scale(ILNumerics.Drawing.Vector4)">
            <summary>Scales this instance by the given parameter.</summary>
            <param name="scale">The scaling of the individual components.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Scale(ILNumerics.Drawing.Vector4@)">
            <summary>Scales this instance by the given parameter.</summary>
            <param name="scale">The scaling of the individual components.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Sub(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4)">
            <summary>
            Subtract one Vector from another
            </summary>
            <param name="a">First operand</param>
            <param name="b">Second operand</param>
            <returns>Result of subtraction</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Sub(ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@)">
            <summary>
            Subtract one Vector from another
            </summary>
            <param name="a">First operand</param>
            <param name="b">Second operand</param>
            <param name="result">Result of subtraction</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Mult(ILNumerics.Drawing.Vector4,System.Single)">
            <summary>
            Multiply a vector and a scalar
            </summary>
            <param name="a">Vector operand</param>
            <param name="f">Scalar operand</param>
            <returns>Result of the multiplication</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Mult(ILNumerics.Drawing.Vector4@,System.Single,ILNumerics.Drawing.Vector4@)">
            <summary>
            Multiply a vector and a scalar
            </summary>
            <param name="a">Vector operand</param>
            <param name="f">Scalar operand</param>
            <param name="result">Result of the multiplication</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Div(ILNumerics.Drawing.Vector4,System.Single)">
            <summary>
            Divide a vector by a scalar
            </summary>
            <param name="a">Vector operand</param>
            <param name="f">Scalar operand</param>
            <returns>Result of the division</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Div(ILNumerics.Drawing.Vector4@,System.Single,ILNumerics.Drawing.Vector4@)">
            <summary>
            Divide a vector by a scalar
            </summary>
            <param name="a">Vector operand</param>
            <param name="f">Scalar operand</param>
            <param name="result">Result of the division</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Add(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4)">
            <summary>
            Adds two vectors.
            </summary>
            <param name="a">Left operand.</param>
            <param name="b">Right operand.</param>
            <returns>Result of operation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Add(ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@)">
            <summary>
            Adds two vectors.
            </summary>
            <param name="a">Left operand.</param>
            <param name="b">Right operand.</param>
            <param name="result">Result of operation.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Subtract(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4)">
            <summary>
            Subtract one Vector from another
            </summary>
            <param name="a">First operand</param>
            <param name="b">Second operand</param>
            <returns>Result of subtraction</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Subtract(ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@)">
            <summary>
            Subtract one Vector from another
            </summary>
            <param name="a">First operand</param>
            <param name="b">Second operand</param>
            <param name="result">Result of subtraction</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Multiply(ILNumerics.Drawing.Vector4,System.Single)">
            <summary>
            Multiplies a vector by a scalar.
            </summary>
            <param name="vector">Left operand.</param>
            <param name="scale">Right operand.</param>
            <returns>Result of the operation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Multiply(ILNumerics.Drawing.Vector4@,System.Single,ILNumerics.Drawing.Vector4@)">
            <summary>
            Multiplies a vector by a scalar.
            </summary>
            <param name="vector">Left operand.</param>
            <param name="scale">Right operand.</param>
            <param name="result">Result of the operation.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Multiply(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4)">
            <summary>
            Multiplies a vector by the components a vector (scale).
            </summary>
            <param name="vector">Left operand.</param>
            <param name="scale">Right operand.</param>
            <returns>Result of the operation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Multiply(ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@)">
            <summary>
            Multiplies a vector by the components of a vector (scale).
            </summary>
            <param name="vector">Left operand.</param>
            <param name="scale">Right operand.</param>
            <param name="result">Result of the operation.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Divide(ILNumerics.Drawing.Vector4,System.Single)">
            <summary>
            Divides a vector by a scalar.
            </summary>
            <param name="vector">Left operand.</param>
            <param name="scale">Right operand.</param>
            <returns>Result of the operation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Divide(ILNumerics.Drawing.Vector4@,System.Single,ILNumerics.Drawing.Vector4@)">
            <summary>
            Divides a vector by a scalar.
            </summary>
            <param name="vector">Left operand.</param>
            <param name="scale">Right operand.</param>
            <param name="result">Result of the operation.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Divide(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4)">
            <summary>
            Divides a vector by the components of a vector (scale).
            </summary>
            <param name="vector">Left operand.</param>
            <param name="scale">Right operand.</param>
            <returns>Result of the operation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Divide(ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@)">
            <summary>
            Divide a vector by the components of a vector (scale).
            </summary>
            <param name="vector">Left operand.</param>
            <param name="scale">Right operand.</param>
            <param name="result">Result of the operation.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Min(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4)">
            <summary>
            Calculate the component-wise minimum of two vectors
            </summary>
            <param name="a">First operand</param>
            <param name="b">Second operand</param>
            <returns>The component-wise minimum</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Min(ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@)">
            <summary>
            Calculate the component-wise minimum of two vectors
            </summary>
            <param name="a">First operand</param>
            <param name="b">Second operand</param>
            <param name="result">The component-wise minimum</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Max(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4)">
            <summary>
            Calculate the component-wise maximum of two vectors
            </summary>
            <param name="a">First operand</param>
            <param name="b">Second operand</param>
            <returns>The component-wise maximum</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Max(ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@)">
            <summary>
            Calculate the component-wise maximum of two vectors
            </summary>
            <param name="a">First operand</param>
            <param name="b">Second operand</param>
            <param name="result">The component-wise maximum</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Clamp(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4)">
            <summary>
            Clamp a vector to the given minimum and maximum vectors
            </summary>
            <param name="vec">Input vector</param>
            <param name="min">Minimum vector</param>
            <param name="max">Maximum vector</param>
            <returns>The clamped vector</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Clamp(ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@)">
            <summary>
            Clamp a vector to the given minimum and maximum vectors
            </summary>
            <param name="vec">Input vector</param>
            <param name="min">Minimum vector</param>
            <param name="max">Maximum vector</param>
            <param name="result">The clamped vector</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Normalize(ILNumerics.Drawing.Vector4)">
            <summary>
            Scale a vector to unit length
            </summary>
            <param name="vec">The input vector</param>
            <returns>The normalized vector</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Normalize(ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@)">
            <summary>
            Scale a vector to unit length
            </summary>
            <param name="vec">The input vector</param>
            <param name="result">The normalized vector</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Dot(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4)">
            <summary>
            Calculate the dot product of two vectors
            </summary>
            <param name="left">First operand</param>
            <param name="right">Second operand</param>
            <returns>The dot product of the two inputs</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Dot(ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@,System.Single@)">
            <summary>
            Calculate the dot product of two vectors
            </summary>
            <param name="left">First operand</param>
            <param name="right">Second operand</param>
            <param name="result">The dot product of the two inputs</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Lerp(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4,System.Single)">
            <summary>
            Returns a new Vector that is the linear blend of the 2 given Vectors
            </summary>
            <param name="a">First input vector</param>
            <param name="b">Second input vector</param>
            <param name="blend">The blend factor. a when blend=0, b when blend=1.</param>
            <returns>a when blend=0, b when blend=1, and a linear combination otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Lerp(ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@,System.Single,ILNumerics.Drawing.Vector4@)">
            <summary>
            Returns a new Vector that is the linear blend of the 2 given Vectors
            </summary>
            <param name="a">First input vector</param>
            <param name="b">Second input vector</param>
            <param name="blend">The blend factor. a when blend=0, b when blend=1.</param>
            <param name="result">a when blend=0, b when blend=1, and a linear combination otherwise</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.BaryCentric(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4,System.Single,System.Single)">
            <summary>
            Interpolate 3 Vectors using Barycentric coordinates
            </summary>
            <param name="a">First input Vector</param>
            <param name="b">Second input Vector</param>
            <param name="c">Third input Vector</param>
            <param name="u">First Barycentric Coordinate</param>
            <param name="v">Second Barycentric Coordinate</param>
            <returns>a when u=v=0, b when u=1,v=0, c when u=0,v=1, and a linear combination of a,b,c otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.BaryCentric(ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Vector4@,System.Single,System.Single,ILNumerics.Drawing.Vector4@)">
            <summary>Interpolate 3 Vectors using Barycentric coordinates</summary>
            <param name="a">First input Vector.</param>
            <param name="b">Second input Vector.</param>
            <param name="c">Third input Vector.</param>
            <param name="u">First Barycentric Coordinate.</param>
            <param name="v">Second Barycentric Coordinate.</param>
            <param name="result">Output Vector. a when u=v=0, b when u=1,v=0, c when u=0,v=1, and a linear combination of a,b,c otherwise</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Transform(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Quaternion)">
            <summary>
            Transforms a vector by a quaternion rotation.
            </summary>
            <param name="vec">The vector to transform.</param>
            <param name="quat">The quaternion to rotate the vector by.</param>
            <returns>The result of the operation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Transform(ILNumerics.Drawing.Vector4@,ILNumerics.Drawing.Quaternion@,ILNumerics.Drawing.Vector4@)">
            <summary>
            Transforms a vector by a quaternion rotation.
            </summary>
            <param name="vec">The vector to transform.</param>
            <param name="quat">The quaternion to rotate the vector by.</param>
            <param name="result">The result of the operation.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.op_Addition(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4)">
            <summary>
            Adds two instances.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <returns>The result of the calculation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.op_Subtraction(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4)">
            <summary>
            Subtracts two instances.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <returns>The result of the calculation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.op_UnaryNegation(ILNumerics.Drawing.Vector4)">
            <summary>
            Negates an instance.
            </summary>
            <param name="vec">The instance.</param>
            <returns>The result of the calculation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.op_Multiply(ILNumerics.Drawing.Vector4,System.Single)">
            <summary>
            Multiplies an instance by a scalar.
            </summary>
            <param name="vec">The instance.</param>
            <param name="scale">The scalar.</param>
            <returns>The result of the calculation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.op_Multiply(System.Single,ILNumerics.Drawing.Vector4)">
            <summary>
            Multiplies an instance by a scalar.
            </summary>
            <param name="scale">The scalar.</param>
            <param name="vec">The instance.</param>
            <returns>The result of the calculation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.op_Division(ILNumerics.Drawing.Vector4,System.Single)">
            <summary>
            Divides an instance by a scalar.
            </summary>
            <param name="vec">The instance.</param>
            <param name="scale">The scalar.</param>
            <returns>The result of the calculation.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.op_Equality(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4)">
            <summary>
            Compares two instances for equality.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <returns>True, if left equals right; false otherwise.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.op_Inequality(ILNumerics.Drawing.Vector4,ILNumerics.Drawing.Vector4)">
            <summary>
            Compares two instances for inequality.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <returns>True, if left does not equa lright; false otherwise.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.op_Explicit(ILNumerics.Drawing.Vector4)~System.Single*">
            <summary>
            Returns a pointer to the first element of the specified instance.
            </summary>
            <param name="v">The instance.</param>
            <returns>A pointer to the first element of v.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.op_Explicit(ILNumerics.Drawing.Vector4)~System.IntPtr">
            <summary>
            Returns a pointer to the first element of the specified instance.
            </summary>
            <param name="v">The instance.</param>
            <returns>A pointer to the first element of v.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.ToString">
            <summary>
            Returns a System.String that represents the current Vector4.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.GetHashCode">
            <summary>
            Returns the hashcode for this instance.
            </summary>
            <returns>A System.Int32 containing the unique hashcode for this instance.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <param name="obj">The object to compare to.</param>
            <returns>True if the instances are equal; false otherwise.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.Equals(ILNumerics.Drawing.Vector4)">
            <summary>Indicates whether the current vector is equal to another vector.</summary>
            <param name="other">A vector to compare with this vector.</param>
            <returns>true if the current vector is equal to the vector parameter; otherwise, false.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Vector4.ToXMLAttrString">
            <summary>
            Convert this vector into a short string representation, suitable for xml attribute serialization
            </summary>
            <returns>short string representing this vectors content</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Vector4.Length">
            <summary>
            Gets the length (magnitude) of the vector.
            </summary>
            <see cref="!:LengthFast"/>
            <seealso cref="P:ILNumerics.Drawing.Vector4.LengthSquared"/>
        </member>
        <member name="P:ILNumerics.Drawing.Vector4.LengthSquared">
            <summary>
            Gets the square of the vector length (magnitude).
            </summary>
            <remarks>
            This property avoids the costly square root operation required by the Length property. This makes it more suitable
            for comparisons.
            </remarks>
            <see cref="P:ILNumerics.Drawing.Vector4.Length"/>
        </member>
        <member name="P:ILNumerics.Drawing.Vector4.Xyz">
            <summary>
            Gets or sets an OpenTK.Vector3 with the X, Y and Z components of this instance.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ContourLevel.LineWidth">
            <summary>
            Get the width of the contour lines of this level or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ContourLevel.LabelSpacing">
            <summary>
            (Not used yet)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ContourLevel.Text">
            <summary>
            Override the automatic text setting for contour line labels
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ContourLevel.LineColor">
            <summary>
            Determine the line color by mapping the value into the current colormap
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ContourLevel.FillColor">
            <summary>
            Determine the fill color by mapping the value into the current colormap
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ContourLevel.LabelColor">
            <summary>
            Get the color for the contour line labels or sets it 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ContourLevel.LineStyle">
            <summary>
            Get the dash style for the contour lines of that level or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ContourLevel.ShowLabel">
            <summary>
            If set, determines if contour lines of this level should be labeled, otherwise take Default setting
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.IILAxisDataProvider.GetRangeMinValue(ILNumerics.Drawing.AxisNames)">
            <summary>
            Gets the lower limit of the axis scale range 
            </summary>
            <param name="AxisName">The type / name of the axis</param>
            <returns>the lower limit</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.IILAxisDataProvider.GetRangeMaxValue(ILNumerics.Drawing.AxisNames)">
            <summary>
            Gets the upper limit of the axis scale range 
            </summary>
            <param name="AxisName">The type / name of the axis</param>
            <returns>the upper limit</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.IILAxisDataProvider.ScaleMode(ILNumerics.Drawing.AxisNames)">
            <summary>
            Gets the scale mode of the axis (log / linear)
            </summary>
            <param name="AxisName">The type / name of the axis</param>
            <returns>AxisScale enum value</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.IILAxisDataProvider.ID">
            <summary>
            ID of this provider, used to identify the object within a scene graph 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.IILColormapProvider.Colormap">
            <summary>
            Gets the current colormap or null, if no colormap is active or used
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.IILColormapProvider.IsColormapped">
            <summary>
            Determines, if the colormap is currently in use 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.IILColormapProvider.Tag">
            <summary>
            Tag used to identify or label this provider object 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plotting.ILColorEnumerator">
            <summary>
            Color enumerator, used for line plot coloring
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILColorEnumerator.#ctor(ILNumerics.Drawing.Colormaps)">
            <summary>
            Creates a new color enumerator based on a user defined colormap
            </summary>
            <param name="basemap"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILColorEnumerator.#ctor">
            <summary>
            Creates a new color enumerator based on Colormap.Lines
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILColorEnumerator.NextColor">
            <summary>
            Gives the next color from the enumeration
            </summary>
            <returns>The next color from the enumeration</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILColormap.SetData(ILNumerics.ILInArray{System.Single})">
            <summary>
            Sets internal data for color indices
            </summary>
            <remarks><para><paramref name="data"/> is a matrix with 5 columns, elements in range [0...1] 
            <list type="number">
            <item>Column 0: keypoint position</item>
            <item>Column 1: keypoint R color component value</item>
            <item>Column 2: keypoint G color component value</item>
            <item>Column 3: keypoint B color component value</item>
            <item>Column 4: keypoint alpha component value</item>
            </list>
            </para>
            <para>Calling this function may fire a <see cref="E:ILNumerics.Drawing.Plotting.ILColormap.Changed"/> event.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILColormap.#ctor">
            <summary>
            construct new colormap, based on ILNumerics default
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILColormap.#ctor(ILNumerics.Drawing.Colormaps)">
            <summary>
             create specific colormap
            </summary>
            <param name="map"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILColormap.#ctor(ILNumerics.ILInArray{System.Single})">
            <summary>
            Creates a new colormap based on predefined colors
            </summary>
            <param name="colors">Matrix with keypoint values as rows, 
            5 columns each: keypoint position (float range), R, G, B, A components in range[0...1]</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILColormap.op_Implicit(ILNumerics.Drawing.Colormaps)~ILNumerics.Drawing.Plotting.ILColormap">
            <summary>
            Implicitly converts a Colormaps enumeration value to a discrete colormap
            </summary>
            <param name="val">Colormaps enum value</param>
            <returns>new colormap object</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILColormap.Map(System.Single,System.Tuple{System.Single,System.Single},System.Nullable{ILNumerics.Drawing.Vector4})">
            <summary>
            Map single value within colormap data range to color 
            </summary>
            <param name="val">Value to map, range of this colormap data range (i.e. column 0 in <see cref="P:ILNumerics.Drawing.Plotting.ILColormap.Data"/> matrix)</param>
            <param name="outOfRangeAndNaNsValue">[optional] Replacement value if no valid color could be mapped, default: black</param>
            <param name="minMaxRange">[optional] If null: val is mapped to the colormap from range 0..1; otherwise, the range for val is taken from minMaxRange</param>
            <returns>Color as Vector4 with mapped RGBA (XYZW) values, interpolated according to this colormap</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILColormap.Map(ILNumerics.ILInArray{System.Single},System.Tuple{System.Single,System.Single},System.Nullable{ILNumerics.Drawing.Vector4})">
            <summary>
            Maps all elements in A to interpolated colors from this colormap
            </summary>
            <param name="A">Array with elements to map, values will be taken in order of storage in A and lined up by their linear indices</param>
            <param name="dataRange">[optional] If given, dataRange marks the upper and lower limit of the color mapping data range, if null: taken from A.GetLimits()</param>
            <param name="outOfRangeAndNaNsValue">[optional] Color value assigned to those values in A, which do not fit inside the range given by <paramref name="dataRange"/>. Default: Color.Black</param>
            <returns>Colors as matrix, the i-th row represents the color from the i-th element of A (linear indexing) as RGBA quadrupel (RGB components and alpha).</returns>
        </member>
        <member name="E:ILNumerics.Drawing.Plotting.ILColormap.Changed">
            <summary>
            Fires when the colormap data have changed
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILColormap.Length">
            <summary>
            Number of colors in the colormap
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILColormap.Type">
            <summary>
            The colormap type this colormap is based on (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILColormap.Data">
            <summary>
            retrieve / set internal data for color indices
            </summary>
            <remarks><para>Data is a matrix with 5 columns, elements in range [0...1] !
            <list type="number">
            <item>Column 0: keypoint position</item>
            <item>Column 1: keypoint R color component value</item>
            <item>Column 2: keypoint G color component value</item>
            <item>Column 3: keypoint B color component value</item>
            <item>Column 4: keypoint alpha component value</item>
            </list>
            </para>
            <para>The array returned will be a <i>copy</i> of the internal data only. It cannot be used to alter the internal color table! 
            In order to modify the color table, one must query the table, alter it outside and store it back.</para></remarks>
            <seealso cref="M:ILNumerics.Drawing.Plotting.ILColormap.SetData(ILNumerics.ILInArray{System.Single})"/>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILColormap.MapCreator.CreateMap(ILNumerics.Drawing.Colormaps)">
            <summary>
            create colormap
            </summary>
            <param name="map">colormap type to create</param>
            <returns>colormap data matrix, the size depends on the type of the colormap</returns>
        </member>
        <member name="T:ILNumerics.Drawing.ILColorProvider">
            <summary>
            Color helper - change RGB to/ from HLS model
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILColorProvider.H2RGB(System.Single)">
            <summary>
            convert hue value to RGB value, based on predefined values  
            </summary>
            <param name="hue">hue: in range 0...MAXHUEVALUE</param>
            <returns>int value as RGB color, A=255</returns>
            <remarks>the internal values (rgb / luminance,saturation) will not be altered</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILColorProvider.H2RGB(System.Single,System.Single@,System.Single@,System.Single@)">
            <summary>
            convert hue value to seperate RGB values, based on predefined values  
            </summary>
            <param name="hue">hue: in range 0...MAXHUEVALUE</param>
            <returns>int value as RGB color, A=255</returns>
            <remarks>the internal values (rgb / luminance,saturation) will not be altered. 
            rgb returned as seperate float values, normalized to 0.0f...1.0f</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILColorProvider.H2RGB(System.Single,System.Single[],System.Int32@)">
            <summary>
            convert hue value to seperate RGB values, based on predefined values  
            </summary>
            <param name="hue">hue: in range 0...MAXHUEVALUE</param>
            <param name="offset">offset into vertex array</param>
            <param name="va">vertex array, target for the color</param>
            <remarks>the internal values (rgb / luminance,saturation) will not be altered. 
            rgb returned as seperate float values, normalized to 0.0f...1.0f</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILColorProvider.H2RGB(System.Single,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            convert hue value to seperate RGB values, based on predefined values  
            </summary>
            <param name="hue">hue: in range 0...MAXHUEVALUE</param>
            <returns>int value as RGB color, A=255</returns>
            <remarks>the internal values (rgb / luminance,saturation) will not be altered. 
            rgb returned as seperate float values, normalized to 0.0f...1.0f</remarks>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILContourPlot.DefaultContourTag">
            <summary>
            Tag used to identify contour plot objects within the scene graph
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILContourPlot.DefaultLineTag">
            <summary>
            Tag used to identify contour line objects within the scene graph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILContourPlot.#ctor(ILNumerics.ILInArray{System.Single},System.Nullable{System.Drawing.Color},System.Nullable{System.Single},System.Nullable{ILNumerics.Drawing.DashStyle},System.Nullable{System.Int32},System.Boolean,ILNumerics.Drawing.Plotting.ILColormap,System.Boolean)">
            <summary>
            Create contour plot, automatic level definition; allows configuration of all contour lines at once
            </summary>
            <param name="Z">data matrix</param>
            <param name="labelColor">[optional] if set, the color for contour labels. Otherwise: take ContourLevel.Default setting</param>
            <param name="lineColor">[optional] if set, the color map value for the contour lines color. Otherwise: determine colors automatically</param>
            <param name="lineStyle">[optional] if set, the dash style for contour lines. Otherwise: take ContourLevel.Default setting</param>
            <param name="lineWidth">[optional] if set, sets the width for all contour lines. Otherwise: take ContourLevel.Default setting</param>
            <param name="showLabels">[optional] determine visibility of contour labels. Default: true</param>
            <param name="colormap">[optional] if set, the colormap used for mapping Z values to colors in the colormap</param>
            <param name="create3D">[optional] determine, if the contour lines are created with with Z coordinates of the level value. Default: false, create at Z=0.</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILContourPlot.#ctor(ILNumerics.ILInArray{System.Single},System.Collections.Generic.List{ILNumerics.Drawing.Plotting.ContourLevel},ILNumerics.Drawing.Plotting.ILColormap,System.Boolean)">
            <summary>
            Create contour plot, manual level definition; individual contour level configuration
            </summary>
            <param name="Z">data matrix</param>
            <param name="levels">Collection of individual contour levels</param>
            <param name="colormap">[optional] if set, the colormap used for mapping Z values to colors in the colormap</param>
            <param name="create3D">[optional] determine, if the contour lines are created with with Z coordinates of the level value. Default: false, create levels at Z=0.</param>
            <remarks>This constructor creates a new contour plot object with individual contour level specification. <paramref name="levels"/> - if not null - 
            is expected to contain <see cref="T:ILNumerics.Drawing.Plotting.ContourLevel"/> objects with the configuration and data value for all contour lines to be created. No 
            levels will be aquired automatically.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILContourPlot.GetRangeMinValue(ILNumerics.Drawing.AxisNames)">
            <summary>
            Provides the minimum axis scale range for rendering axis scales
            </summary>
            <param name="AxisName">Name of the axis to query</param>
            <returns>Minimum color range</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILContourPlot.GetRangeMaxValue(ILNumerics.Drawing.AxisNames)">
            <summary>
            Provides the maximum axis scale range for rendering axis scales
            </summary>
            <param name="AxisName">Name of the axis to query</param>
            <returns>Maximum color range</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILContourPlot.ScaleMode(ILNumerics.Drawing.AxisNames)">
            <summary>
            Provides the scale mode (linear/logarithmic) for rendering axis scales
            </summary>
            <param name="AxisName">Name of the axis to query</param>
            <returns>Linear scale mode</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILContourPlot.Colormap">
            <summary>
            Colormap used for mapping values to colors
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILContourPlot.Levels">
            <summary>
            Collection of contour levels 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILContourPlot.ColorRangeMin">
            <summary>
            Gets minimum for the range used to map countour data values to color values within the colormap range
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILContourPlot.ColorRangeMax">
            <summary>
            Gets maximum for the range used to map countour data values to color values within the colormap range
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILContourPlot.IsColormapped">
            <summary>
            Determines if this contour plot uses a colormap for coloring contour lines
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILContourPlot.ContourHelper.VisitFace(System.SByte[],System.Single[],System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            find crossing within a face
            </summary>
            <param name="faces">visited marks for all faces, column major order</param>
            <param name="Z">level values (Z - level), column major order</param>
            <param name="c">index of column for upper left face corner into Z and faces</param>
            <param name="r">index of row for upper left face corner into Z and faces</param>
            <param name="ldz">leading dimension of Z and faces matrices</param>
            <param name="edge">id of edge to start with: 0 (top)... 3 (left)</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILContourLine.#ctor(System.Object)">
            <summary>
            Create a new countour line 
            </summary>
            <param name="tag">[optional] tag identifying the object in the scene graph</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILContourLine.ConfigureLegendVisual(ILNumerics.Drawing.ILGroup)">
            <summary>
            Renders a visual representation of this countour line into a legend 
            </summary>
            <param name="renderArea">Root group for output</param>
            <remarks>The <paramref name="renderArea"/> is expected to provide a coordinate system in range [0,0,0] -> [1,1,1]. 
            The function may adds and configures new objects to the group. Properties of the group will not get altered.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILContourLine.ConfigureLegendLabel(ILNumerics.Drawing.ILGroup)">
            <summary>
            Renders a textual representation / label of this countour line into a legend 
            </summary>
            <param name="renderArea">Root group for output</param>
            <remarks>The <paramref name="renderArea"/> is expected to provide a coordinate system in range [0,0,0] -> [1,1,1]. 
            The function may adds and configures new objects to the group. Properties of the group will not get altered.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILContourLine.GetID">
            <summary>
            Gets an ID for the contour line; used to identify the line among objects in the scene graph
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILContourLine.GetVersion">
            <summary>
            Gets the current version for the contour line
            </summary>
            <returns>Current version</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILContourLine.Line">
            <summary>
            Gets access to the line object of the contour line
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILContourLine.Label">
            <summary>
            Gets access to the label object of the contour line
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILContourLine.LabelTarget">
            <summary>
            Determines if the label for the contour line is rendered as Screen2D or as 3D object 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILContourLine.ShowLabel">
            <summary>
            Determines if the labels for the contour line is to be shown
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.IILPositionProvider">
            <summary>
            provides methods or properties to handle over individual positions
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILLegendItem.EntryAreaTag">
            <summary>
            Tag used to identiy the entry area within the scene graph
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILLegendItem.LabelAreaTag">
            <summary>
            Tag used to identiy the label area within the scene graph
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILLegendItem.LabelTag">
            <summary>
            Tag used to identiy the label within the scene graph
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILLegendItem.LegendItemTag">
            <summary>
            Tag used to identiy the whole legend item (entry area, label area, label) within the scene graph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILLegendItem.#ctor(System.Int32,System.String,System.Object)">
            <summary>
            Create new legend item for manual mode, provide provider reference and [optionally] a label string 
            </summary>
            <param name="providerID">A valid object ID to an provider object for the new legend item</param>
            <param name="text">[optional] legend item label text, default: the Tag property of the provider object </param>
            <param name="tag">[optional] a tag identifying the item in the scene</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILLegendItem.#ctor(ILNumerics.Drawing.Plotting.IILLegendItemDataProvider,System.String,System.Object)">
            <summary>
            Create new legend item for manual mode, provide provider reference and [optionally] a label string 
            </summary>
            <param name="plotSource">provider object, the source for the new legend item, can not be null</param>
            <param name="text">[optional] legend item label text, default: the Tag property of the provider object </param>
            <param name="tag">[optional] a tag identifying the item in the scene</param>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILLegendItem.Text">
            <summary>
            Legend item label text override, default: null -> builds label text from source plot properties
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILLegendItem.MarkerPositions">
            <summary>
            The position of the marker within the legend entry area; (X,Y,Z) coordinates; default: (.375, .5, 0)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILLegendItem.ProviderID">
            <summary>
            Gives a reference to the plot object for this legend item or sets it
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plotting.ILSelectionRectangle">
            <summary>
            Class used for displaying a selection rectangle for zooming in 2D plots 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILSelectionRectangle.LineTag">
            <summary>
            Tag used to identify the selection rectangle lines in the scene graph
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILSelectionRectangle.GroupTag">
            <summary>
            Tag used to identify the selection rectangle group node in the scene graph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILSurface.#ctor(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Tuple{System.Single,System.Single},ILNumerics.Drawing.Plotting.ILColormap,System.Object)">
            <summary>
            Creates a new surface plot, provide Z, X and/or Y coordinates
            </summary>
            <param name="ZXYPositions">Positions data for the grid points, matrix of size [m x n x [1|2|3]]</param>
            <param name="C">[optional] Colors for the grid points, size [m x n x [1|4]], default: colormapped heights (Z-values)</param>
            <param name="colormap">[optional] Colormap to be used for colormappings, default: 'ILNumerics'</param>
            <param name="tag">[optional]tag used to identify the surface within the scene graph</param>
            <param name="colorsDataRange">[optional] if not null, the lower (Item1) and the upper (Item2) limit of the inherent data range of the
            <paramref name="C"/> parameter in colormap mode. If null, the maximum and the minimum values are taken from <paramref name="C"/>.</param>
            <remarks>
            <para>The <paramref name="ZXYPositions"/> parameter defines the grid positions of the new surface. The array 
            is of size [m x n x 3]. m and m are the number of rows / columns respectively. The position coordinates for each 
            grid point is stored along the 3rd dimension. Note the order of the coordinates: Z,X,Y ! Z is obligatory, X and Y are optional. 
            If X and/or Y are ommitted (i.e. a matrix with Z values is provided only), a regular grid will be created for the missing axis, 
            having evenly spaced grid distances of 1. </para>
            <para>The optional <paramref name="C"/> parameter is used to define the coloring of each grid point. One of the 
            following modes are available: 
            <list type="bullet">
            <item><paramref name="C"/> is an 3d array of size [m x n x [3|4]] with individual RGB[A] color tupels for every grid point.</item>
            <item>If <paramref name="C"/> is a matrix of size [m x n], the values are mapped into the current colormap. If 
            the current colormap is changed, the resulting colors will change as well. Values of <paramref name="C"/> are mapped onto  
            the colorrange of the current colormap. <paramref name="colorsDataRange"/> can be used to adjust the data range used for mapping.</item>
            </list>
            </para>
            <para>The optional <paramref name="colormap"/> parameter can be used to set the surfaces colormap to an individual map. If this 
            parameter is ommitted, the predefined 'ILNumerics' colormap is taken by default.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILSurface.#ctor(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Tuple{System.Single,System.Single},ILNumerics.Drawing.Plotting.ILColormap,System.Object)">
            <summary>
            Creates a new surface plot, provide Z values, X and Y ranges
            </summary>
            <param name="Z">Positions data for the grid points, matrix of size [m x n]</param>
            <param name="X">X range: a matrix of size Z.S or a vector of length Z.S[1]</param>
            <param name="Y">Y range: a matrix of size Z.S or a vector of length Z.S[0]</param>
            <param name="C">[optional] Colors for the grid points, size [m x n x [1|4]], default: colormapped heights (Z-values)</param>
            <param name="colormap">[optional] Colormap to be used for colormappings, default: 'ILNumerics'</param>
            <param name="tag">[optional]tag used to identify the surface within the scene graph</param>
            <param name="colorsDataRange">[optional] if not null, the lower (Item1) and the upper (Item2) limit of the inherent data range of the
            <paramref name="C"/> parameter in colormap mode. If null, the maximum and the minimum values are taken from <paramref name="C"/>.</param>
            <remarks>
            <para>The <paramref name="Z"/>, <paramref name="X"/> and <paramref name="Y"/> parameters define the grid positions of the new surface. Z defines 
            the size of the surface. X and Y define the position of the surface on the X and Y axes respectively. X and Y can be vectors or matrices. If X is provided 
            as vector, it gives the X coordinates of the grid points which are replicated for all rows. If Y is a vector, it defines the Y coords for the grid
            points for all columns respectively. If X or Y are given as matrices, they define the X and/or Y coordinates of all individual grid points explicitely.
            This allows the creation of arbitrary parametric surfaces. </para>
            <para>If either of X or Y is null, the coords are computed based on a regular spacing, starting at 0 and running along the X and Y axis with a step width of 1.</para>
            <para>The optional <paramref name="C"/> parameter is used to define the coloring of each grid point. One of the 
            following modes are available: 
            <list type="bullet">
            <item><paramref name="C"/> is an 3d array of size [m x n x [3|4]] with individual RGB[A] color tupels for every grid point.</item>
            <item>If <paramref name="C"/> is a matrix of size [m x n], the values are mapped into the current colormap. If 
            the current colormap is changed, the resulting colors will change as well. Values of <paramref name="C"/> are mapped onto  
            the colorrange of the current colormap. <paramref name="colorsDataRange"/> can be used to adjust the data range (min,max) used for mapping.</item>
            </list>
            </para>
            <para>The optional <paramref name="colormap"/> parameter can be used to set the surfaces colormap to an individual map. If this 
            parameter is ommitted, the predefined 'ILNumerics' colormap is taken by default.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILSurface.#ctor(System.Func{System.Single,System.Single,System.Single},System.Single,System.Single,System.Int32,System.Single,System.Single,System.Int32,System.Func{System.Single,System.Single,System.Single},System.Tuple{System.Single,System.Single},ILNumerics.Drawing.Plotting.ILColormap,System.Object)">
             <summary>
             Creates a new surface plot from a function delegate
             </summary>
             <param name="ZFunc">function delegate or lambda expression for computing the Z values out of X and Y parameters</param>
             <param name="xmin">[optional] minimal x axis range</param>
             <param name="xmax">[optional] maximum x axis range</param>
             <param name="xlen">[optional] number of steps on the x axis</param>
             <param name="ymin">[optional] minimal y axis range</param>
             <param name="ymax">[optional] maximum y axis range</param>
             <param name="ylen">[optional] number of steps on the y axis</param>
             <param name="CFunc">[optional] function delegate or lambda expression for computing the colors for the grid point (x,y) tuples; default: colormapped heights (Z-values)</param>
             <param name="colormap">[optional] Colormap to be used for colormappings, default: 'ILNumerics'</param>
             <param name="tag">[optional]tag used to identify the surface within the scene graph</param>
             <param name="colorsDataRange">[optional] if not null, the lower (Item1) and the upper (Item2) limit of the inherent data range of the
             <paramref name="C"/> parameter in colormap mode. If null, the maximum and the minimum values are taken from <paramref name="C"/>.</param>
             <remarks>
             <para>The surface is constructed by evaluating <paramref name="ZFunc"/> for every grid point. The optional parameters xmin, xmax and xlen define the grid points 
             for the X axis; ymin, ymax and ylen for the Y axis accordingly. Axes generate 50 points running from -5 to 5 per default.</para>
             <para>If either of X or Y is null, the coords are computed based on a regular spacing, starting at 0 and running along the X and Y axis with a step width of 1.</para>
             <para>The optional <paramref name="CFunc"/> parameter is used to define the coloring of each grid point. If omitted, the Z values (heights) are mapped to the current colormap. 
             Otherwise, the CFunc is evaluated for each grid point. 
             </para>
             <para>The optional <paramref name="colormap"/> parameter can be used to set the surfaces colormap to an individual map. If this 
             parameter is ommitted, the predefined 'ILNumerics' colormap is taken by default.</para>
             </remarks>
             <example>The following example generates a surface from a lambda expression. The Z values are computed from the x,y tuples on every gridpoint from the function: 
             <code>(x, y) => (float)(Math.Sin(x) * Math.Cos(y) * Math.Exp(-(x * x * y * y) / 4)</code>
             <para>The ranges for the X and Y axes are left at their defaults. The colors are generated from the function 
             <code>(x,y) => x * y</code></para>
             <para>The complete scene setup: </para>
             <code>        
            private void ilPanel1_Load(object sender, EventArgs e) {
                var scene = new ILScene() {
                    new ILPlotCube(twoDMode: false) {
                        new ILSurface((x, y) => (float)(Math.Sin(x) * Math.Cos(y) * Math.Exp(-(x * x * y * y) / 4)), 
                                  CFunc: (x,y) => x * y, colormap: Colormaps.Jet) { 
                            UseLighting = true,
                            Children = { new ILColorbar() },
                        }
                    } 
                };
                ilPanel1.Scene = scene;
            }</code>
            <para>Download this example within <a href="http://ilnumerics.net/ilcc.php?ilc=ic05e51">ILView</a> and modify it interactively.</para>
            </example>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILSurface.Resize(System.Int32,System.Int32)">
            <summary>
            Resize the grid size (number of rows and columns) 
            </summary>
            <param name="rows">number of rows</param>
            <param name="columns">number of columns</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILSurface.UpdateSolidColor(System.Drawing.Color,ILNumerics.ILInArray{System.Single})">
            <summary>
            Update positions data [optional] and switches to solid coloring mode 
            </summary>
            <param name="ZXYPositions">[optional] positions data matrix, size: [M x N x [1|2|3]] with Z, [X and Y] values, resizing allowed</param>
            <param name="solidColor">Color for the surface fill</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILSurface.UpdateRGBA(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Update positions data [optional] and switches to solid coloring mode 
            </summary>
            <param name="ZXYPositions">[optional] positions data matrix, size: [M x N x [1|2|3]] with Z, [X and Y] values, resizing allowed</param>
            <param name="RGBAcolors">RGBA color component tuples for every grid point, size [M x N x [3|4]]</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILSurface.UpdateColormapped(ILNumerics.ILInArray{System.Single},ILNumerics.Drawing.Plotting.ILColormap,System.Tuple{System.Single,System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Update positions data [optional] and color data [optional], switch to colormapped mode 
            </summary>
            <param name="ZXYPositions">[optional] positions data matrix, size: [M x N x [1|2|3]] with Z, [X and Y] values, resizing allowed</param>
            <param name="colormap">[optional] if given, the current colormap will be changed</param>
            <param name="dataRange">[optional] if defined, this range is used to map data values to the colormap instead of min/max(dataValues)</param>
            <param name="dataValues">[optional] matrix [M x N], with data values. If ommited: use Z values as data values</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILSurface.Copy">
            <summary>
            Create a copy of the surface. This function is used internally. 
            </summary>
            <returns></returns>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILSurface.DataRange">
            <summary>
            Get the current data range which corresponds to the current colormap or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILSurface.Colormap">
            <summary>
            Gets the colormap used for coloring in colormapped modes or sets it 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILSurface.UseLighting">
            <summary>
            Determines, if the surface plot utilizes lighting. Default: Auto (true for individual color mode, false for colormap mode)
            </summary>
            <remarks>Lighting makes it potentially harder to match the colors of the surface with the colorscale of the colormap /colorbar. 
            Therefore, for those surfaces which are using a colormap to determine the surface colors, lighting is disabled per default. For all 
            other surfaces, ligthing is enabled by default. By assigning a value to this property, this behavior can be overwritten.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILSurface.Wireframe">
            <summary>
            Gets a reference to the lines shape representing the wireframes of the surface
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILSurface.Fill">
            <summary>
            Gets a reference to the triangles shape representing the fill area of the surface 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILSurface.Rows">
            <summary>
            Gets the number of rows currently held in the surface, readonly
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILSurface.Columns">
            <summary>
            Gets the number of columns currently held in the surface, readonly
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILSurface.Positions">
            <summary>
            Gets the positioning values for this surface or sets them
            </summary>
            <remarks><para>The coords property converts the underlying buffer data to/from matrix for X,Y and Z values. No data are 
            stored redundantly. Therefore, the conversion may introduces a workload if frequently used.</para>
            <para>The array returned on get access reflects the data stored in the vertex buffers of the shapes. It is a lazy copy 
            on write clone and therefore cannot be used to alter the data in the buffers. In order to alter the surface data, 
            one must query the complete data set, do all modifications on the array returned and store the full array back by
            using the set accessor. </para>
            <para>Assigning data to the <c>Positions</c> property is a buffer changing operation. Therefore, one must call 
            <see cref="M:ILNumerics.Drawing.ILGroup.Configure(System.Boolean,System.Boolean)"/> on the group node or any group node above in order to populate the changes 
            for rendering.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILSurface.Colors">
            <summary>
            Gets the coloring values for this surface or sets them
            </summary>
            <remarks>
            <para>The color array returned on get access and the one expected on set access contain coloring information for 
            every grid point of the surface. The array has the size [m x n x 4] or [m x n x 1], where m and n are the number of rows and columns of 
            the surface grid. The size of the 3rd dimension determines the coloring mode of the surface: 
            <list type="bullet">
            <item>Providing an array of the size [m x n x <b>4</b>] will set the surface in RGBA mode. Individual RBGA tuples are expected for each grid point. 
            The surface will have lighting enabled and the colorbar / colormap will get disabled.</item>
            <item>Providing a matrix of size [m x n] will set the surface in colormapped mode. Values are taken as <i>references</i> into the current colormap. If 
            later the current colormap is changed, the resulting colors will change as well. Values of the matrix are mapped onto  
            the colorrange of the current colormap. <see cref="P:ILNumerics.Drawing.Plotting.ILSurface.DataRange"/> can be used to adjust the data range used for mapping. Lighting will be disabled.</item>
            <item>Providing an empty array will cause the surface to switch to solid coloring. Neither the colormap nor individual color values are used for 
            coloring the surface. The colors of the <see cref="P:ILNumerics.Drawing.Plotting.ILSurface.Fill"/> area and the <see cref="P:ILNumerics.Drawing.Plotting.ILSurface.Wireframe"/> 
            still can individually get configured by accessing its individual <see cref="!:ILNumerics.Drawing.ILNode.Color"/> or <see cref="P:ILNumerics.Drawing.ILShape.Colors"/> properties. 
            Lighting will be enabled, the colormap will be disabled.</item>
            </list>
            </para>
            <para>The array returned on get access reflects the state of the surface. In RGBA mode, the array reflects the data stored in the 
            vertex colors buffer of the shapes. In colormapped mode the value reflects the indices data used to map the grid points to the current colormap.</para>
            <para>The array returned cannot be used to alter the data in the buffers directly. In order to alter the surface data, 
            one must query the complete data set, do all modifications on the array returned and store the full array back by
            using the set accessor.</para>
            <para>Assigning data to the <c>Colors</c> property is a buffer changing operation. Therefore, one must call the derived  
            <see cref="M:ILNumerics.Drawing.ILGroup.Configure(System.Boolean,System.Boolean)"/> on the group node or any group node above in order to populate changes made 
            to the rendering output.</para></remarks>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILSurface.ColorModes.Solid">
            <summary>
            All surface grid points have the same color
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILSurface.ColorModes.Colormapped">
            <summary>
            Colors of the surface are mapped from a colormap
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILSurface.ColorModes.RBGA">
            <summary>
            Surface grid points are individually colored
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plotting.ILAutoSizeGroup">
            <summary>
            Container class for arbitrary 3D nodes, provides a local coordinate system for drawing inside a specific screen rectangle
            </summary>
            <remarks>The class ensures, that the projection of a virtual cube (of size [-1 ... 1] in each direction) is 
            limited to the screen rectangle given in 'Rect'. The current camera position and projection is taken into account. 
            Therefore, any transformation does only affect the local driver and not the global scene.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAutoSizeGroup.ScreenRect">
            <summary>
            Rectangular area of the controls surface the rendering of all childs controls is limited to, range 0..1
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plotting.ILAxis">
            <summary>
            The class implements an axis for displaying scaling information
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILAxis.AxisGroupTag">
            <summary>
            Default node tag for new instances of ILAxis
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILAxis.TicksTag">
            <summary>
            Default node tag for new instances of axis' ticks collection, default: 'TicksCollectionGroup'
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILAxis.LabelTag">
            <summary>
            Default node tag for new instances of axis' label, default: 'AxesLabel'
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILAxis.ScaleLabelTag">
            <summary>
            Default node tag for new instances of axis' scale label, default: 'ScaleLabel'
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILAxis.GridMajorLinesTag">
            <summary>
            Default node tag for new instances of axis' grid major lines, default: 'GridMajorLines'
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILAxis.GridMinorLinesTag">
            <summary>
            Default node tag for new instances of axis' grid minor lines, default: 'GridMinorLines'
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILAxis.TickLabelPadding">
            <summary>
            Padding between individual ticks, default: 7
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILAxis.TickLabelMargin">
            <summary>
            Margin around tick labels as fraction of Ticks.DefaultLabel.Font.Height; default: 0.33f
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILAxis.DefaultLabelPosition">
            <summary>
            The relative position of the axis main label, if LabelPosition is null. Default: follow axis at (0.5,1) (axis center, close to tick label)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILAxis.DefaultScaleLabelPosition">
            <summary>
            The relative position of the axis tick scale label, if ScaleLabelPosition is null. Default: follow axis at (1,1) (upper axis end, close to tick label)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.DataProviderID">
            <summary>
            Gets/ sets the id of the data provider this axis retrieves its data from
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.DataProvider">
            <summary>
            The object providing neccessary data for this axis; default: first IILAxisDataProvider on the path up to the root
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.LabelAnchor">
            <summary>
            Anchor for the main axis label, range: (0,0)..(1,1); null: automatic
            </summary>
            <remarks>This value overrides any setting of the Label.Anchor property.
            <para>Leaving this value to <code>null</code> will automatically find a good looking setting according to the current orientation and position 
            of the label.</para>
            <para>Custom settings of this property align the labels anchor point relative to the labels size. (0,0) is the upper left corner of the label, 
            (1,1) corresponds to the lower right corner. The anchor point is addressed by the position and used as reference point for any rotation of the 
            label.</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.ScaleLabelAnchor">
            <summary>
            Anchor for the axis scale label, range: 0..1, null: automatic (default)
            </summary>
            <remarks>This value overrides any setting of the ScaleLabel.Anchor property!
            <para>Leaving this value to <code>null</code> will automatically find a good looking setting 
            according to the current orientation and position of the label and the current position of 
            the main label.</para>
            <para>A custom setting of this property aligns the labels anchor point relative to the 
            scale labels size. (0,0) is the upper left corner of the label, 
            (1,1) corresponds to the lower right corner. The anchor point is addressed by the position 
            and used as reference point for any rotation of the label. See <see cref="T:ILNumerics.Drawing.ILLabel"/> for <code>ILLabel.Anchor</code> usage.</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.LabelPosition">
            <summary>
            Default position of the label relative to the current axis position, size and orientation; null: automatic (default)
            </summary>
            <remarks>This value overrides any setting of the Label.Position property.
            <para>Leaving this value to <code>null</code> will automatically find a good looking setting according to the current orientation and position 
            of the axis.</para>
            <para>Custom settings of this property position the labels anchor point relative to the axis orientation and position. </para>
            <para>The X coordinate corresponds to the length of the axis with 0 being the lower axis end (i.e. the end with the lower value) and 1 being the
            upper axis end.</para>
            <para>The Y coordinate corresponds to the direction pointing outside along the ticks direction perpendicular to the axis. 0 corresponds to a 
            position on the axis line, 1 corresponds to the distance along that direction, which equals the tick length plus the size of the tick label.</para>
            <para>Note, the relevant size of the tick label depend on the current roation of the axis, for vertical axes, the width of the label is commonly 
            more relevant than the height. This is taken into account automatically, so a setting of (0,1) will place the label always on the lower end and 
            outside of the tick labels area - regardless of the axis orientation.</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.ScaleLabelPosition">
            <summary>
            Position of the scale label relative to the current axis position, size and orientation; null: automatic (default)
            </summary>
            <remarks>This value overrides any setting of the ScaleLabel.Position property.
            <para>Leaving this value to <code>null</code> will automatically find a good looking setting according to the current orientation and position 
            of the axis and the current position of the main axis label.</para>
            <para>Custom settings of this property position the scale labels anchor point relative to the axis orientation and position. </para>
            <para>The X coordinate corresponds to the length of the axis with 0 being the lower axis end (i.e. the end with the lower value) and 1 being the
            upper axis end.</para>
            <para>The Y coordinate corresponds to the direction pointing outside along the ticks direction perpendicular to the axis. 0 corresponds to a 
            position on the axis line, 1 corresponds to the distance along that direction, which equals the tick length plus the size of the tick label.</para>
            <para>Note, the relevant size of the tick label depend on the current roation of the axis, for vertical axes, the width of the label is usually 
            more relevant than the height. This is taken into account automatically, so a setting of (0,1.1) will place the label always on the lower end and 
            outside of the tick labels area - regardless of the axis orientation.</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.LabelRotation">
            <summary>
            Rotation for the main axis label; null: the label follows the axis orientation (default)
            </summary>
            <remarks>
            <para>If this property is null the axis main label will always follow the orientation of this axis (default). Otherwise, the value set to LabelRotation 
            will define the (fixed) rotation value for the main axis label.</para>
            <para>This property overrides any value may be configured for the Label.Rotation property.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.AxisName">
            <summary>
            Get the type of the axis (XAxis, YAxis or ZAxis) or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.Position">
            <summary>
            Gets the axis position or sets it. The position is the start/lower end of the axis. null: automatic (default)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.Direction">
            <summary>
            The direction of the axis. Default: automatic setting according to the axis name (XAxis, YAxis or ZAxis)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.Min">
            <summary>
            The minimum value for the axis range, if this property is not null, its value will override the actual value 
            taken from the assigned data container within the plot cube. Default: null
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.Max">
            <summary>
            The maximum value for the axis range, if this property is not null, its value will override the actual value 
            taken from the assigned data container within the plot cube. Default: null
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.Label">
            <summary>
            Access the axis main label for configuration
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.ScaleLabel">
            <summary>
            Access the axis scale label for configuration. 
            </summary>
            <remarks>The scale label displays the tick value scale factor for abbreviated tick values outside of the allowed display range width.
            Individual values for the ScaleLabel.Position will be ignored. The scale label is always displayed at the position of the tick with the lowest screen Y coordinate.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.Ticks">
            <summary>
            Access to the ticks collection group
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.GridMajor">
            <summary>
            Major grid lines for axes ticks
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxis.GridMinor">
            <summary>
            Minor grid lines for axes ticks
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILAxisCollection.AUTOAXIS_PREFER_LENGTH_OVER_POSITION_FACTOR">
            <summary>
            Length difference threshold for choosing an axis position candidate based on its length rather than its position. Default: 3
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILAxisCollection.AUTOAXIS_NON_HULL_SCREEN_POSITION">
            <summary>
            Prefered position of axis which do not lay on the hull of the unit cube. Clip coordinates. Default: (1,-1) (lower right outside region)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILAxisCollection.AUTOAXIS_HULL_SCREEN_POSITION">
            <summary>
            Prefered position of axis which exist on the hull of the unit cube. Clip coordinates. Default: (0.45,1) (lower left corner)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILAxisCollection.DefaultTag">
            <summary>
            Tag used to identify the object within the scene graph 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILAxisCollection.Graphics">
            <summary>
            Default helper graphics instance; used to measure string extends
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILAxisCollection.#ctor(ILNumerics.Drawing.Plotting.IILAxisDataProvider,System.Object)">
            <summary>
            Create new Axis Collection
            </summary>
            <param name="plotContainer">[optional] IILAxisDataProvider to be used to retrieve axis' data from; default: null (take the first provider found on the path up to the root node)</param>
            <param name="tag">[optional] tag used to identify the object within the scene graph</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILAxisCollection.Add(ILNumerics.Drawing.Plotting.ILAxis)">
            <summary>
            Add new axis to the axes collection
            </summary>
            <param name="axis">the axis to be added</param>
            <returns>axis added to this collection (might differ from <paramref name="axis"/> provided)</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILAxisCollection.Remove(ILNumerics.Drawing.Plotting.ILAxis)">
            <summary>
            Remove an axis from the collection
            </summary>
            <param name="axis"></param>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxisCollection.Item(ILNumerics.Drawing.AxisNames)">
            <summary>
            Gives the first axis with matching axis name (XAxis/YAxis/ZAxis) or null
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxisCollection.XAxis">
            <summary>
            Give first XAxis from the axis collection, or null
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxisCollection.YAxis">
            <summary>
            Give first YAxis from the axis collection, or null
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILAxisCollection.ZAxis">
            <summary>
            Give first ZAxis from the axis collection, or null
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILAxisCollection.Computation.hull(ILNumerics.ILInArray{System.Single})">
            <summary>
            Gives indices of vertices in <paramref name="points"/> which form a convex hull
            </summary>
            <param name="points">vertices, 2D coordinates, 2 rows, n columns</param>
            <returns>indices of hull of points</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Plotting.ILColorbar">
            <summary>
            Colorbar objects are used to visualize colormaps 
            </summary>
            <remarks>Colorbars are added to arbitrary object groups, supporting the IILColormapProvider interface. <see cref="T:ILNumerics.Drawing.Plotting.ILSurface"/> is a common example. 
            They visualize the colormap and the data range mapped to the colors for the object.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.ILScreenObject">
            <summary>
            Screen oriented rectangle with viewport relative position and size ([0..1])
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILScreenObject.ZCoord">
            <summary>
            Gets or sets the Z coordinate for this screen object. Childs will take this as base depth value.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILScreenObject.Movable">
            <summary>
            Dis-/allows the user to move the rectangle on screen interactively (if supported by the driver). Default: true 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILScreenObject.Border">
            <summary>
            Border of the screen rectangle
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILScreenObject.Background">
            <summary>
            Background fill area 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILScreenObject.Anchor">
            <summary>
            Gets the reference point for the location of the screen rectangle relative to the rectangles size. Default: center of the rectangle (.5,.5)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILScreenObject.Location">
            <summary>
            Location of the anchor point of the screen rectangle in units defined by LocationXUnit and LocationYUnit. Default: viewport center 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILScreenObject.Width">
            <summary>
            Width of the screen rectangle in units defined by WidthUnit. Default: Auto (null); determined by content
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILScreenObject.Height">
            <summary>
            Height of the screen rectangle in units defined by HeightUnit. Default: Auto (null); determined by content
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILScreenObject.MinimumSize">
            <summary>
            Minimum size of the screen rect when Size mode is null (auto), in units defined by WidthUnit and HeightUnit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILScreenObject.LocationXUnit">
            <summary>
            Units for the horizontal location of the anchor point
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILScreenObject.LocationYUnit">
            <summary>
            Units for the vertical location of the anchor point
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILScreenObject.WidthUnit">
            <summary>
            Units for the width of the screen rectangle
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILScreenObject.HeightUnit">
            <summary>
            Units for the height of the screen rectangle
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILColorbar.ColorFillWidth">
            <summary>
            Gets or sets the width of the inner colored bar area; fractions / multiples of the font height in pixels
            </summary>
            <remarks>As measure of the inner colored bar width, the height of the font for the tick labels is used. If the font gets resized, the bar width does so automatically. 
            The tick label font size is determined by ILColorbar.Axis.Ticks.DefaultLabel.Font.Height</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILColorbar.Padding">
            <summary>
            Padding between inner elements of the colorbar and the outer border in units defined by PaddingXUnit and PaddingYUnit
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plotting.ILLegend">
            <summary>
            Legend object
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILLegend.LegendTag">
            <summary>
            Tag used to identify legends in the scene graph
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILLegend.ItemsGroupTag">
            <summary>
            Tag used to identify legend item area group within the scene graph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILLegend.#ctor(System.String[])">
            <summary>
            Create legend object for any suitable plot object in the plot cube; provide label text for all items
            </summary>
            <param name="labels">item label text strings</param>
            <remarks><para>The number of created items depends on the number of elements in labels and the number of plot objects found in the plot cube. 
            The iteration of suitable plot objects in the plot cube is walked. Every object gets a new legend item associated to with the label text given by the 
            corresponding element in <paramref name="labels"/>. If the corresponding element in labels is null, the <see cref="P:ILNumerics.Drawing.ILNode.Tag"/> 
            property of the plot object is used as label text instead. </para>
            <para>The iteration of suitable plot objects is acquired from the subtree of that plot cube in the scene, where this legend object is 
            contained within at time of rendering. If the number of suitable objects found is n, the number of legend items created is min(labels.Count, n). 
            If labels is string[0] (empty array) no items are created. If labels is null, items for all suitable objects are created. </para>
            <para>Not all plot objects are suitable objects for display in a legend. Examples of suitable objects are line plots and contour plots.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Drawing.Plotting.ILLegend.#ctor(ILNumerics.Drawing.ILGroup,System.Collections.Generic.IEnumerable{System.String},System.Object)"/>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILLegend.#ctor(ILNumerics.Drawing.ILGroup,System.Collections.Generic.IEnumerable{System.String},System.Object)">
            <summary>
            Create legend object for automatic configuration
            </summary>
            <param name="root">[optional] root node of the subtree considered for finding legend items automatically. Default: plot cube this legends is in</param>
            <param name="labels">[optional] label text strings for all items to be displayed</param>
            <param name="tag">[optional] tag used to identify this object in the scene</param>
            <remarks><para>The number of created items depends on the number of elements in labels and the number of plot objects found in the plot cube. 
            The iteration of suitable plot objects below <paramref name="root"/> is walked. Every object gets a new legend item associated to it; the label text is taken from the 
            corresponding element in <paramref name="labels"/>. If the corresponding element in labels is null, the <see cref="P:ILNumerics.Drawing.ILNode.Tag"/> 
            property of the plot object is used as label text instead.</para>
            <para>If <paramref name="root"/> is null, the collection of suitable plot objects is acquired from the subtree of the first plot cube in the scene, which lays 
            on the path from the legend up to the scene root at time of rendering. If the number of suitable objects found is n, the number of legend items created is min(labels.Count, n). 
            If labels is string[0] (empty array) no items are created. If labels is null, items for <i>all</i> suitable objects are created. </para>
            <para>Not all plot objects are suitable objects for display in a legend. Examples of suitable objects are line plots and contour plots.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Drawing.Plotting.ILLegend.#ctor(System.String[])"/>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILLegend.#ctor(System.Collections.Generic.IEnumerable{ILNumerics.Drawing.Plotting.ILLegendItem},System.Object)">
            <summary>
            Create a new legend object, provide initial legend items 
            </summary>
            <param name="items">collection of legend items</param>
            <param name="tag">tag object used to identify the legend in the scene</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILLegend.Configure(System.Boolean,System.Boolean)">
            <summary>
            Configures the legend initially and after changes to child objects
            </summary>
            <param name="configureChilds">[optional] triggers childs configuration; default: true</param>
            <param name="configurePath2Root">[optional] triggers parents configuration; default: true</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILLegend.Configure">
            <summary>
            update all existing legend items
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILLegend.LegendItemSize">
            <summary>
            Get or sets the width for the area in pixels where lines &amp; markers are drawn; default: 100px
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILLegend.RootID">
            <summary>
            Gets the root node of the subtree in the scene, which is considered for finding legend items automatically or sets it. Default: the plot cube containing this legend (null)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILLegend.LegendItems">
            <summary>
            Gets the collection of (typed) legend items (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILLegend.Items">
            <summary>
            The collection of node items for display in this legend
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILLegend.Padding">
            <summary>
            Spacing between outer border of the legend and the legend items measured in pixels
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plotting.ILLinePlot">
            <summary>
            A class used to visualize 1-,2- and 3 dimensional data as line plots with markers
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILLinePlot.LinePlotTag">
            <summary>
            Tag identifying line plots within the scene graph
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILLinePlot.MarkerTag">
            <summary>
            Tag identifying markers for line plots within the scene graph
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILLinePlot.LineTag">
            <summary>
            Tag identifying individual lines within the line plot
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILLinePlot.NextColors">
            <summary>
            Color enumerator used to color subsequent lines 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILLinePlot.#ctor(ILNumerics.ILArray{System.Single},System.Object,System.Nullable{System.Drawing.Color},ILNumerics.Drawing.DashStyle,System.Int32,System.Nullable{System.Drawing.Color},ILNumerics.Drawing.MarkerStyle)">
            <summary>
            Creates a new line plot
            </summary>
            <param name="positions">1, 2 or 3D positions as column vectors</param>
            <param name="tag">[optionial] tag identifying the plot in the scene</param>
            <param name="lineColor">[optional] color of the line, default: auto</param>
            <param name="lineStyle">[optional] line style, default: solid</param>
            <param name="lineWidth">[optional] line width, default: 1px</param>
            <param name="markerColor">[optional], color for markers, default: auto</param>
            <param name="markerStyle">[optional], marker style, default: none</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILLinePlot.ConfigureLegendVisual(ILNumerics.Drawing.ILGroup)">
            <summary>
            Creates visual representation for the line
            </summary>
            <param name="renderArea">Root group node for visual output; must provide coord system [0,0,0] -> [1,1,1]</param>
            <remarks>This function is used by legends for rendering</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILLinePlot.ConfigureLegendLabel(ILNumerics.Drawing.ILGroup)">
            <summary>
            Creates textual / label representation for the line
            </summary>
            <param name="renderArea">Root group node for visual output; must provide coord system [0,0,0] -> [1,1,1]</param>
            <remarks>This function is used by legends for rendering</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILLinePlot.GetID">
            <summary>
            Gets the Id of the line plot
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILLinePlot.GetVersion">
            <summary>
            Gets the modification version of the line plot 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILLinePlot.CreateXPlots(ILNumerics.ILInArray{System.Single},System.Collections.Generic.IEnumerable{System.Drawing.Color},System.Collections.Generic.IEnumerable{ILNumerics.Drawing.DashStyle},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{ILNumerics.Drawing.MarkerStyle})">
            <summary>
            Creates a new X-line plot for every row in A
            </summary>
            <param name="A">data matrix with individual line plot data in rows</param>
            <param name="lineColors">[optional] defines colors for lines, plots without corresponding elements get default colors</param>
            <param name="lineStyles">[optional] defines dash styles, plots without corresponding elements are drawn as solid line</param>
            <param name="lineWidth">[optional] defines line width, plots without corresponding elements are drawn as 1px lines</param>
            <param name="markers">[optional] defines marker styles, plots without corresponding elements are drawn without markers</param>
            <returns>Group node containing all line plots created</returns>
            <remarks>The group node returned contains one line plot for every row in A. 
            Every line plot gets a tag according to the following naming scheme: 'LinePlotXXXX', 
            where XXXX corresponds to the row index in A.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILLinePlot.Line">
            <summary>
            Gets access to the line of the line plot 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILLinePlot.Marker">
            <summary>
            Gets access to the marker of the line plot 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILLinePlot.Positions">
            <summary>
            Provides positions of line vertices
            </summary>
            <remarks>This function is used by markers for rendering</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILLinePlot.Indices">
            <summary>
            Provides indices of line vertices
            </summary>
            <remarks>This function is used by markers for rendering</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILMarker.Size">
            <summary>
            Get/set the size of the marker in pixels
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILMarker.Position">
            <summary>
            Get/set the position of the marker in world coords
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILMarker.Fill">
            <summary>
            Get a reference to the triangles shape which represents the inner marker area
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILMarker.Border">
            <summary>
            Gets a reference to the line shape which represents the marker border
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILMarker.Style">
            <summary>
            Gets the style of the marker or sets it.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILPlotCube.DefaultTag">
            <summary>
            Default tag for the plot box group node itself
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILPlotCube.CameraDefaultTag">
            <summary>
            Default tag for the camera node
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILPlotCube.MinZoomDragLimit">
            <summary>
            Get the mouse position distance threshold in pixels before a drag operation is triggered
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILPlotCube.Add``1(``0,System.Object,System.Boolean)">
            <summary>
            Add an object to the first plots data container of this cube
            </summary>
            <typeparam name="T">plot object type</typeparam>
            <param name="node">new plot object</param>
            <param name="tag">[optional] tag identifying the new plot object in the scene</param>
            <returns>The new object added to the scene</returns>
            <remarks>This override redirects Add requests to the first plot data container object within the plot cube.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILPlotCube.AddDataGroup(System.Object)">
            <summary>
            Add a new data group to the data groups of the plot cube
            </summary>
            <param name="tag">[optional] tag used to identify the data group within the scene graph</param>
            <returns>the newly created plot cube data group</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCube.TwoDMode">
            <summary>
            Determines, if this plot cube should be optimized for 2D content (true, default) or for 3D content (false)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCube.AllowPan">
            <summary>
            Determines if users are allowed to move the scene interactively
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCube.AllowRotation">
            <summary>
            Determines if users are allowed to rotate the scene interactively
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCube.AllowZoom">
            <summary>
            Determines if users are allowed to zoom the scene interactively
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCube.Rotation">
            <summary>
            Rotation matrix used to rotate the plot cube
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCube.ZoomRectangle">
            <summary>
            Access to the lines for the zoom rectangle in interactive 2D mode
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCube.ScaleGroup">
            <summary>
            helper node holding box lines, axes and plots data group, scales the plot cube screen rect area
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCube.AutoScaleOnAdd">
            <summary>
            Automatically expand the plotting view limits when a larger new plot is added 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCube.Axes">
            <summary>
            Gets access to the axes collection
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCube.ScaleModes">
            <summary>
            Gets the scale modes collection, used to determine linear / logarithmic scales for eache axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCube.Limits">
            <summary>
            gets / sets the limits for the main plot cube axes 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCube.Lines">
            <summary>
            Allows access to the cube main lines for arbitrary configuration
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCube.Plots">
            <summary>
            Gets the collection of the first (default) plot cube data group, hosting the plot objects 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCube.DataScreenRect">
            <summary>
            Gets the screen recangle of the data cube containing the plots or sets it, default: automatic. range [0..1] of the container.
            </summary>
            <remarks>The data screen rectangle marks the rectangular area on the rendering surface, where the plots are contained. 
            This area depends on the rotation of the plots and does only take the extend of the (rotated and projected) plots within the
            plot cube into account. The space used by labels and ticks are not considered here.
            <para>Per default, the ILNumerics plot cube does automatically determine a good setting in order to make all plot cube 
            elements (ticks &amp; labels) visible. However, for the purpose of aligning a plot cube with another plot cube, it might be helpful to choose the 
            extend manually. </para>
            <para>Note, the rectangle is given in relative coordinates of X and Y within the plot cube screen rect area, as determined by 
            <see cref="P:ILNumerics.Drawing.ILCamera.ScreenRect"/>. (0,0) is the upper left corner of the rectangle within the one defined by ScreenRect. </para>
            </remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCube.Children">
            <summary>
            The collection of plots contained in this plot cubes first data group
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCube.Childs">
            <summary>
            The collection of plots contained in this plot cubes first data group
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILPlotCubeDataGroup.Reset">
            <summary>
            Reset current view limits to show all content
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plotting.ILPlotCubeScaleGroup">
            <summary>
            The class scales the plot cube data area to always fit into the PlotCubeScreeRect rectangle.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILPlotCubeScaleGroup.LinesTag">
            <summary>
            Default tag for the plot cube bounding box lines node
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILPlotCubeScaleGroup.PlotsTag">
            <summary>
            Tag for the Plots group node
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILPlotCubeScaleGroup.AxesTag">
            <summary>
            Tag used to identify the axes collection within the scene graph node
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILPlotCubeScaleGroup.CalculateTransform(ILNumerics.Drawing.ILRenderParameter,System.Drawing.RectangleF)">
            <summary>
            scales and translates the the screen extends of the group node according to the DataScreenRect property
            </summary>
            <param name="parameter">current render parameter</param>
            <param name="screenRect">current setting of DataScreeRect or default/ auto screen rect</param>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILPlotCubeScaleGroup.DataScreenRect">
            <summary>
            If set: the extend of the screen area used by the plot cube internals, relative viewport coordinates [0,0] -> [1,1]. See: ILPlotCube.DataScreeRect
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plotting.ILTickCollection">
            <summary>
            The class represents the collection of ticks for axis objects and is used in ILPlotCube
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILTickCollection.DefaultFontFunc">
            <summary>
            Font creation function used for initial fonts for tick labels; default: 
            gives the default font for all labels (Helvetica, 10pt) 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILTickCollection.TickLinesTag">
            <summary>
            Tag identifying the tick lines within the scene graph 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILTickCollection.TickLabelTag">
            <summary>
            Tag identifying the tick label within the scene graph
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILTickCollection.DefaultTickCreationFunc">
            <summary>
            Default tick creation function for all axis objects with <see cref="T:ILNumerics.Drawing.TickMode"/> set to Automatic. 
            </summary>
            <remarks><para>This defaults to the static <see cref="M:ILNumerics.Drawing.Plotting.ILTickCollection.CreateTicksAuto(System.Single,System.Single,System.Int32,ILNumerics.Drawing.Plotting.ILAxis,ILNumerics.Drawing.AxisScale)"/> function.</para></remarks>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILTickCollection.TickCreationFunc">
            <summary>
            Function used to control the creation of ticks for this axis. Default: <see cref="F:ILNumerics.Drawing.Plotting.ILTickCollection.DefaultTickCreationFunc"/>
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILTickCollection.TickCreationFuncEx">
            <summary>
            Function used to control the creation of ticks for this axis. Default: <see cref="M:ILNumerics.Drawing.Plotting.ILTickCollection.CreateTicksAuto(System.Single,System.Single,System.Int32,ILNumerics.Drawing.Plotting.ILAxis,ILNumerics.Drawing.AxisScale)"/>
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILTickCollection.LabelTransformFunc">
            <summary>
            Function used to control the creation of tick labels from position values. Default: <see cref="F:ILNumerics.Drawing.Plotting.ILTickCollection.DefaultLabelTransformFunc"/>
            </summary>
            <remarks><para>The Func defines the following input parameters:</para>
            <list type="bullets">
            <item>Index (int) - the index of the tick within the collection of all visible ticks; 0-based indexing</item>
            <item>The position value (float) - number used to position the tick along the axis scale</item>
            </list>
            <para>The function returns a string which is directly used to display the tick.</para>
            <para>In order to control the creation of tick labels and/or to implement custom tick filters, one may assign 
            custom (anonymous) functions to <code>LabelTransformFunc</code>.</para>
            </remarks>
        </member>
        <member name="F:ILNumerics.Drawing.Plotting.ILTickCollection.DefaultLabelTransformFunc">
            <summary>
            Default function used to transform tick positions into tick label texts. It applies a simple number transform, 
            taking the current culture into account.
            </summary>
            <remarks><para>The Func defines the following input parameters:</para>
            <list type="bullets">
            <item>Index (int) - the index of the tick within the collection of all visible ticks; 0-based indexing</item>
            <item>The position value (float) - number used to position the tick along the axis scale</item>
            </list>
            <para>The function returns a string which is directly used to display the tick. It is per default used by <code>LabelTransformFunc</code>.</para>
            <para>In order to control the creation of tick labels and/or to implement custom tick filters, one may assign a
            custom (anonymous) function to <code>LabelTransformFunc</code>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILTickCollection.Add(ILNumerics.Drawing.Plotting.ILTick)">
            <summary>
            Add a new tick to the tick collection
            </summary>
            <param name="tick">new tick object</param>
            <returns>the newly added tick object</returns>
            <remarks><para>The tick object returned is not guaranteed to be identical to the one given as <paramref name="tick"/> argument.</para></remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILTickCollection.Add(System.Single,ILNumerics.Drawing.ILLabel)">
            <summary>
            Add a new tick to the tick collection by providing position and a label instance
            </summary>
            <param name="position">tick position</param>
            <param name="label">label object to be used for rendering the tick label</param>
            <returns>newly created tick object</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILTickCollection.Add(System.Single,System.String)">
            <summary>
            Add a new tick to the tick collection by providing position and a label text
            </summary>
            <param name="position">tick position</param>
            <param name="label">text to be used as tick label</param>
            <returns>newly created tick object</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILTickCollection.Clear">
            <summary>
            Remove all ticks from the tick collection
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILTickCollection.Replace(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Replace all existing ticks with a collection of new ticks; does not change current tick Mode
            </summary>
            <param name="ticks">collection of position values</param>
            <remarks><para>Every item in <paramref name="ticks"/> creates a new tick object with the value of the item as position for the new tick.</para>
            <para>Tick labels are automatically created by transforming the position value into a string. Therefore, the <see cref="F:ILNumerics.Drawing.Plotting.ILTickCollection.LabelTransformFunc"/>
            function is used (which by default references <see cref="F:ILNumerics.Drawing.Plotting.ILTickCollection.DefaultLabelTransformFunc"/>). </para>
            <para>In order to control the label text creation process, set the <see cref="F:ILNumerics.Drawing.Plotting.ILTickCollection.LabelTransformFunc"/> to a custom function.</para></remarks>
        </member>
        <!-- Ung端ltiger XML-Kommentar wurde f端r den Member "M:ILNumerics.Drawing.Plotting.ILTickCollection.Replace(System.Collections.Generic.IEnumerable{ILNumerics.Drawing.Plotting.ILTick})" ignoriert -->
        <member name="M:ILNumerics.Drawing.Plotting.ILTickCollection.niceNumber(System.Double,System.Boolean)">
            <summary>
            create "nice" number in fractions of 2 or 5
            </summary>
            <param name="value">value</param>
            <returns>This code was adopted from Paul Heckbert
            from "Graphics Gems", Academic Press, 1990. </returns>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILTickCollection.CreateTicksAuto(System.Single,System.Single,System.Int32,ILNumerics.Drawing.Plotting.ILAxis,ILNumerics.Drawing.AxisScale)">
            <summary>
            Create nice numbers for ticks for arbitrary axes
            </summary>
            <param name="min">lower axis range limit </param>
            <param name="max">upper axis range limit</param>
            <param name="numberTicks">optimal number of ticks (hint)</param>
            <param name="axis">The axis object to create the ticks for (not used)</param>
            <param name="scale">The scaling of the axis, log / lin</param>
            <returns>Enumerable of newly created ticks</returns>
            <remarks><para>This method provides the default implementation of a tick generator for arbitrary axes. It handles logarithmic and 
            linear axes of arbitrary range and size. By returning a collection of <code>ILTick</code> objects, it defines 
            all properties of every tick: position, label text, label properties, major/ minor tick etc.</para>
            <para></para></remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILTickCollection.CreateTicksAuto(System.Single,System.Single,System.Int32)">
            <summary>
            Default ticks creation function, produce nice numbers for linear axes
            </summary>
            <param name="min">minimal axis range</param>
            <param name="max">maximum axis range</param>
            <param name="numberTicks">number of ticks (hint)</param>
            <returns>list of nice ticks positions</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILTickCollection.GetEnumerator">
            <summary>
            Give an enumerator for this tick collection, allows the use inside foreach constructs
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Plotting.ILTickCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Give an enumerator for this tick collection, allows the use inside foreach constructs
            </summary>
            <returns></returns>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILTickCollection.DefaultLabel">
            <summary>
            The label template used to create new tick labels; provides all settings (color, font, ...)
            </summary>
            <remarks>Changes to the default label instance will immediately affect all existing labels in the tick collection!</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILTickCollection.MaxNumberDigitsShowFull">
            <summary>
            Threshold on number of digits allowed for a tick label before it gets abbreviated and the scale label is shown. Default: 5
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILTickCollection.DefaultTickLabelSize">
            <summary>
            Gets the default size of tick labels in pixels or sets it. Default: actual size of <see cref="!:TickSizeMeasureDefaultTemplate"/> with <see cref="!:DefaultLabel.Font"/>.
            </summary>
            <remarks><para>The property is used for axis configuration and layout. It serves as a placeholder for the size of a tick label and helps 
            positioning other components of the axis relative to that size. One example is the axis main label which per default is placed <b>outside</b>
            of the ticks.</para>
            <para>With custom ticks it might be necessary to modify this value in order to better reflect the actual tick label size.</para></remarks>
            <seealso cref="P:ILNumerics.Drawing.Plotting.ILTickCollection.MaxNumberDigitsShowFull"/>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILTickCollection.Count">
            <summary>
            Gets the current number of ticks in the collection (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILTickCollection.Lines">
            <summary>
            Access to the <see cref="T:ILNumerics.Drawing.ILLines"/> shape used for drawing the tick lines
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILTickCollection.Mode">
            <summary>
            Gets the tick creation mode or sets it
            </summary>
            <remarks><para>For TickMode.Auto the ticks for the axis are created automatically (default). TickMode.Manual allows for custom configuration of the ticks.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILTickCollection.Color">
            <summary>
            Gets the color for the lines of the ticks and the main axis line or sets it.
            </summary>
            <remarks><para>This property is a shortcut to the Color property of the Lines member which allows further configuration of the lines.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILTickCollection.Width">
            <summary>
            Gets the thickness of the tick lines or sets it
            </summary>
            <remarks><para>The tickness of the lines is measured in pixels on screen.</para>
            <para>This property is a shortcut to the Width property of the Lines member which allows further configuration of the tick lines.</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILTickCollection.TickLength">
            <summary>
            Gets/sets the length of the ticks; negative values: flip ticks inside plot cube; unit: fraction of DefaultFont height; default: 0.5f
            </summary>
            <remarks><para>The length is measured in fractions of the current DefaultFont.Height, i.e. a value of 1 will produce a tick length of 
            exactly the height of the DefaultFont.</para>
            <para>Negative values for TickLength will draw the ticks in opposite direction. For 2D plots and colorbars this produces ticks reaching 'inside' the content area.</para>
            </remarks>
            <see cref="P:ILNumerics.Drawing.Plotting.ILTickCollection.LengthLevelFraction"/>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILTickCollection.LengthLevelFraction">
            <summary>
            Gets/sets the fraction used to modify the lenght of the ticks for every tick level. Default: 0.5f
            </summary>
            <remarks><para>LengthLevelFraction is used to scale minor ticks up or down in relation to the major ticks. Minor ticks are created by specifying a level > 0 for a tick. 
            The resulting length for a tick is computed by: len = [TickLength * [LengthLevelFracion]^[Level]]</para>
            <para>A value of 0.5 (default) scales minor ticks (level 1) to half the length of major ticks (level 0).</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plotting.ILTickCollection.Item(System.Int32)">
            <summary>
            Retrieve a single tick by index; to be used in Manual Tick Mode only!
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILNodeCollection.Move(System.Int32,System.Int32)">
            <summary>
            moves a node from its current position to a new position
            </summary>
            <param name="currentId">the current position of the node to move</param>
            <param name="targetId">target index of the node, before inserting the new node</param>
        </member>
        <member name="T:ILNumerics.Drawing.ILScene">
            <remarks>The root node of all ILNumerics scene graphs.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILScene.#ctor(ILNumerics.Drawing.ILGroup)">
            <summary>
            Creates a scene from a given scene graph group node 
            </summary>
            <param name="root">existing scene graph root</param>
            <remarks><para>This constructor will create <b>a shallow copy</b> of the existing <paramref name="root"/> node and its 
            children. The copy is done efficiently without copying any buffer data.</para></remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILScene.#ctor(ILNumerics.Drawing.ILScene)">
            <summary>
            Create a complete shallow copy of the complete scene 
            </summary>
            <param name="source">source scene</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILScene.#ctor(System.Boolean)">
            <summary>
            Construct a new empty scene
            </summary>
            <param name="localScene">True: do not create global defaults (Camera, Light, etc.)</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILScene.Snapshot(System.Int64,ILNumerics.Drawing.ILGroup)">
            <summary>
            create a clone of the current scene state (driver-/render task)
            </summary>
            <returns>Clone</returns>
        </member>
        <member name="P:ILNumerics.Drawing.ILScene.AmbientLight">
            <summary>
            Gets the ambient light color or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILScene.MaxLightIntensity">
            <summary>
            Gets or sets the maximum intensity for ligths, used for scaling global lighting
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILScene.Camera">
            <summary>
            Gets a reference to the default camera in the scene
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILScene.Screen">
            <summary>
            Gets a reference to the default Screen2D node of the scene. It establishes a 2D coordinate system.
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILDrawable">
            <summary>
            Base class for drawable scene node objects, like shapes and labels
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILDrawable.#ctor(ILNumerics.Drawing.ILDrawable)">
            <summary>
            Creates a new drawable object as clone of an existing one
            </summary>
            <param name="source">Source object</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILDrawable.#ctor(System.Object)">
            <summary>
            Creates a new drawable object, alternatively specify a tag (recommended).
            </summary>
            <param name="tag">tag, describing the object</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILDrawable.GetPosition">
            <summary>
            Get the anchor position for this object 
            </summary>
            <returns>The current anchor position</returns>
        </member>
        <member name="P:ILNumerics.Drawing.ILDrawable.Color">
            <summary>
            Any color (except null) will override individual object vertex colors. 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILDrawable.IsTransparent">
            <summary>
            determine transparency state for this shape
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILFringe.Width">
            <summary>
            Width of the fringe around a glyph
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILFringe.Color">
            <summary>
            Color for the fringe around the characters
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILLabel.SmallFontTextRenderingHint">
            <summary>
            Defines a hint for rendering font sizes &lt; 16 points. Default: AntiAliasGridFit
            </summary>
            <remarks>Small font sizes may look blurry, when rendered with antialiasing. Per default, AntiAliasGridFit is selected. Setting this property to 
            <see cref="F:System.Drawing.Text.TextRenderingHint.AntiAlias"/> will generate a more smooth output for small fonts.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILLabel.#ctor(ILNumerics.Drawing.ILLabel)">
            <summary>
             Copy constructor
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:ILNumerics.Drawing.ILLabel.MeasureSize">
            <summary>
            Measures the size in screen pixels of the current label state
            </summary>
            <returns>size in pixels as SizeF struct</returns>
        </member>
        <member name="P:ILNumerics.Drawing.ILLabel.DefaultFont">
            <summary>
            Default font for new label objects
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILShape.Configure(System.Boolean,System.Boolean)">
            <summary>
            Configures the shape; must be called after changes to any vertex buffers 
            </summary>
            <param name="configureChildren">[optional] configure subtree; default: true</param>
            <param name="configurePath2Root">[optional] configure nodes on the path to the root node; default: true</param>
            <remarks>Configure must be called to populate changes to the driver. If you can be sure, changes will not effect 
            any other shapes, set <paramref name="configureChildren"/> and/or <paramref name="configurePath2Root"/> to true. This 
            limits the configuration to this shape and may gives better performance.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILShape.Dispose">
            <summary>
            Dispose off this shape, release any references to buffer resources
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILShape.Detach">
            <summary>
            Detach this shapes buffers from any shared buffers and allows individual changes
            </summary>
            <remarks>This function allows a shape to act completely independent of any other shapes in a scene. 
            After calling Detach() changes to local buffers are save to only effect the appearance of this shape. 
            Therefore, any buffers which have been shared will detach from their source and use up individual storage. 
            However, this new storage is not immediately allocated but only, once changes really arrive ("lazy").</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILShape.GetPosition">
            <summary>
            Get midpoint of the vertex positions
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILShape.OnMouseClick(ILNumerics.Drawing.ILMouseEventArgs)">
            <summary>
            Default mouse click handler, toogles the selection state
            </summary>
            <param name="args">ILNumerics mouse event arguments</param>
            <returns>true if the event should get handled further</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILShape.GetPrimitiveCount">
            <summary>
            Get the number of basic primitives which are configured for this shape 
            </summary>
            <returns>number of basic primitives</returns>
            <remarks>The number of basic primitives returned depend on several factors, like 
            <list type="bullet">
            <item>The existence of an index buffer and its size</item>
            <item>The shape type (lines, line strip, triangles, -strip or -fan, etc.)</item>
            </list>
            This function returns the number of basic primitives <strong>defined</strong> - regardless of
            how many of them will later really be drawn. Hence, clipping is not considered here.
            </remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILShape.GetIndicesForSorting(ILNumerics.ILInArray{System.Int32})">
            <summary>
            create indices matrix for individually sortable primitives
            </summary>
            <returns>discrete indices matrix/element (indices) buffer storage</returns>
        </member>
        <member name="P:ILNumerics.Drawing.ILShape.Buffers">
            <summary>
            Get the complete set of buffers for the shape or sets it
            </summary>
            <remarks>Buffer sets contain any buffers for the shape: vertex and index buffers. 
            A buffer set can be shared among multiple shapes in the same way as individual buffers can. Reference 
            counting keeps track of the instances and memory management transparently.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILShape.VerticesPerPrimitive">
            <summary>
            Get the number of vertices every basic primitive type in the shape is composed of
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILShape.Colors">
            <summary>
            Get the buffer with individual colors for the shape or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILShape.SpecularColor">
            <summary>
            Get the specular color if the shape is lit or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILShape.EmissionColor">
            Get the emmisive color if the shape is lit or sets it
        </member>
        <member name="P:ILNumerics.Drawing.ILShape.Shininess">
            Get the shininess factor (basically the size of the shiny reflection) if the shape is lit or sets it
        </member>
        <member name="P:ILNumerics.Drawing.ILShape.AutoNormals">
            Specifies if the normal vectors for lighting are to be computed automatically; default: true
        </member>
        <member name="P:ILNumerics.Drawing.ILShape.Positions">
            <summary>
            Get the buffer with vertex positions or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILShape.Normals">
            <summary>
            Get the buffer with vertex normals or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILShape.Indices">
            <summary>
            Get the buffer with indices composing basic primitives or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILShape.Type">
            <summary>
            Get the primitive type of this shape
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILShape.Limits">
            <summary>
            Get the bounding box limits for this shape
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILShape.Selected">
            <summary>
            Determines if this shape is currently in selected state
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILShape.IsTransparent">
            <summary>
            after configuration: determine transparency state for this shape
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLines.Width">
            <summary>
            Get/set the width of the lines, default: 1
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLines.DashStyle">
            <summary>
            Dash style for the lines, default: solid
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLines.Pattern">
            <summary>
            User defined line stipple pattern for dash style 'UserPattern'
            </summary>
            <remarks>the pattern is defined by corresponding bits 
            set in the short value. It may be stretched via the 
            LinePatternScale parameter. Default: 15</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILLines.PatternScale">
            <summary>
            Scaling for line stipple patterns (default: 2.0f)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLines.Antialiasing">
            <summary>
            Get/set value, if lines are drawn with smooth antialiasing (if possible and supported)
            </summary>
            <remarks>Smooth edges will be drawn if the driver supports antialiased lines. 
            This sometimes comes with the drawback of the lines apppearing to be 
            thicker. Not all objects support antialiasing. Default value is 'false'.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILLines.VerticesPerPrimitive">
            <summary>
            Get the number of vertices used per line: 2
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILPointLight">
            <summary>
            A light in model coordinates 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILPointLight.#ctor(System.Object,ILNumerics.Drawing.Vector3)">
            <summary>
            Creates a new point light
            </summary>
            <param name="tag">[optional] tag identifying the light in the scene</param>
            <param name="position">[optional] position for the new light</param>
        </member>
        <member name="P:ILNumerics.Drawing.ILPointLight.Intensity">
            <summary>
            Light intensity, range: [0 (invisible) ... float.MaxValue]. Default: 1
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPointLight.Position">
            <summary>
            Model coords position for the light. Default: [0,0,0]
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPointLight.Color">
            <summary>
            Ligth color, default: Gray
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoints.#ctor(System.String,System.Nullable{System.Drawing.Color})">
            <summary>
            Create a new points shape
            </summary>
            <param name="tag"></param>
            <param name="color">[optional] color for all points, default: red</param>
        </member>
        <member name="P:ILNumerics.Drawing.ILPoints.Size">
            <summary>
            Diameter for all the points in the shape, size in pixels 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILTriangles.Computation.CreateShapeIndicesIndex(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Creates the index of the shape indices.
            </summary>
            <param name="shapeIndices">The shape indices.</param>
            <returns>index of shape indices</returns>
            <remarks>The index of shape indices is used for fast facette lookup while (auto) creating
            the normal vectors for the vertices. Therefore, the index of every vertex used in the shape
            serves as index for a list of those facettes, where that vertex occures.
            <para>TODO: may be replaced by a custom data structure in order to decrease memory requirements?</para></remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.CreateGear(System.Single,System.Single,System.Single,System.Int32,System.Single)">
            <summary>
            Create a new gear triangle shape with arbitrary parameters
            </summary>
            <param name="inR">inner radius</param>
            <param name="outR">outer radius between tooths</param>
            <param name="toothR">tooth radius</param>
            <param name="toothCount">number of tooths</param>
            <param name="thickness">thickness of the gear</param>
            <returns>New gear triangles shape</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.CreateGearWireframe(System.Single,System.Single,System.Single,System.Int32,System.Single)">
            <summary>
            Create a new gear wireframe lines shape with arbitrary parameters
            </summary>
            <param name="inR">inner radius</param>
            <param name="outR">outer radius between tooths</param>
            <param name="toothR">tooth radius</param>
            <param name="toothCount">number of tooths</param>
            <param name="thickness">thickness of the gear</param>
            <returns>New gear wireframe as lines shape</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Disc50">
            <summary>
            Gets a disc as triangle fan shape, 50 points resolution, single colored: gray
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Disc10">
            <summary>
            Gets a disc as triangle fan shape, 10 points resolution, single colored: gray
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Disc200">
            <summary>
            Gets a disc as triangle fan shape, 200 points resolution, single colored: gray
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Disc100">
            <summary>
            Gets a disc as triangle fan shape, 100 points resolution, single colored: gray
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Circle10">
            <summary>
            Gets a circle as line strip shape, 10 points resolution, single colored: black
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Circle50">
            <summary>
            Gets a circle as line strip shape, 50 points resolution, single colored: black
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Circle100">
            <summary>
            Gets a circle as line strip shape, 100 points resolution, single colored: black
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Circle200">
            <summary>
            Gets a circle as line strip shape, 100 points resolution, single colored: black
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.HemisphereWireframe">
            <summary>
            Get a hemisphere wireframe lines shape, single colored: green
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Hemisphere">
            <summary>
            Get a hemisphere triangles shape, single colored: green, lit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Sphere5Wireframe">
            <summary>
            Get a detailed sphere wireframe lines shape, single colored: green
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.SphereWireframe">
            <summary>
            Get a regular sphere wireframe lines shape, single colored: green
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Sphere3Wireframe">
            <summary>
            Get a rougher sphere wireframe lines shape, single colored: green
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Sphere2Wireframe">
            <summary>
            Get a rough sphere wireframe lines shape, single colored: green
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Sphere5">
            <summary>
            Get a detailed sphere triangles shape, single colored: green, lit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Sphere">
            <summary>
            Get a regular sphere triangles shape, single colored: green, lit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Sphere3">
            <summary>
            Get a rougher sphere triangles shape, single colored: green, lit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Sphere2">
            <summary>
            Get a rough sphere triangles shape, single colored: green, lit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Point">
            <summary>
            Get single point shape at (0,0,0), single colored: red
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Line">
            <summary>
            Get single line shape at (0,0,0) -> (1,1,1), single colored: black
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.TriangleWireframe">
            <summary>
            Gets isosceles triangle wireframe as line strip, single colored: black
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.TriangleEquilateralWireframe">
            <summary>
            Gets equilateral triangle wireframe as line strip, single colored: black
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Triangle">
            <summary>
            Gets isosceles triangle, single colored: blue, unlit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.TriangleEquilateral">
            <summary>
            Get equilateral (even sided) triangle, single colored: blue, unlit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.TriangleRight">
            <summary>
            Get isosceles triangle, right angle at origin, single colored: blue, unlit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.TriangleInterp">
            <summary>
            Gets isosceles triangle, individual colors, unlit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.TriangleEquilateralInterp">
            <summary>
            Get equilateral (even sided) triangle, individual colors, unlit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.TriangleRightInterp">
            <summary>
            Get isosceles triangle, right angle at origin, individual colors, unlit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.TriangleLit">
            <summary>
            Gets isosceles triangle, single colored: blue, lit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.TriangleEquilateralLit">
            <summary>
            Get equilateral (even sided) triangle, single colored: blue, lit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.TriangleRightLit">
            <summary>
            Get isosceles triangle, right angle at origin, single colored: blue, lit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.TriangleInterpLit">
            <summary>
            Gets isosceles triangle, individual colors, lit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.TriangleEquilateralInterpLit">
            <summary>
            Get equilateral (even sided) triangle, individual colors, lit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.TriangleRightInterpLit">
            <summary>
            Get isosceles triangle, right angle at origin, individual colors, lit
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.UnitCubeWireframe">
            <summary>
            Create unit cube wireframe: (0,0,0) -> (1,1,1)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.UnitCubeFilled">
            <summary>
            Create filled unit cube: (0,0,0) -> (1,1,1) (shared vertices)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.UnitCubeFilledLit">
            <summary>
            Create filled unit cube: (0,0,0) -> (1,1,1) (optimized for lighting)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.RectangleWireframe">
            <summary>
            Create rectangle in XY plane: (0,0),(0,1),(1,1),(1,0)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.RectangleFilled">
            <summary>
            Create filled rectangle in XY plane: (0,0) -> (1,1)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Gear2">
            <summary>
            Gets a gear triangle shape with 2 tooths
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Gear5">
            <summary>
            Gets a gear triangle shape with 5 tooths
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Gear10">
            <summary>
            Gets a gear triangle shape with 10 tooths
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Gear15">
            <summary>
            Gets a gear triangle shape with 15 tooths
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Gear25">
            <summary>
            Gets a gear triangle shape with 25 tooths
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Gear2Wireframe">
            <summary>
            Gets a gear wireframe line shape with 2 tooths
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Gear5Wireframe">
            <summary>
            Gets a gear wireframe line shape with 5 tooths
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Gear10Wireframe">
            <summary>
            Gets a gear wireframe line shape with 10 tooths
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Gear15Wireframe">
            <summary>
            Gets a gear wireframe line shape with 15 tooths
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.Gear25Wireframe">
            <summary>
            Gets a gear wireframe line shape with 25 tooths
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Triangle.ClipPlaneChecked">
            <summary>
            internal flag storing, which clip planes have been checked for the triangle already 
            </summary>
        </member>
        <member name="T:ILNumerics.MachineParameterSingle">
            <summary>
            Extensive numerical machine parameter infos - single precision
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.ibeta">
            <summary>
            Radix
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.it">
            <summary>
            Number of base digits(bits) in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.irnd">
            <summary>
            Rounding and underflow information.  
            </summary>
            <remarks><list type="bullet"><listheader>Rounding properties</listheader>
            <item>2,5: IEEE rounding conform </item>
            <item>1,4: not IEEE conform rounding </item>
            <item>0,3: truncating - no rounding </item></list>
            <list type="bullet"><listheader>Under-/ Overflow. numbers below xmin will be interpreted as... </listheader>
            <item>0,1,2: zero</item>
            <item>3,4,5: xmin (IEEE conform)</item></list></remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.ngrd">
            <summary>
            Number of guard digits in the product of 2 mantissas
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.machep">
            <summary>
            Exponent of the smalles number ibeta^machep &gt; 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.negep">
            <summary>
            Exponent of smallest number ibeta^negep wich may be substracted from 1.0, giving a result not equal to 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.iexp">
            <summary>
            Number of exponent bits 
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.minexp">
            <summary>
            Smallest power of ibeta without leading zeros in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.maxexp">
            <summary>
            Smallest power of ibeta where overflow occours
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.eps">
            <summary>
            Distance between the smallest number &gt; 1.0, distinguishable from 1.0 and 1.0
            </summary>
            <remarks>This number is computed by ibeta <sup>machep</sup>.</remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.epsneg">
            <summary>
            Alternative eps. ibeta <sup>negep</sup>
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.xmin">
            <summary>
            Smallest floating point number
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.xmax">
            <summary>
            Largest floating point number
            </summary>
        </member>
        <member name="T:ILNumerics.MachineParameterDouble">
            <summary>
            Extensive numerical machine parameter infos - double precision
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.ibeta">
            <summary>
            Radix
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.it">
            <summary>
            Number of base digits(bits) in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.irnd">
            <summary>
            Rounding and underflow information.  
            </summary>
            <remarks><list type="bullet"><listheader>Rounding properties</listheader>
            <item>2,5: IEEE rounding conform </item>
            <item>1,4: not IEEE conform rounding </item>
            <item>0,3: truncating - no rounding </item></list>
            <list type="bullet"><listheader>Under-/ Overflow. numbers below xmin will be interpreted as... </listheader>
            <item>0,1,2: zero</item>
            <item>3,4,5: xmin (IEEE conform)</item></list></remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.ngrd">
            <summary>
            Number of guard digits in the product of 2 mantissas
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.machep">
            <summary>
            Exponent of the smalles number ibeta^machep &gt; 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.negep">
            <summary>
            Exponent of smallest number ibeta^negep wich may be substracted from 1.0, giving a result not equal to 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.iexp">
            <summary>
            Number of exponent bits 
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.minexp">
            <summary>
            Smallest power of ibeta without leading zeros in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.maxexp">
            <summary>
            Smallest power of ibeta where overflow occours
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.eps">
            <summary>
            Distance between the smallest number &gt; 1.0, distinguishable from 1.0 and 1.0
            </summary>
            <remarks>This number is computed by ibeta <sup>machep</sup>.</remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.epsneg">
            <summary>
            Alternative eps. ibeta <sup>negep</sup>
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.xmin">
            <summary>
            Smallest floating point number
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.xmax">
            <summary>
            Largest floating point number
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes">
            <summary>
            All toolboxes currently available in ILNumerics 
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.MachineLearning">
            <summary>
             Machine Learning Toolbox
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.Statistics">
            <summary>
            Statistics Toolbox
            </summary>
        </member>
        <member name="T:ILNumerics.LogicalConversionMode">
            <summary>
            Modes for implicit conversions from logical arrays to System.Boolean 
            </summary>
            <remarks>
            <seealso cref="P:ILNumerics.Settings.LogicalArrayToBoolConversion"/></remarks>
        </member>
        <member name="F:ILNumerics.LogicalConversionMode.NonScalarThrowsException">
            <summary>
            Throw an exception on the attempt to convert a non scaler value to logical/boolean.
            </summary>
        </member>
        <member name="F:ILNumerics.LogicalConversionMode.ImplicitAllAll">
            <summary>
            Convert non scalar values to logical/boolean by applying the allall() function (i.e. it is true when all elements are non zero).
            </summary>
        </member>
        <member name="T:ILNumerics.NumericType">
            <summary>
            Enumerate all numeric type names used by ILNumerics
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Double">
            <summary>
            double element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Single">
            <summary>
            float element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Complex">
            <summary>
            complex element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.FComplex">
            <summary>
            fcomplex element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Byte">
            <summary>
            byte element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Int32">
            <summary>
            Int32 element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Int64">
            <summary>
            Int64 element type.
            </summary>
        </member>
        <member name="T:ILNumerics.ILArrayStreamSerializationFlags">
            <summary>
            Defines the way ILArrays are serialized to stream.
            </summary>
            <seealso cref="M:ILNumerics.ILDenseArray`1.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)"/>
        </member>
        <member name="F:ILNumerics.ILArrayStreamSerializationFlags.Serial">
            <summary>
            Print values 'vectorized': one value after each other. The true dimension configuration 
            of the array will be lost in the result. 
            </summary>
        </member>
        <member name="F:ILNumerics.ILArrayStreamSerializationFlags.Formatted">
            <summary>
            Print values 'matrixwise'. The real dimensions configuration for the array are kept 
            in the result. The array will be printed by pages, consisting out of the 1st and 2nd 
            leading dimnsion. A dimension tag will prefix each page. The format can be used as 
            fancier output version for human reading as well as human readable serialization 
            format. ILArray's are capable of constructing from streams containing this type of 
            output. 
            </summary>
        </member>
        <member name="F:ILNumerics.ILArrayStreamSerializationFlags.Matlab">
            <summary>
            Export whole array instance to matlab 5.0 format
            </summary>
        </member>
        <member name="T:ILNumerics.MatrixProperties">
            <summary>
            Possible properties for matrices 
            </summary>
            <remarks><para>These properties may be returned by function overloads receiving a MatrixProperties 
            parameter by reference. </para>
            <para><![CDATA[This enum is a bitflag'ed enum! You may query for any combination via the bitwise operators | and &. ]]></para></remarks>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Hermitian">
            <summary>
            Hermitian matrix 
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.PositivDefinite">
            <summary>
            Positive definite
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.UpperTriangular">
            <summary>
            Upper triangular matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.LowerTriangular">
            <summary>
            Lower triangular matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Square">
            <summary>
            Square matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Diagonal">
            <summary>
            Diagonal matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Singular">
            <summary>
            The matrix is singular 
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Hessenberg">
            <summary>
            Hessenberg matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Householder">
            <summary>
            Householder matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Unitary">
            <summary>
            Unitary matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Orthogonal">
            <summary>
            Orthogonal matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Orthonormal">
            <summary>
            Orthonormal matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.RankDeficient">
            <summary>
            The matrix has deficient rank
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.None">
            <summary>
            The matrix has no special properties
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Unknown">
            <summary>
            No specific properties known (default)
            </summary>
        </member>
        <member name="T:ILNumerics.Misc.ILCacheManager">
            <summary>
            Manages local array caches, singleton instance is accessed via: ILNumerics.ILArrayCache&lt;T;gt;.Manager
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILCacheManager.GetCache">
            <summary>
            Create a new ILArrayCache and add to managed caches
            </summary>
            <returns>The new cache</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILCacheManager.FreeAllCaches">
            <summary>
            Dispose all managed caches
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILCacheManager.Manager">
            <summary>
            Singleton instance of a cache manager, used to retrieve local array caches 
            </summary>
        </member>
        <member name="T:ILNumerics.complex">
            <summary>
            Floating point complex value data type of double precision
            </summary>
            <remarks>This class extends the system value types for real numbers to complex double 
            values. Besides the publicly available members 'real' and 'imag' it provides all the 
            basis functionality the floating point system.double brings (abs, log, sqrt, tan etc.),
            as well as it overrides the basic unary and binary operators for all common system value 
            types including rarely used types (e.g. UInt16). This includes the basic numerical operations 
            like '+','-','/','*' and the relational operators: '==','>','>=' etc. Also there are some 
            explicit and some implicit casting operators from / to complex value into system 
            value types.</remarks>
        </member>
        <member name="F:ILNumerics.complex.real">
            <summary>
            Real part of this complex number
            </summary>
        </member>
        <member name="F:ILNumerics.complex.imag">
            <summary>
            Imaginary part of this complex number
            </summary>
        </member>
        <member name="F:ILNumerics.complex.i">
            <summary>
            Imaginary unit 
            </summary>
        </member>
        <member name="M:ILNumerics.complex.#ctor(System.Double,System.Double)">
            <summary>
            Constructor creating a new complex value
            </summary>
            <param name="real">Real part</param>
            <param name="imag">Imaginary part</param>
        </member>
        <member name="M:ILNumerics.complex.Equals(System.Object)">
            <summary>
            Are obj's real and imaginary part identical to the real and imaginary parts of this fcomplex
            </summary>
            <param name="obj">fcomplex object to determine the equality for</param>
            <returns>true if obj is of fcomplex type and its real and imag part has the same 
            values as the real and imaginary part of this array.</returns>
        </member>
        <member name="M:ILNumerics.complex.Equals(ILNumerics.complex)">
            <summary>
            Check if a complex number equals this complex number
            </summary>
            <param name="other">other complex number</param>
            <returns>true if both, real and imaginary parts of both complex number are (binary) equal, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.complex.GetHashCode">
            <summary>
            Hash code of this comples
            </summary>
            <returns>Hash code of this complex</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Subtract two complex values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Multiply two complex values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
            <remarks><para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
            <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true, if real and imaginary part are identical</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Subtract two complex values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Multiply two complex values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
            <remarks><para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
            <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true, if real and imaginary part are identical</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Double)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Double)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Double)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Double)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Double)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Double)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Double)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Double)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Double)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Double)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Int64)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Int64)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Int64)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Int64)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Int64)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Int64)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Int64)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Int64)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Int64)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Int64)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Int32)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Int32)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Int32)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Int32)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Int32)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Int32)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Int32)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Int32)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Int32)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Int32)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Single)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Single)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Single)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Single)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Single)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Single)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Single)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Single)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Single)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Single)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Byte)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Byte)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Byte)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Byte)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Byte)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Byte)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Byte)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Byte)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Byte)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Byte)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Double,ILNumerics.complex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Double,ILNumerics.complex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Double,ILNumerics.complex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Double,ILNumerics.complex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Double,ILNumerics.complex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Double,ILNumerics.complex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Double,ILNumerics.complex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Double,ILNumerics.complex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Double,ILNumerics.complex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Double,ILNumerics.complex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Int64,ILNumerics.complex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Int64,ILNumerics.complex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Int64,ILNumerics.complex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Int64,ILNumerics.complex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Int64,ILNumerics.complex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Int64,ILNumerics.complex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Int64,ILNumerics.complex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Int64,ILNumerics.complex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Int64,ILNumerics.complex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Int64,ILNumerics.complex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Int32,ILNumerics.complex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Int32,ILNumerics.complex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Int32,ILNumerics.complex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Int32,ILNumerics.complex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Int32,ILNumerics.complex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Int32,ILNumerics.complex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Int32,ILNumerics.complex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Int32,ILNumerics.complex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Int32,ILNumerics.complex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Int32,ILNumerics.complex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Single,ILNumerics.complex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Single,ILNumerics.complex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Single,ILNumerics.complex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Single,ILNumerics.complex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Single,ILNumerics.complex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Single,ILNumerics.complex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Single,ILNumerics.complex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Single,ILNumerics.complex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Single,ILNumerics.complex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Single,ILNumerics.complex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Byte,ILNumerics.complex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Byte,ILNumerics.complex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Byte,ILNumerics.complex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Byte,ILNumerics.complex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Byte,ILNumerics.complex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Byte,ILNumerics.complex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Byte,ILNumerics.complex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Byte,ILNumerics.complex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Byte,ILNumerics.complex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Byte,ILNumerics.complex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_UnaryNegation(ILNumerics.complex)">
            <summary>
            Unary minus operator
            </summary>
            <param name="A">Complex input</param>
            <returns>Complex number similar to A, having real and imag part negated</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Double)~ILNumerics.complex">
            <summary>
            Cast value to complex number
            </summary>
            <param name="a">Value to cast</param>
            <returns>Complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Single)~ILNumerics.complex">
            <summary>
            Cast value to complex number
            </summary>
            <param name="a">Value to cast</param>
            <returns>Complex number with the real part having the same value as the a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(ILNumerics.fcomplex)~ILNumerics.complex">
            <summary>
            Cast value to complex number
            </summary>
            <param name="a">Value to cast</param>
            <returns>Complex number being a copy of the real and imaginary parts of a.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Byte)~ILNumerics.complex">
            <summary>
            Cast value to complex number
            </summary>
            <param name="a">Value to cast</param>
            <returns>Complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Int32)~ILNumerics.complex">
            <summary>
            Cast value to complex number
            </summary>
            <param name="a">Value to cast</param>
            <returns>Complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Int64)~ILNumerics.complex">
            <summary>
            Cast value to complex number
            </summary>
            <param name="a">Value to cast</param>
            <returns>Complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Double">
            <summary>
            Cast value from complex number
            </summary>
            <param name="a">Complex value to cast</param>
            <returns>Double number with the real part of a </returns>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Single">
            <summary>
            Cast value from complex number
            </summary>
            <param name="a">Complex value to cast</param>
            <returns>number with the real part of a </returns>
            <remarks>the return value is the result of a cast from double to float.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~ILNumerics.fcomplex">
            <summary>
            Cast value from complex number
            </summary>
            <param name="a">Complex value to cast</param>
            <returns>float complex number with the real and imaginary parts being a copy of a </returns>
            <remarks>The real and imaginary parts are the result of a cast to float.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Byte">
            <summary>
            Cast value from complex number
            </summary>
            <param name="a">Complex value to cast</param>
            <returns>Number with the real part of a </returns>
            <remarks>The return value is the result of a cast to byte.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Int32">
            <summary>
            Cast value from complex number
            </summary>
            <param name="a">Complex value to cast</param>
            <returns>Number with the real part of a </returns>
            <remarks>The return value is the result of a cast to Int32.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Int64">
            <summary>
            Cast value from complex number
            </summary>
            <param name="a">Complex value to cast</param>
            <returns>number with the real part of a </returns>
            <remarks>the return value is the result of a cast to Int64.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Abs(ILNumerics.complex)">
            <summary>
            Absolute value of input
            </summary>
            <param name="input">Input value</param>
            <returns>The absolute value of the input</returns>
        </member>
        <member name="M:ILNumerics.complex.Angle(ILNumerics.complex)">
            <summary>
            Phase angle of complex number
            </summary>
            <param name="input">Input value</param>
            <returns>The phase angle of the input</returns>
            <remarks>For the result the Atan2 function of the <see cref="T:System.Math"/> class is used.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Atan(ILNumerics.complex)">
            <summary>
            Arcus tangens of complex input
            </summary>
            <param name="input">Complex input</param>
            <returns>Arcus tangens of complex input</returns>
            <remarks></remarks>
        </member>
        <member name="M:ILNumerics.complex.Acos(ILNumerics.complex)">
            <summary>
            Arcus cosinus of complex input
            </summary>
            <param name="input">Complex input</param>
            <returns>Arcus cosinus of input</returns>
        </member>
        <member name="M:ILNumerics.complex.Acos(System.Double)">
            <summary>
            Arcus cosinus of input
            </summary>
            <param name="input">Input value</param>
            <returns>Arcus cosinus of input</returns>
        </member>
        <member name="M:ILNumerics.complex.Asin(System.Double)">
            <summary>
            Arcus sinus of complex input
            </summary>
            <param name="input">Input value</param>
            <returns>Arcus sinus of input</returns>
        </member>
        <member name="M:ILNumerics.complex.Asin(ILNumerics.complex)">
            <summary>
            Arcus sinus of input
            </summary>
            <param name="input">Input value</param>
            <returns>Arcus sinus of  input</returns>
        </member>
        <member name="M:ILNumerics.complex.Ceiling(ILNumerics.complex)">
            <summary>
            Round towards positive infinity
            </summary>
            <param name="input">Input value</param>
            <returns>Result is the next integer value greater then input</returns>
            <remarks>ILMath.Ceiling operates in both: real and imaginary parts seperately</remarks>
        </member>
        <member name="M:ILNumerics.complex.Floor(ILNumerics.complex)">
            <summary>
            Round towards negative infinity
            </summary>
            <param name="input">Input value</param>
            <returns>Result is the next integer value lower then input</returns>
            <remarks>ILMath.Floor operates in both: real and imaginary parts seperately</remarks>
        </member>
        <member name="M:ILNumerics.complex.Round(ILNumerics.complex)">
            <summary>
            Rounds towards nearest integer
            </summary>
            <param name="input">Input value</param>
            <returns>Result is the nearest integer value for input</returns>
            <remarks>ILMath.Round operates in both: real and imaginary parts deperately</remarks>
        </member>
        <member name="M:ILNumerics.complex.Sign(ILNumerics.complex)">
            <summary>
            Signum function
            </summary>
            <param name="input">Complex input </param>
            <returns>Sesult as input / Abs(input)</returns>
            <remarks>Sign(input) with input being complex returns the projection onto
            the unit circle. If input is 0+0i the result will be 0+0i.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Truncate(ILNumerics.complex)">
            <summary>
            Truncate a floating point complex value
            </summary>
            <param name="input">Input value</param>
            <returns>Integer part of input</returns>
            <remarks>Operates on real and imaginary parts seperately.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Cos(ILNumerics.complex)">
            <summary>
            Cosinus
            </summary>
            <param name="input">Input value</param>
            <returns>Cosine of input</returns>
            <remarks><para>The cosine is computed by the trigonometric euler equation: </para>
            <para>0.5 * [exp(i input) + exp(-i input)]</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Cosh(ILNumerics.complex)">
            <summary>
            Cosinus hyperbolicus
            </summary>
            <param name="input">Input</param>
            <returns>Cosine hyperbolicus of input</returns>
            <remarks><para>The cosine is computed by the trigonometric euler equation: </para>
            <para>(Exp(input) + Exp(-1.0 * input)) / 2.0</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Sin(ILNumerics.complex)">
            <summary>
            Sinus
            </summary>
            <param name="input">Input value</param>
            <returns>Sinus of input</returns>
            <remarks><para>The sinus is computed by the trigonometric euler equation: </para>
            <para>(Exp(i * input) - Exp(-1.0 * i * input)) / (2.0 * i)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Sinh(ILNumerics.complex)">
            <summary>
            Sinus hyperbolicus
            </summary>
            <param name="input">Input</param>
            <returns>Sinus hyperbolicus of input</returns>
            <remarks><para>The sinus hyperbolicus is computed by the trigonometric euler equation: </para>
            <para>(Exp(input) - Exp(-1.0 * input)) / 2.0</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Exp(ILNumerics.complex)">
            <summary>
            Complex exponent
            </summary>
            <param name="exponent">Exponent</param>
            <returns>Result of exp(exponent)</returns>
            <remarks>For complex exponents, exp(exponent) is computed by
            <para>complex.FromPol(Math.Exp(exponent.real), exponent.imag)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Pow(ILNumerics.complex,System.Double)">
            <summary>
            Complex power for real exponent
            </summary>
            <param name="input">Basis</param>
            <param name="exponent">Exponent</param>
            <returns>Result of input power exponent</returns>
            <remarks>The computation will be carried out by 
            <para>exp(log(input) * exponent)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Pow(System.Double,System.Double)">
            <summary>
            Complex power - real basis, real exponent
            </summary>
            <param name="basis">Basis</param>
            <param name="exponent">Exponent</param>
            <returns>Complex number.</returns>
            <remarks>The result will be a complex number. For negative basis 
            the basis will be converted to a complex number and the power 
            will be computed in the complex plane.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Pow(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Complex power - complex exponent
            </summary>
            <param name="basis">Basis</param>
            <param name="exponent">Exponent</param>
            <returns>Complex number exp(log(basis) * exponent).</returns>
            <remarks>The result will be the complex number exp(log(basis) * exponent). </remarks>
        </member>
        <member name="M:ILNumerics.complex.Sqrt(System.Double)">
            <summary>
            Square root
            </summary>
            <param name="input">Input value</param>
            <returns>The square root of input</returns>
            <remarks>If input is smaller than 0.0, the computation will be done in the complex plane. </remarks>
        </member>
        <member name="M:ILNumerics.complex.Sqrt(ILNumerics.complex)">
            <summary>
            Square root
            </summary>
            <param name="input">Input value</param>
            <returns>The square root of input</returns>
            <remarks>Numerical recipes in C: Appendix C </remarks>
        </member>
        <member name="M:ILNumerics.complex.Tan(ILNumerics.complex)">
            <summary>
            Tangens
            </summary>
            <param name="input">Input value</param>
            <returns>Tangens of input</returns>
            <remarks>The tangens is 
            <para>sin(input) / cos(input)</para>
            if cos(input) == 0.0+0.0i, INF will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Tanh(ILNumerics.complex)">
            <summary>
            Tangens hyperbolicus
            </summary>
            <param name="input">Input value</param>
            <returns>Tangens hyperbolicus</returns>
            <remarks>The tangens hyperbolicus is 
            <para>sinh(input) / cosh(input)</para>
            if cosh(input) == 0.0+0.0i, INF will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Log(ILNumerics.complex)">
            <summary>
            Complex logarithm 
            </summary>
            <param name="input">Input value</param>
            <returns>Complex logarithm of input</returns>
            <remarks>The real part of the logarithm is computed by 
            <para>log (abs (input))</para>
            <para>The imaginary part holds the phase of input.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.complex.Log(System.Double)">
            <summary>
            Logarithm of real input 
            </summary>
            <param name="input">Input value - may be negative</param>
            <returns>Complex logarithm</returns>
        </member>
        <member name="M:ILNumerics.complex.Log10(System.Double)">
            <summary>
            Logarithm of base 10 of real input 
            </summary>
            <param name="input">Input value - may be negative</param>
            <returns>Complex logarithm of base 10</returns>
        </member>
        <member name="M:ILNumerics.complex.Log2(System.Double)">
            <summary>
            Logarithm of base 2 of real input 
            </summary>
            <param name="input">Input value - may be negative</param>
            <returns>Complex logarithm of base 2</returns>
        </member>
        <member name="M:ILNumerics.complex.Log10(ILNumerics.complex)">
            <summary>
            Logarithm of base 10
            </summary>
            <param name="input">Input value</param>
            <returns>Logarithm of base 10</returns>
            <seealso cref="M:ILNumerics.complex.Log(ILNumerics.complex)"/>
        </member>
        <member name="M:ILNumerics.complex.Log2(ILNumerics.complex)">
            <summary>
            Logarithm of base 2
            </summary>
            <param name="input">Input value</param>
            <returns>Logarithm of base 2.</returns>
            <seealso cref="M:ILNumerics.complex.Log(ILNumerics.complex)"/>
        </member>
        <member name="M:ILNumerics.complex.FromPol(System.Double,System.Double)">
            <summary>
            Convert polar notation into cartesian notation
            </summary>
            <param name="magnitude">Magnitude</param>
            <param name="angle">Phase</param>
            <returns>Complex value having magnitude and phase</returns>
        </member>
        <member name="M:ILNumerics.complex.ToString">
            <summary>
            Convert to string
            </summary>
            <returns>String displaying the comlex number (full precision)</returns>
        </member>
        <member name="M:ILNumerics.complex.ToString(System.Int32)">
            <summary>
            Print formated output of this number, determine number of digits
            </summary>
            <param name="digits">Number of digits</param>
            <returns>Formated output</returns>
        </member>
        <member name="M:ILNumerics.complex.Abs">
            <summary>
            Magnitude of this complex instance
            </summary>
            <returns>Magnitude</returns>
        </member>
        <member name="M:ILNumerics.complex.Angle">
            <summary>
            Phase of this complex instance
            </summary>
            <returns>Phase</returns>
        </member>
        <member name="M:ILNumerics.complex.Acos">
            <summary>
            Arcus cosinus of this complex instance
            </summary>
            <returns>Arcus cosinus</returns>
        </member>
        <member name="M:ILNumerics.complex.Asin">
            <summary>
            Arcus sinus of this complex instance
            </summary>
            <returns>arcus sinus</returns>
        </member>
        <member name="M:ILNumerics.complex.Exp">
            <summary>
            Exponential / power of base e
            </summary>
            <returns>Power of base e</returns>
        </member>
        <member name="M:ILNumerics.complex.Pow(System.Double)">
            <summary>
            Complex power real exponent
            </summary>
            <param name="exponent">Exponent</param>
            <returns>New complex number with result</returns>
            <remarks>If this instance is a and the exponent is e than 
            the result will be the complex number exp(log(a) * e). </remarks>
        </member>
        <member name="M:ILNumerics.complex.Pow(ILNumerics.complex)">
            <summary>
            Complex power - complex exponent
            </summary>
            <param name="exponent">Exponent</param>
            <returns>Complex number exp(log(this) * exponent).</returns>
            <remarks>If this instance is a than 
            the result will be the complex number exp(log(a) * exponent). </remarks>
        </member>
        <member name="M:ILNumerics.complex.Sqrt">
            <summary>
            Square root of this complex value
            </summary>
            <returns>Square root of this complex value</returns>
        </member>
        <member name="M:ILNumerics.complex.Log">
            <summary>
            Logarithm of base e
            </summary>
            <returns>Logarithm of base e</returns>
            <remarks>The logarithm of a complex number A is defined as follows: <br />
            <list type="none"><item>real part: log(abs(A))</item>
            <item>imag part: Atan2(imag(A),real(A))</item></list>
            </remarks>
        </member>
        <member name="M:ILNumerics.complex.IsNaN(ILNumerics.complex)">
            <summary>
            Test if any of real or imaginary parts are NAN's
            </summary>
            <param name="input">Complex number to test</param>
            <returns>true if any of real or imag part is not a number</returns>
        </member>
        <member name="M:ILNumerics.complex.IsInfinity(ILNumerics.complex)">
            <summary>
            Test if any of real or imaginary parts are infinite
            </summary>
            <param name="input">Complex number to test</param>
            <returns>true if any of real or imag part is infinite</returns>
        </member>
        <member name="M:ILNumerics.complex.IsPositiveInfinity(ILNumerics.complex)">
            <summary>
            Test if any of real or imaginary parts are pos.nfinite
            </summary>
            <param name="input">Complex number to test</param>
            <returns>true if any of real or imag part is positive infinite</returns>
        </member>
        <member name="M:ILNumerics.complex.IsNegativeInfinity(ILNumerics.complex)">
            <summary>
            Test if any of real or imaginary parts are neg. infinite
            </summary>
            <param name="input">Complex number to test</param>
            <returns>true if any of real or imag part is negative infinite</returns>
        </member>
        <member name="M:ILNumerics.complex.IsFinite(ILNumerics.complex)">
            <summary>
            Test if any of real or imaginary parts are finite
            </summary>
            <param name="input">Complex number to test</param>
            <returns>true if any of real and imag part is finite</returns>
        </member>
        <member name="M:ILNumerics.complex.iszero">
            <summary>
            Test if both of real or imaginary parts are 0
            </summary>
            <returns>true if real and imag part is 0</returns>
        </member>
        <member name="P:ILNumerics.complex.conj">
            <summary>
            Complex conjugate 
            </summary>
        </member>
        <member name="P:ILNumerics.complex.INF">
            <summary>
            Positive infinity for real and imag part of complex value
            </summary>
        </member>
        <member name="P:ILNumerics.complex.Zero">
            <summary>
            New complex, real and imaginary parts are zero
            </summary>
        </member>
        <member name="P:ILNumerics.complex.NaN">
            <summary>
            Complex quantity, marked as being "not a number"
            </summary>
        </member>
        <member name="T:ILNumerics.ILExtensionMethods">
            <summary>
            Extension methods for ILNumerics types
            </summary>
        </member>
        <member name="M:ILNumerics.ILExtensionMethods.ToMSComplex(ILNumerics.ILArray{ILNumerics.complex},System.Numerics.Complex[])">
            <summary> 
            Convert this complex ILNumerics array to a system array of type System.Numerics.Complex[]
            </summary>
            <param name="A">this ILNumerics array</param>
            <param name="Storage">[option] if given, this system array will be used as storage for the conversion. Defaul: null (a new System.Array is returned)</param>
            <returns>System.Array with the elements of A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the storage given does not have sufficient length for all elements of the ILNumerics array</exception>
            <remarks><para>The elements of the ILNumerics array will be copied to the System.Array and converted to the System.Numerics.Complex type.</para>
            <para>The System.Array returned will contain all elements of the ILNumerics arrays after conversion - in column major order.</para>
            <example>
            This example demonstrates a common scenario for interchanging System.Numerics.Complex[] with ILNumerics complex arrays. It takes the converion between System.Numerics.Complex and ILNumerics.complex 
            into account, as well as the memory management of all storage involved. 
            <code>
            ILArray&lt;complex&gt; A = sqrtc(B); 
            // interfacing an external library as System.Numerics.Complex[]
            // We dont provide a System.Array as target for the conversion,
            // so it will be fetched from the ILNumerics memory management. 
            System.Numerics.Complex[] A_MSComplex = A.ToMSComplex(); 
            // .. do some work here with A_MSComplex
            // ...
            // The results get converted back to ILNumerics array 
            ILArray&lt;complex&gt; Result = A_MSComplex.ToILArray(A.S, true); 
            </code>
            <para>For the conversion of the System.Numerics.Complex[] array back to an ILNumerics array, we use the same size (<c>A.S</c>) as before. Here, any size 
            would work, as long as it fits into the number of elements of the source System.Array.</para>
            <para>Note that the calls to <c>A.ToMSComplex()</c> and <c>A_MSComplex.ToILArray(A.S, true)</c> will fetch and return all System.Arrays involved into/from the 
            ILINumerics memory pool. So if called frequently, no pressure on the GC is produced, what qualifies this scheme for high performance scenarios.</para> 
            </example>
            </remarks>
            <seealso cref="M:ILNumerics.ILExtensionMethods.ToILArray(System.Numerics.Complex[],ILNumerics.ILSize,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILExtensionMethods.ToMSComplex(ILNumerics.ILInArray{ILNumerics.complex},System.Numerics.Complex[])">
            <summary>
            Convert this complex ILNumerics array to a system array of type System.Numerics.Complex[]
            </summary>
            <param name="A">this ILNumerics array</param>
            <param name="Storage">[option] if given, this system array will be used as storage for the conversion. Defaul: null (a new System.Array is returned)</param>
            <returns>System.Array with the elements of A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the storage given does not have sufficient length for all elements of the ILNumerics array</exception>
            <remarks><para>The elements of the ILNumerics array will be copied to the System.Array and converted to the System.Numerics.Complex type.</para>
            <para>The System.Array returned will contain all elements of the ILNumerics arrays after conversion - in column major order.</para>
            <example>
            This example demonstrates a common scenario for interchanging System.Numerics.Complex[] with ILNumerics complex arrays. It takes the converion between System.Numerics.Complex and ILNumerics.complex 
            into account, as well as the memory management of all storage involved. 
            <code>
            ILArray&lt;complex&gt; A = sqrtc(B); 
            // interfacing an external library as System.Numerics.Complex[]
            // We dont provide a System.Array as target for the conversion,
            // so it will be fetched from the ILNumerics memory management. 
            System.Numerics.Complex[] A_MSComplex = A.ToMSComplex(); 
            // .. do some work here with A_MSComplex
            // ...
            // The results get converted back to ILNumerics array 
            ILArray&lt;complex&gt; Result = A_MSComplex.ToILArray(A.S, true); 
            </code>
            <para>For the conversion of the System.Numerics.Complex[] array back to an ILNumerics array, we use the same size (<c>A.S</c>) as before. Here, any size 
            would work, as long as it fits into the number of elements of the source System.Array.</para>
            <para>Note that the calls to <c>A.ToMSComplex()</c> and <c>A_MSComplex.ToILArray(A.S, true)</c> will fetch and return all System.Arrays involved into/from the 
            ILINumerics memory pool. So if called frequently, no pressure on the GC is produced, what qualifies this scheme for high performance scenarios.</para> 
            </example>
            </remarks>
            <seealso cref="M:ILNumerics.ILExtensionMethods.ToILArray(System.Numerics.Complex[],ILNumerics.ILSize,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILExtensionMethods.ToMSComplex(ILNumerics.ILOutArray{ILNumerics.complex},System.Numerics.Complex[])">
            <summary>
            Convert this complex ILNumerics array to a system array of type System.Numerics.Complex[]
            </summary>
            <param name="A">this ILNumerics array</param>
            <param name="Storage">[option] if given, this system array will be used as storage for the conversion. Defaul: null (a new System.Array is returned)</param>
            <returns>System.Array with the elements of A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the storage given does not have sufficient length for all elements of the ILNumerics array</exception>
            <remarks><para>The elements of the ILNumerics array will be copied to the System.Array and converted to the System.Numerics.Complex type.</para>
            <para>The System.Array returned will contain all elements of the ILNumerics arrays after conversion - in column major order.</para>
            <example>
            This example demonstrates a common scenario for interchanging System.Numerics.Complex[] with ILNumerics complex arrays. It takes the converion between System.Numerics.Complex and ILNumerics.complex 
            into account, as well as the memory management of all storage involved. 
            <code>
            ILArray&lt;complex&gt; A = sqrtc(B); 
            // interfacing an external library as System.Numerics.Complex[]
            // We dont provide a System.Array as target for the conversion,
            // so it will be fetched from the ILNumerics memory management. 
            System.Numerics.Complex[] A_MSComplex = A.ToMSComplex(); 
            // .. do some work here with A_MSComplex
            // ...
            // The results get converted back to ILNumerics array 
            ILArray&lt;complex&gt; Result = A_MSComplex.ToILArray(A.S, true); 
            </code>
            <para>For the conversion of the System.Numerics.Complex[] array back to an ILNumerics array, we use the same size (<c>A.S</c>) as before. Here, any size 
            would work, as long as it fits into the number of elements of the source System.Array.</para>
            <para>Note that the calls to <c>A.ToMSComplex()</c> and <c>A_MSComplex.ToILArray(A.S, true)</c> will fetch and return all System.Arrays involved into/from the 
            ILINumerics memory pool. So if called frequently, no pressure on the GC is produced, what qualifies this scheme for high performance scenarios.</para> 
            </example>
            </remarks>
            <seealso cref="M:ILNumerics.ILExtensionMethods.ToILArray(System.Numerics.Complex[],ILNumerics.ILSize,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILExtensionMethods.ToMSComplex(ILNumerics.ILRetArray{ILNumerics.complex},System.Numerics.Complex[])">
            <summary>
            Convert this complex ILNumerics array to a system array of type System.Numerics.Complex[]
            </summary>
            <param name="A">this ILNumerics array</param>
            <param name="Storage">[option] if given, this system array will be used as storage for the conversion. Defaul: null (a new System.Array is returned)</param>
            <returns>System.Array with the elements of A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the storage given does not have sufficient length for all elements of the ILNumerics array</exception>
            <remarks><para>The elements of the ILNumerics array will be copied to the System.Array and converted to the System.Numerics.Complex type.</para>
            <para>The System.Array returned will contain all elements of the ILNumerics arrays after conversion - in column major order.</para>
            <example>
            This example demonstrates a common scenario for interchanging System.Numerics.Complex[] with ILNumerics complex arrays. It takes the converion between System.Numerics.Complex and ILNumerics.complex 
            into account, as well as the memory management of all storage involved. 
            <code>
            ILArray&lt;complex&gt; A = sqrtc(B); 
            // interfacing an external library as System.Numerics.Complex[]
            // We dont provide a System.Array as target for the conversion,
            // so it will be fetched from the ILNumerics memory management. 
            System.Numerics.Complex[] A_MSComplex = A.ToMSComplex(); 
            // .. do some work here with A_MSComplex
            // ...
            // The results get converted back to ILNumerics array 
            ILArray&lt;complex&gt; Result = A_MSComplex.ToILArray(A.S, true); 
            </code>
            <para>For the conversion of the System.Numerics.Complex[] array back to an ILNumerics array, we use the same size (<c>A.S</c>) as before. Here, any size 
            would work, as long as it fits into the number of elements of the source System.Array.</para>
            <para>Note that the calls to <c>A.ToMSComplex()</c> and <c>A_MSComplex.ToILArray(A.S, true)</c> will fetch and return all System.Arrays involved into/from the 
            ILINumerics memory pool. So if called frequently, no pressure on the GC is produced, what qualifies this scheme for high performance scenarios.</para> 
            </example>
            </remarks>
            <seealso cref="M:ILNumerics.ILExtensionMethods.ToILArray(System.Numerics.Complex[],ILNumerics.ILSize,System.Boolean)"/>
        </member>
        <!-- Ung端ltiger XML-Kommentar wurde f端r den Member "M:ILNumerics.ILExtensionMethods.ToILArray(System.Numerics.Complex[],ILNumerics.ILSize,System.Boolean)" ignoriert -->
        <member name="T:ILNumerics.fcomplex">
            <summary>
            Floating point complex value data type of float (single) precision
            </summary>
            <remarks>This class extends the system value types for real numbers to complex float 
            values. Besides the publicly available members 'real' and 'imag' it provides all the 
            basis functionality the floating point System.double brings (abs, log, sqrt, tan etc.) for 
            float precision complex,
            as well as it overrides the basic unary and binary operators for all common system value 
            types including rarely used types (e.g. UInt16). This includes the basic numerical operations 
            like '+','-','/','*' and the relational operators: '==','>','>=' etc. Also there are some 
            explicit and some implicit casting operators from / to fcomplex values into system 
            value types. </remarks>
        </member>
        <member name="F:ILNumerics.fcomplex.real">
            <summary>
            Real part of this complex number
            </summary>
        </member>
        <member name="F:ILNumerics.fcomplex.imag">
            <summary>
            Imaginary part of this complex number
            </summary>
        </member>
        <member name="F:ILNumerics.fcomplex.i">
            <summary>
            Imaginary unit 
            </summary>
        </member>
        <member name="M:ILNumerics.fcomplex.#ctor(System.Single,System.Single)">
            <summary>
            Construct new float complex number
            </summary>
            <param name="real">Real part</param>
            <param name="imag">Imaginary part</param>
        </member>
        <member name="M:ILNumerics.fcomplex.Equals(System.Object)">
            <summary>
            Are obj's real and imaginary part identical to the real and imaginary parts of this fcomplex
            </summary>
            <param name="obj">fcomplex object to determine the equality for</param>
            <returns>true if obj is of fcomplex type and its real and imag part has the same 
            values as the real and imaginary part of this array.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Equals(ILNumerics.fcomplex)">
            <summary>
            Check if a fcomplex number equals this fcomplex number
            </summary>
            <param name="other">other complex number</param>
            <returns>true if both, real and imaginary parts of both complex number are (binary) equal, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.GetHashCode">
            <summary>
            Give HashCode of this fcomplex number
            </summary>
            <returns>HashCode of this fcomplex number</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Subtract two complex values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Multiply two complex values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
            <remarks><para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
            <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true, if real and imaginary part are identical</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Subtract two complex values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Multiply two complex values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
            <remarks><para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
            <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true, if real and imaginary part are identical</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Single)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Single)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Single)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Single)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Single)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Single)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Single)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Single)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Single)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Single)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Double)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Double)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Double)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Double)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Double)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Double)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Double)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Double)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Double)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Double)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.Single,ILNumerics.fcomplex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Single,ILNumerics.fcomplex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.Single,ILNumerics.fcomplex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.Single,ILNumerics.fcomplex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.Single,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.Single,ILNumerics.fcomplex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Single,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.Single,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Single,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Single,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_UnaryNegation(ILNumerics.fcomplex)">
            <summary>
            Unary minus operator
            </summary>
            <param name="in1">fcomplex input</param>
            <returns>fcomplex number similar to in1, having real and imag part negated</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Abs(ILNumerics.fcomplex)">
            <summary>
            Magnitude value of float complex number
            </summary>
            <param name="input">fcomplex number</param>
            <returns>Magnitude of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Angle(ILNumerics.fcomplex)">
            <summary>
            Angle of complex number
            </summary>
            <param name="input">fcomplex number to compute angle of</param>
            <returns>Angle of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Acos(ILNumerics.fcomplex)">
            <summary>
            Arcus cosinus for float complex number
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Arcus cosinus of input</returns>
            <remarks>The arcus cosinus of a complex number is computed by
            <para>Log(Sqrt(input^2 - 1) + input) * i </para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Acos(System.Single)">
            <summary>
            Arcus cosinus of real number
            </summary>
            <param name="input">float input</param>
            <returns>Arcus cosinus of input</returns>
            <remarks>For input &gt; 1.0, <see cref="M:ILNumerics.fcomplex.Acos(ILNumerics.fcomplex)"/> will be used. </remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Asin(System.Single)">
            <summary>
            Arcus sinus of real number
            </summary>
            <param name="input">float input</param>
            <returns>Arcus sinus of input</returns>
            <remarks>For input &gt; 1.0, <see cref="M:ILNumerics.fcomplex.Asin(ILNumerics.fcomplex)"/> will be used. </remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Asin(ILNumerics.fcomplex)">
            <summary>
            Arcus sinus for complex number
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Arcus sinus of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Exp(ILNumerics.fcomplex)">
            <summary>
            Power of base e for float complex number
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Result of Exp(input)</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Pow(ILNumerics.fcomplex,System.Double)">
            <summary>
            fcomplex power real exponent
            </summary>
            <param name="input">Basis </param>
            <param name="exponent">Exponent</param>
            <returns>New fcomplex number with result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Pow(System.Double,System.Double)">
            <summary>
            Complex power - real basis, real exponent
            </summary>
            <param name="basis">Basis</param>
            <param name="exponent">Exponent</param>
            <returns>fcomplex number.</returns>
            <remarks>The result will be a fcomplex number. For negative basis 
            the basis will be converted to a fcomplex number and the power 
            will be computed in the fcomplex plane.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Pow(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Power: complex base, complex exponent
            </summary>
            <param name="basis">Basis</param>
            <param name="exponent">Exponent</param>
            <returns>result of basis^exponent</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Sqrt(System.Single)">
            <summary>
            Square root of real input
            </summary>
            <param name="input">float input</param>
            <returns>Square root of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Sqrt(ILNumerics.fcomplex)">
            <summary>
            Square root of complex number
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Square root of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Tan(ILNumerics.fcomplex)">
            <summary>
            Tangens of float complex number
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Tangens of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Tanh(ILNumerics.fcomplex)">
            <summary>
            Tangens hyperbolicus of float complex input
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Tangens hyperbolicus</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log(ILNumerics.fcomplex)">
            <summary>
            Logarithm of complex input
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Logarithm of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log10(ILNumerics.fcomplex)">
            <summary>
            Logarithm to base 10
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Logarithm of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log2(ILNumerics.fcomplex)">
            <summary>
            Logarithm of base 2
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Logarithm of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log(System.Single)">
            <summary>
            Logarithm of real input 
            </summary>
            <param name="input">float input - may be negative</param>
            <returns>Complex logarithm</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log10(System.Single)">
            <summary>
            Logarithm of base 10 of real input 
            </summary>
            <param name="input">float input - may be negative</param>
            <returns>Complex logarithm of base 10</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log2(System.Single)">
            <summary>
            Logarithm of base 2
            </summary>
            <param name="input">float input - may be negative</param>
            <returns>Complex logarithm of base 2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.FromPol(System.Single,System.Single)">
            <summary>
            Convert from polar to cartesian form
            </summary>
            <param name="magnitude">Magnitude</param>
            <param name="angle">Angle</param>
            <returns>fcomplex number with magnitude <c>magnitude</c> 
            and phase <c>angle</c></returns>
        </member>
        <member name="M:ILNumerics.fcomplex.ToString">
            <summary>
            Convert this float complex number to string 
            </summary>
            <returns>String representation of this float complex number</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.ToString(System.Int32)">
            <summary>
            Print formated output of this number, determine number of digits
            </summary>
            <param name="digits">Number of digits</param>
            <returns>Formatted output</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Abs">
            <summary>
            Magnitude of this float complex number
            </summary>
            <returns>Magnitude</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Angle">
            <summary>
            Phase angle of this float complex number
            </summary>
            <returns>Phase angle </returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Acos">
            <summary>
            Arcus cosinus of this float complex number
            </summary>
            <returns>Arcus cosinus</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Asin">
            <summary>
            Arcus sinus of this float complex number
            </summary>
            <returns>Arcus sinus</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Atan(ILNumerics.fcomplex)">
            <summary>
            Arcus tangens of float complex number
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Arcus tangens of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Ceiling(ILNumerics.fcomplex)">
            <summary>
            Round towards next greater integer
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Rounded float complex number</returns>
            <remarks>Real and imaginary parts are independently rounded 
            towards the next integer value towards positive infinity.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Floor(ILNumerics.fcomplex)">
            <summary>
            Round towards next lower integer
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Rounded float complex number</returns>
            <remarks>Real and imaginary parts are independently rounded 
            towards the next integer value towards negative infinity.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Round(ILNumerics.fcomplex)">
            <summary>
            Round mercantilistic
            </summary>
            <param name="input">fcomplex number</param>
            <returns>Rounded number</returns>
            <remarks>Real and imaginaty parts are rounded independently. </remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Sign(ILNumerics.fcomplex)">
            <summary>
            Signum function
            </summary>
            <param name="input">fcomplex input</param>
            <returns> Signum of input</returns>
            <remarks>
            For numbers a = 0.0 + 0.0i, sign(a)'s real and imag parts are 0.0. 
            For all other numbers sign(a) is the projection onto the unit circle.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Truncate(ILNumerics.fcomplex)">
            <summary>
            Truncate a floating point complex value
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Integer part of input</returns>
            <remarks>Operates on real and imaginary parts seperately.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Cos(ILNumerics.fcomplex)">
            <summary>
            Cosinus
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Cosinus of input</returns>
            <remarks><para>The cosinus is computed by the trigonometric euler equation: </para>
            <para>0.5 * [exp(i input) + exp(-i input)]</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Cosh(ILNumerics.fcomplex)">
            <summary>
            Cosinus hyperbolicus
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Cosinus hyperbolicus of input</returns>
            <remarks><para>The cosinus is computed by the trigonometric euler equation: </para>
            <para>(Exp(input) + Exp(-1.0 * input)) / 2.0</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Sin(ILNumerics.fcomplex)">
            <summary>
            Sinus
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Sinus of input</returns>
            <remarks><para>The sinus is computed by the trigonometric euler equation: </para>
            <para>(Exp(i * input) - Exp(-1.0 * i * input)) / (2.0 * i)</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Sinh(ILNumerics.fcomplex)">
            <summary>
            Sinus hyperbolicus
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Sinus hyperbolicus of input</returns>
            <remarks><para>The sinus hyperbolicus is computed by the trigonometric euler equation: </para>
            <para>(Exp(input) - Exp(-1.0 * input)) / 2.0</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Exp">
            <summary>
            Exponential / power of base e
            </summary>
            <returns>Power of base e</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Pow(System.Double)">
            <summary>
            Power of fcomplex number, real exponent
            </summary>
            <param name="exponent">Exponent</param>
            <returns>New fcomplex number with result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Pow(ILNumerics.fcomplex)">
            <summary>
            Power of fcomplex number, complex exponent
            </summary>
            <param name="exponent">Exponent</param>
            <returns>New fcomplex number with result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Sqrt">
            <summary>
            Square root of fcomplex number
            </summary>
            <returns>Square root</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log">
            <summary>
            Logarithm of fcomplex number
            </summary>
            <returns>Natural logarithm</returns>
            <remarks>The logarithm of a complex number A is defined as follows: <br />
            <list type="none"><item>real part: log(abs(A))</item>
            <item>imag part: Atan2(imag(A),real(A))</item></list>
            </remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.IsNaN(ILNumerics.fcomplex)">
            <summary>
            Test if any of real or imaginary parts are NAN's
            </summary>
            <param name="input">fcomplex input</param>
            <returns>true if any of real or imag part is not a number</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.IsInfinity(ILNumerics.fcomplex)">
            <summary>
            Test if any of real or imaginary parts are infinite
            </summary>
            <param name="input">fcomplex input</param>
            <returns>true if any of real or imag part is infinite</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.IsPositiveInfinity(ILNumerics.fcomplex)">
            <summary>
            Test if any of real or imaginary parts are pos. infinite
            </summary>
            <param name="input">fcomplex input</param>
            <returns>true if any of real or imag part is positive infinite</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.IsNegativeInfinity(ILNumerics.fcomplex)">
            <summary>
            Test if any of real or imaginary parts are neg. infinite
            </summary>
            <param name="input">fcomplex input</param>
            <returns>true if any of real or imag part is negative infinite</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.IsFinite(ILNumerics.fcomplex)">
            <summary>
            Test if any of real or imaginary parts are finite
            </summary>
            <param name="input">fcomplex input</param>
            <returns>true if any of real and imag part is finite</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Double)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">double</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Single)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">float</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Byte)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">byte</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Char)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">char</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Int16)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">Int16</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Int32)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">Int32</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Int64)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">Int64</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.UInt16)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">UInt16</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.UInt32)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">UInt32</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.UInt64)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">UInt64</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Double">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Single">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Byte">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Char">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Int16">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Int32">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">complex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Int64">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.UInt16">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.UInt32">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.UInt64">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.iszero">
            <summary>
            Test if real and imag part are zero
            </summary>
            <returns>true if real and imag parts are zero, false else</returns>
        </member>
        <member name="P:ILNumerics.fcomplex.conj">
            <summary>
            Complex conjugate 
            </summary>
        </member>
        <member name="P:ILNumerics.fcomplex.INF">
            <summary>
            Positive infinity for real and imag part of complex value
            </summary>
        </member>
        <member name="P:ILNumerics.fcomplex.Zero">
            <summary>
            New fcomplex, real and imaginary parts are zero
            </summary>
        </member>
        <member name="P:ILNumerics.fcomplex.NaN">
            <summary>
            fcomplex quantity, marked as being "not a number"
            </summary>
        </member>
        <member name="T:ILNumerics.Misc.ILArrayDebuggerProxy`1">
            <summary>
            This class is for internal use only. Do not instantiate from this class!
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ILNumerics.Exceptions.ILException">
            <summary>
            Generic exception, base class for all exceptions thrown by ILNumerics
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILMathException">
            <summary>
            Base class for mathematical exceptions. Needed e.g. in interpreter for proper error
            messages
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILMathException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILMathException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILDimensionMismatchException">
            <summary>
            One of the most common exceptions: The matrix sizes do not match
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILDimensionMismatchException.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILDimensionMismatchException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILDimensionMismatchException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILArgumentException">
            <summary>
            Something was wrong with the arguments supplied
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILArgumentNumberException">
            <summary>
            A function was called with the wrong number of arguments
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentNumberException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentNumberException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILArgumentSizeException">
            <summary>
            A function argument has the wrong size
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentSizeException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentSizeException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILArgumentTypeException">
            <summary>
            A function was called with a wrong argument type
            </summary>
            <remarks>This exception might be thrown if the size or inner 
            type of a argument is invalid. (e.g. matrix expected, but 3D array found)
            </remarks>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentTypeException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentTypeException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILMemoryException">
            <summary>
            A request could not be completed due to not enough memory available
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILMemoryException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILMemoryException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILCastException">
            <summary>
            Thrown on illegal casting attempts
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILCastException.#ctor(System.String)">
            <summary>
            Costructor
            </summary>
            <param name="message">Addditional message to be included into the exception</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILCastException.#ctor(System.String,System.Exception)">
            <summary>
            Costructor
            </summary>
            <param name="message">Additional message to be included into the exception</param>
            <param name="innerException">On cascaded exception handling, the exception catched before</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILOutputException">
            <summary>
            ILOutputException, thrown if an I/O attempt fails
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILOutputException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILOutputException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILInvalidOperationException">
            <summary>
            Exception thrown if an operation could not completed
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILInvalidOperationException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILInvalidOperationException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILInvalidLicenseException">
            <summary>
            No valid license could be found
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILInvalidLicenseException.#ctor(System.String,System.Exception)">
            <summary>
            Create a new ILInvalidLicenseException 
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="T:ILNumerics.ILMatFile">
            <summary>
            Matlab .mat file wrapper class
            </summary>
            <remarks>This class reads and writes Matlab .mat files version 6! ! 
            All numeric array types are supported. The reading and writing of 
            Matlab cell arrays is not supported yet.</remarks>
        </member>
        <member name="F:ILNumerics.ILMatFile.ReservedKeywords">
            <summary>
            List of keywords which Matlab disallows for variable names
            </summary>
        </member>
        <member name="M:ILNumerics.ILMatFile.sizeOf(ILNumerics.ILMatFile.MatFileType)">
            <summary>
            size of single elements stored in Matlab's *.mat files
            </summary>
            <param name="type">one of Matlab's inner element types</param>
            <returns>size in bytes </returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.read_miMATRIX(System.IO.BinaryReader)">
            <summary>
            read ONE array (arbitrary dimensions/type) from MAT file 
            </summary>
            <param name="br">binary reader initialized and pointing to the beginning of the subarray element.</param>
            <returns>ILBaseArray of size and type originally stored into the mat file.</returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.readElementGeneric(System.IO.BinaryReader,ILNumerics.ILMatFile.MatFileType,System.Array@,System.Int32@,System.Int32)">
            <summary>
            read array of supported matlab data types 
            </summary>
            <param name="br">binary reader, opened and correctly positioned</param>
            <param name="storageType">actual storage type</param>
            <param name="realData">output: on return, the array read</param>
            <param name="len">input: number of bytes to read, on return: number of elements in array</param>
            <param name="paddBytes">padding border, the stream will be read to the next border of length 'paddBytes'.</param>
        </member>
        <member name="M:ILNumerics.ILMatFile.createNameSubelement(System.String,System.Int32@,System.Byte[]@)">
            <summary>
            create name subelement for Matfile storage - padded to 8 byte border
            </summary>
            <param name="arrName">name property</param>
            <param name="type">will be 'miINT8' on return</param>
            <param name="data">return data array </param>
        </member>
        <member name="M:ILNumerics.ILMatFile.getElementClass(ILNumerics.ILBaseArray)">
            <summary>
            get mat file array class type corresponding to this arra element type
            </summary>
            <param name="arr">arra with generic system type or complex/fcomplex</param>
            <returns>mat file array class type code (int value)</returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.getElementLength(ILNumerics.ILBaseArray)">
            <summary>
            get storage length of inner array elements 
            </summary>
            <param name="arr">base array in question</param>
            <returns>storage length in bytes</returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.typeToString(ILNumerics.ILMatFile.MatFileType)">
            <summary>
            Convert MatFileType enumeration member to string representation
            </summary>
            <param name="type">MatFileType enumeration member</param>
            <returns>String representing the Matlab's inner element type</returns>
            <remarks>This function is obsolete. You may directly use the enumeration's functionality instead.</remarks>
        </member>
        <member name="M:ILNumerics.ILMatFile.AddArray(ILNumerics.ILBaseArray,System.String)">
            <summary>
            Add array to collection of arrays in this ILMatFile container
            </summary>
            <param name="A">Array to be added to ILMatFile</param>
            <returns>String used to identify the array in the collection of arrays</returns>
            <remarks><para>The internal <c>Name</c> property of array given will be used as identification key.</para>
            <para>Note, the test if elements of A are supported by MatFile specification is done if the MatFile is to be written to stream ('write').</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILInvalidOperationException">If the internal name of A does not fullfill the restrictions given by Matlab.</exception>
        </member>
        <member name="M:ILNumerics.ILMatFile.GetArray``1(System.String)">
            <summary>
            Retrieve array by name
            </summary>
            <typeparam name="T">Expected type of the array</typeparam>
            <param name="name">Name of the array to retrieve</param>
            <returns>A clone of the array found or null, if no array with the given name exists</returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.GetArray``1(ILNumerics.ILBaseArray)">
            <summary>
            Retrieve array by index
            </summary>
            <typeparam name="T">Expected type of the array</typeparam>
            <param name="index">Index of the array</param>
            <returns>A clone of the array found or null, if no array at the given index exists</returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.Write(System.IO.Stream)">
            <summary>
            Write this mat file into a binary stream
            </summary>
            <param name="stream">Stream to receive data. This will commonly be a FileStream object.</param>
            <remarks>
            <para>This method writes the full content of the current mat file into a binary stream. The file 
            afterwards is suitable to be read again by ILNumerics.MatFile classes or by compatible *.mat file 
            readers - including Matlab, e.g.</para>
            <example><code>
            MatFile m = new MatFile(myarrays); 
            using (Stream s = new FileStream("test.mat",FileMode.Create)) {
                m.Write(s);
            }
            </code></example></remarks>
        </member>
        <member name="M:ILNumerics.ILMatFile.Write(System.String)">
            <summary>
            Write all arrays to *.mat file
            </summary>
            <param name="filename">Filename of the file to write the mat file to</param>
            <remarks>
            <para>The method writes the full content of the matfile to the file specified. If the filename 
            points to a file which already exists, that file will be overwritten. Otherwise a new file will
            be created. </para>
            <para>The file will be suitable for reading by ILNumerics.MatFile classes or by compatible *.mat file 
            readers - including e.g. matlab</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMatFile.#ctor(System.String)">
            <summary>
            Create MatFile object from existing mat file 
            </summary>
            <param name="file2open">Path to Matlab mat file to open</param>
            <remarks>Curently mat files up to Matlab version 6.5 are supported. Compressed mat file content is not supported yet.</remarks>
        </member>
        <member name="M:ILNumerics.ILMatFile.#ctor(ILNumerics.ILBaseArray[])">
            <summary>
            Create MatFile object from ILBaseArray
            </summary>
            <param name="input">ILBaseArray of arbitrary size/type</param>
            <exception cref="T:System.ArgumentNullException">If input array was null or one of the names in the input arrays does not fullfill the restrictions made from Matlab</exception>
        </member>
        <member name="M:ILNumerics.ILMatFile.#ctor">
            <summary>
            Create an empty MatFile object
            </summary>
        </member>
        <member name="M:ILNumerics.ILMatFile.Dispose">
            <summary>
            Dispose all arrays of the matfile object
            </summary>
            <remarks>Calling dispose should be the last action for a matfile object. It is recommended to 
            utilize the matfile class in using blocks (C#) only.</remarks>
        </member>
        <member name="P:ILNumerics.ILMatFile.Filelocation">
            <summary>
            Path to mat file, if this object was created from an existing mat file.
            </summary>
        </member>
        <member name="P:ILNumerics.ILMatFile.Keys">
            <summary>
            List all key names currently stored with arrays 
            </summary>
        </member>
        <member name="P:ILNumerics.ILMatFile.Arrays">
            <summary>
            Retrieve a cell with all arrays stored in the mat file
            </summary>
            <remarks>The cell returned will be clone of the arrays stored in the mat file. Altering any cell 
            elements will leave the arrays in the matfile (class/memory object) untouched.
            <para>The cell returned will be of size [n,2], where n is the number of arrays contained. The 
            first row saved the arrays, the second row containes scalar string arrays with the name of 
            the array in the corresponding row.</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILMatFile.Item(System.String)">
            <summary>
            Add or replace named array to this MatFile
            </summary>
            <param name="name">The assigned name of the array</param>
            <remarks><para>The get acces is provided for compatibility reasons only. It may be removed in a future version! Use one of the typed retrieval functions <see cref="M:ILNumerics.ILMatFile.GetArray``1(System.String)"/> or <see cref="M:ILNumerics.ILMatFile.GetArray``1(ILNumerics.ILBaseArray)"/> instead.</para>
            <para>For get access the name must exist as key in the container. Use the MatFile.Keys property to get a list of all names if needed</para>
            <para>For set access, the name given must not be null or empty. It cannot be one of the <see cref="F:ILNumerics.ILMatFile.ReservedKeywords">ReservedKeywords</see>.
            If the name allready exist in the collection as name, the array currently assigned to it will be replaced. If the value is null, the current array will be removed from the list. If the name does 
            not already exist, the new array will be added and assigned to this name.</para>
            <para>Restrictions on array names: Matlab allowes variables to have names of maximum length 63. Therefore, if the 
            name given was larger than 63, it will be abbreviated. Names must start with a letter and contain only digits, (ASCII) letters or underscores '_'.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the name does not fullfill the restrictions given from Matlab</exception>
        </member>
        <member name="P:ILNumerics.ILMatFile.Count">
            <summary>
            Number of arrays in the mat file container
            </summary>
        </member>
        <member name="T:ILNumerics.ILMatFile.MatFileType">
            <summary>
            Inner types for MATLAB data elements
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miUNKNOWN">
            <summary>
            unknown 
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miINT8">
            <summary>
            Int8
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miUINT8">
            <summary>
            UInt8
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miINT16">
            <summary>
            Int16
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miUINT16">
            <summary>
            UInt16
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miINT32">
            <summary>
            int32
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miUINT32">
            <summary>
            UInt32
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miSINGLE">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miDOUBLE">
            <summary>
            double
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miINT64">
            <summary>
            Int64
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miUINT64">
            <summary>
            UInt64
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miMATRIX">
            <summary>
            matrix type (general)
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miCOMPRESSED">
            <summary>
            compressed
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miUTF8">
            <summary>
            utf8 encoded
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miUTF16">
            <summary>
            utf16 encoded
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miUTF32">
            <summary>
            utf32 encoded
            </summary>
        </member>
        <member name="T:ILNumerics.ILMatFile.MatFileArrayClass">
            <summary>
            Types for matrix chunks
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxCELL_CLASS">
            <summary>
            cell
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxSTRUCT_CLASS">
            <summary>
            struct
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxOBJECT_CLASS">
            <summary>
            object
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxCHAR_CLASS">
            <summary>
            char
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxSPARSE_CLASS">
            <summary>
            sparse
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxDOUBLE_CLASS">
            <summary>
            double
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxSINGLE_CLASS">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxINT8_CLASS">
            <summary>
            Int8
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxUINT8_CLASS">
            <summary>
            UInt8
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxINT16_CLASS">
            <summary>
            Int16
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxUINT16_CLASS">
            <summary>
            UInt16
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxINT32_CLASS">
            <summary>
            Int32
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxUINT32_CLASS">
            <summary>
            UInt32
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxINT64_CLASS">
            <summary>
            Int32
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxUINT64_CLASS">
            <summary>
            UInt32
            </summary>
        </member>
        <member name="T:ILNumerics.ILMemoryPool">
            <summary>
            The ILNumerics Memory Pool is the heart of the ILNumerics memory management.
            </summary>
            <remarks>The pool reduces the pressure on the systems memory caused by larger objects.
            <para>Arrays created in ILNumerics will try to allocate their memory from the pool. If the attempt fails, the memory is gathered from the regular managed heap instead.</para>
            <para>Disposed array objects deterministically register their underlying storage in the pool for later reusing. The process is triggered by a deterministic disposal 
            pattern in conjunction with <a href="http://ilnumerics.net/$Arrays.html">ILNumerics array types</a> and <a href="http://ilnumerics.net/$FunctionRules.html">ILNumerics Function Rules</a>.</para></remarks>
        </member>
        <member name="F:ILNumerics.ILMemoryPool.Pool">
            <summary>
            The only global ILMemoryPool instance 
            </summary>
        </member>
        <member name="M:ILNumerics.ILMemoryPool.MinArrayLength``1">
            <summary>
            Gets the minimum length required for arrays of a certain element type to be stored in the pool
            </summary>
            <typeparam name="T">Element type of the pool</typeparam>
            <returns>minumun element length</returns>
        </member>
        <member name="M:ILNumerics.ILMemoryPool.New``1(System.Int64,System.Boolean,System.Boolean@)">
            <summary>
            Get new array of type T from memory pool.
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="length">Size of T[]</param>
            <param name="clear">If true, set the elements in T[] to default(T)</param>
            <param name="cleared">Always true if <paramref name="clear"/> was set. Otherwise this will be true if the array was newly created instead of being recycled from the pool. False otherwise.</param>
            <remarks><para>If the pool contains an unused matching element of sufficient size this element will be returned. If <paramref name="clear"/> was false,
            the result might still contain the old data.</para>
            <para>If the pool does not contain a matching element a new one is created.</para>
            <para><b>Note:</b> The returned array may be larger than requested if it was recycled from the pool.</para></remarks>
            <returns>An array of type T of at least length <paramref name="length"/></returns>
        </member>
        <member name="M:ILNumerics.ILMemoryPool.New``1(System.Int64)">
            <summary>
            Get an array from the memory pool without clearing the elements
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="length">Required minimum length</param>
            <remarks>The returned array is only guaranteed to have at least length <paramref name="length"/>. Its length may exceed <paramref name="length"/>.
            There is no guarantee on the values contained in the returned array! To force all elements to their default value 
            use <see cref="!:ILNumerics.ILMemoryPool.New&lt;T&gt;(long length, bool clear, out bool cleared)"/></remarks>
            <returns>An array of type T of at least length <paramref name="length"/>.</returns>
        </member>
        <member name="M:ILNumerics.ILMemoryPool.Free``1(``0[])">
            <summary>
            Return a array of type T that is not needed anymore to the pool.
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="array">The array to add to the pool</param>
            <remarks>You may also "free" objects not retrieved from the pool, in which case they are registered in the pool.</remarks>
        </member>
        <member name="M:ILNumerics.ILMemoryPool.MaxBytes``1">
            <summary>
            Get maximal potential size of the memory pool for objects of type T
            </summary>
            <typeparam name="T">Element type</typeparam>
            <returns>Maximal number of bytes in pool</returns>
        </member>
        <member name="M:ILNumerics.ILMemoryPool.Reset``1(System.Int64,System.Int32)">
            <summary>
            Reset &amp; reconfigure the pool 
            </summary>
            <param name="MinPoolArrayLen">Minimum length for array object to be stored inside the pool</param>
            <param name="maxSizeMB">Overall size the memory pool consumes at most</param>
            <remarks>Reset will dispose all objects currently hold in the pool!</remarks>
        </member>
        <member name="M:ILNumerics.ILMemoryPool.Info(System.Boolean)">
            <summary>
            Give information about pool state
            </summary>
            <param name="shortVersion">true (default): abbreviate infos to: current MB in Pool, reclaimed MB for livetime, reclaimed objects for livetime. False: give full info</param>
            <returns>Infos about current pool state</returns>
        </member>
        <member name="T:ILNumerics.Misc.ILMemoryPoolInternal`1">
            <summary>
            Memory pool serving as temporary storage for System.Array objects
            </summary>
            <remarks>The pool reduces the pressure on the systems memory caused by larger objects.
            <para>Arrays created in ILNumerics will first try to reclaim their memory from this pool. If that 
            fails, the memory is allocated from the managed heap only.</para>
            <para>Disposed array objects register their underlying System.Array in the pool for 
            later reusing. The process is triggered by the ILNumerics memory management automatically.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Reset(System.Int64,System.Int32)">
            <summary>
            Reset &amp; reconfigure the pool 
            </summary>
            <param name="MinArrayLength">Minimum length for array object to be stored inside the pool</param>
            <param name="PoolSizeMB">Overall size the memory pool consumes at most</param>
            <remarks>Reset will dispose all objects currently hold in the pool!</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.DisposeContent">
            <summary>
            Dispose all objects currently hold in the pool 
            </summary>
            <remarks>The pool get cleared and continues working with the same parameters after the call has finished. </remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Free(`0[])">
            <summary>
            Return or register an array object of value type in the pool that is not used anymore, i.e. free it
            </summary>
            <typeparam name="T">arbitrary element type</typeparam>
            <param name="arr">array</param>
            <remarks><para>In order to be stored in the pool, the array must meet the minimum array length and must fit into the global pool size.
            Null objects or empty arrays or array not suitable for the pool will be silently ignored.</para>
            <para>If the new array is too large to fit into the remaining pool space, the oldest objects in the pool will be released until the object can get registered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.New(System.Int64)">
            <summary>
            Request a System.Array instance (may not be cleared!)
            </summary>
            <typeparam name="T">value type</typeparam>
            <param name="length"><b>minimum</b> length of array</param>
            <returns>System.Array - either from the pool or a newly created array</returns>
            <remarks><para>If a suitable System.Array was found in the pool, this object is returned. 
            Otherwise a new array is created.</para>
            <para>There is no way of determining, if the array was reclaimed from pool or newly created! 
            If you must be sure, the element values are set to default(T), call the overloaded version 
            <see cref="!:ILNumerics.Misc.ILMemoryPool.New&lt;T&gt;(long, bool, out bool)"/> instead!</para>
            <para>If a new array could not get created due to an OutOfMemoryException, a garbage collection
            is triggered and the array is again requested from the pool. If this again fails, another attempt 
            to create the array is done. Exceptions may thrown from this last attempt are not catched and 
            therefore must be handled by the calling function.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.New(System.Int64,System.Boolean,System.Boolean@)">
            <summary>
            Request a System.Array instance and optionally clear the array
            </summary>
            <typeparam name="T">value type</typeparam>
            <param name="length">length of array</param>
            <param name="clear">if true, the elements of the array returned are set to default(T).</param>
            <param name="iscleared">out paramater determining if the array returned has been cleared</param>
            <returns>System.Array - either from the pool or a newly created array</returns>
            <remarks><para>If a suitable System.Array was found in the pool, this object is returned. Otherwise a new array is created.</para>
            <para>If the <paramref name="clear">clear </paramref> parameter was set to false, the
            <paramref name="iscleared">iscleared</paramref> parameter can be used to determine, if the object
            was returnd from the pool and may need extra clearing.</para>
            <para>If a new array could not get created due to an OutOfMemoryException, a garbage 
            collection is triggered and the array is again requested from the pool. If this again failes, 
            another attempt to create the array is done. Exceptions eventually thrown from this last 
            attempt are not catched and given back to the callee.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Info(System.Boolean,System.Boolean)">
            <summary>
            Give infos about pool state, optionally reset counters
            </summary>
            <param name="shortVersion">true: abbreviate infos to: current MB in Pool, reclaimed MB for livetime, reclaimed objects for livetime. False: give full info (see below)</param>
            <param name="reset">true: reset internal counter for reclaimed objects/ - bytes</param>
            <returns>infos about current pool state</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Info">
            <summary>
            Give extended infos about pool state
            </summary>
            <returns>Full info about current and reclaimed pool objects</returns>
            <remarks>For short version infos use the overloaded version <see cref="!:ILNumerics.Misc.ILMemoryPool.Info(bool)"/></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Info(System.Boolean)">
            <summary>
            Give infos about pool state, optionally reset counters
            </summary>
            <param name="shortVersion">true: abbreviate infos to: current MB in Pool, reclaimed MB for livetime, reclaimed objects for livetime. False: give full info (see below)</param>
            <returns>infos about current pool state</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Shrink(System.Int64)">
            <summary>
            shrink the pool's content to SHRINK_PERCENT of the maximum pool size or at the size, suitable to store requestLen
            </summary>
            <param name="requestLen">minimum length to make available (bytes)</param>
        </member>
        <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.MaxRequestedLengthIncrease">
            <summary>
            factor used, to allow returned arrays to exceed the requested array length
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.MinArrayLength">
            <summary>
            minimum length of array objects for recognition in the pool (default: 80k)
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.MaxBytes">
            <summary>
            maximum size of the pool configured in bytes
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.SuccessRate">
            <summary>
            percentage of allocation requests which could be successfully be completed
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.ReclaimedBytesCount">
            <summary>
            Number of reclaimed bytes since the pool exists
            </summary>
            <remarks>The counter will be reset by calls to <see cref="!:ILNumerics.Misc.ILMemoryPool.Reset(int, int)"/></remarks>
        </member>
        <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.ReclaimedObjectsCount">
            <summary>
            Number of reclaimed objects since the pool exists
            </summary>
            <remarks>The counter will be reset by calls to <see cref="!:ILNumerics.Misc.ILMemoryPool.Reset(int, int)"/></remarks>
        </member>
        <member name="T:ILNumerics.Misc.ILThreadPool">
            <summary>
            simple thread pool implementation - NOT THREAD SAFE !! 
            </summary>
        </member>
        <member name="T:ILNumerics.ILScope">
            <summary>
            An artificial scope class, used by the ILNumerics memory management
            </summary>
        </member>
        <member name="M:ILNumerics.ILScope.Enter(ILNumerics.ILBaseArray[])">
             <summary>
             Begins an artificial scope block within a local function block
             </summary>
             <param name="inputArrays">Any <b>input</b> arry, given as parameter for the current function</param>
             <returns>A new scope</returns>
             <remarks><para>The <c>ILScope</c> class plays an important role for the ILNumerics memory management. When writing functions in ILNumerics, 
             <c>ILScope</c> is used, to define blocks of artificial scopes for local function blocks. ILNumerics ensures, no memory is left as garbage, once 
             such a scope block was left. Furthermore, it garantees, input arrays are kept alive during the execution of the block. By following these 
             <a href="http://ilnumerics.net/$GeneralRules.html" target="ILMain">simple rules</a>, ILNumerics is able to optimize the execution of the algorithm regarding 
             execution speed and memory footprint.</para></remarks>
             <example><para>The examples demonstrates a custom function in ILNumerics. It demonstrates the use of distinct array types in the function declaration and the use of 
             artificial scopes.</para>
             <code><![CDATA[ILRetArray<double> FreqPeaks(ILInArray<double> inData, ILOutArray<double> freq = null, double sampFreq = 44.1) { 
            
                using (ILScope.Enter(inData)) {    
                         
                    ILArray<double> Data = check(inData); 
                    ILArray<double> retLength = min(ceil(Data.Length / 2.0 + 1), 5.0);   
                    ILArray<double> Window = stdWindowFunc(Data.Length);  
                    ILArray<double> magnitudes = abs(fft(Data * Window));  
                    magnitudes = magnitudes[r(0,end / 2 + 1)];  
             
                    ILArray<double> indices = empty();  
                    ILArray<double> sorted = sort(magnitudes, indices, descending:true);  
                    if (!isnull(freq)) 
                        freq.a = (sampFreq / 2.0 / magnitudes.Length * indices)[r(0,retLength-1)];  
                    return magnitudes[r(0,retLength-1)];  
                } 
            }]]></code>
             </example>
        </member>
        <member name="M:ILNumerics.ILScope.Enter(ILNumerics.ILBaseArray)">
             <summary>
             Begins an artificial scope block within a local function block
             </summary>
             <param name="inputArrays">Any <b>input</b> arry, given as parameter for the current function</param>
             <returns>A new scope</returns>
             <remarks><para>The <c>ILScope</c> class plays an important role for the ILNumerics memory management. When writing functions in ILNumerics, 
             <c>ILScope</c> is used, to define blocks of artificial scopes for local function blocks. ILNumerics ensures, no memory is left as garbage, once 
             such a scope block was left. Furthermore, it garantees, input arrays are kept alive during the execution of the block. By following these 
             <a href="http://ilnumerics.net/$GeneralRules.html" target="ILMain">simple rules</a>, ILNumerics is able to optimize the execution of the algorithm regarding 
             execution speed and memory footprint.</para></remarks>
             <example><para>The examples demonstrates a custom function in ILNumerics. It demonstrates the use of distinct array types in the function declaration and the use of 
             artificial scopes.</para>
             <code><![CDATA[ILRetArray<double> FreqPeaks(ILInArray<double> inData, ILOutArray<double> freq = null, double sampFreq = 44.1) { 
            
                using (ILScope.Enter(inData)) {    
                         
                    ILArray<double> Data = check(inData); 
                    ILArray<double> retLength = min(ceil(Data.Length / 2.0 + 1), 5.0);   
                    ILArray<double> Window = stdWindowFunc(Data.Length);  
                    ILArray<double> magnitudes = abs(fft(Data * Window));  
                    magnitudes = magnitudes[r(0,end / 2 + 1)];  
             
                    ILArray<double> indices = empty();  
                    ILArray<double> sorted = sort(magnitudes, indices, descending:true);  
                    if (!isnull(freq)) 
                        freq.a = (sampFreq / 2.0 / magnitudes.Length * indices)[r(0,retLength-1)];  
                    return magnitudes[r(0,retLength-1)];  
                } 
            }]]></code>
             </example>
        </member>
        <member name="M:ILNumerics.ILScope.Dispose">
            <summary>
            Dispose all arrays in this scope
            </summary>
        </member>
        <member name="P:ILNumerics.ILScope.Context">
            <summary>
            The threading context - individual for each thread
            </summary>
        </member>
        <member name="M:ILNumerics.ILScope.ILThreadingContext.RegisterArray(ILNumerics.ILBaseArray)">
            <summary>
            Registers an ILNumerics array for disposal after the current scope was left
            </summary>
            <param name="A">arbitrary ILNumerics array</param>
            <remarks><para>This method is part of the memory managent of ILNumerics. You should not 
            call this method explicitely!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILScopeList`1.Peek(System.Int32)">
            <summary>
            peek element at distance 'index' from END!!
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:ILNumerics.Settings">
            <summary>
            The class provides static setting properties to control the behaviour of ILNumerics, see <a href="http://ilnumerics.net/$Configuration.html">Configuration</a> in the online documentation
            </summary>
        </member>
        <member name="F:ILNumerics.Settings.KnownIDENames">
            <summary>
            List of known IDE executable names used for detecting design mode and disabling OpenGL renderers for unsupported IDE.
            </summary>
            <remarks><para>Currently the known IDEs span the following exe names: "devenv", "vbexpress", "vcsexpress", "vwdexpress", and "monodevelop".</para></remarks>
        </member>
        <member name="M:ILNumerics.Settings.LoadDefaults">
            <summary>
            (Re)load settings from the application configuration file
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.DefaultRenderer">
            <summary>
            Configures or defines the default renderer used for interactive drawing controls like ILPanel, default: null (auto) 
            </summary>
            <remarks><para>By default, ILNumerics selects the optimal renderer for interactive panels (<see cref="T:ILNumerics.Drawing.ILPanel"></see>) automatically. For situations where 
            this does not work efficiently, the user is able to define the default renderer manually by setting this flag, either via app.config or programmatically.</para>
            <para>The setting will be considered for all panels created with ILNumerics at a later point.</para>
            <para>When setting this property via app.config, use the key 'ILNDefaultRenderer' and provide it one of the values of the RendererTypes enum. Valid values are any available interactive renderer: 
            <list type="bullet">
            <item>GDI</item>
            <item>OpenGL</item>
            <item>DirectX</item>
            </list></para>
            <para>Using no setting signals ILNumerics to determine the optimal renderer automatically. This will cause OpenGL to be used. In a later version, on Windows it will default to DirectX.</para>
            <para>Keep in mind, the actual type of the renderer used at runtime may differs from that setting, since ILNumerics prevents from known situations where certain renderers are not working properly.</para>
            <para>ILNuerics provides the following options to determine the actual renderer used for ILPanel. Settings are applied in the following order. Subsequent settings may override values which were set earlier.</para>
            <list type="bullet">
            <item>ILNumerics.Settings, applied via app.config value 'ILNDefaultRenderer'</item>
            <item>ILNumerics.Settings, applied programmatically: <code>Settings.DefaultRenderer = ... </code></item>
            <item>Individual driver configuration for each <code>ILPanel</code>: <code>ILPanel.Driver = ... RendererTypes.OpenGL /  ...</code></item>
            </list></remarks>
        </member>
        <member name="P:ILNumerics.Settings.ShowMessageBoxOnGDIFallback">
            <summary>
            Gets or sets a flag indicating if a message box is shown to the user, once the rendering driver falls back to GDI; default: true
            </summary>
            <remarks><para>If at runtime unrecoverable errors prevent the driver from rendering successfully, a message box will inform the user 
            about the issue before the driver falls backt to GDI rendering. Setting this flag to false prevents the message box from showing.</para>
            <para>Potential problems with accelerated drivers commonly include: 
            <list type="bullet">
            <item>Outdated drivers: for OpenGL GPU rendering, currently OpenGL version 3.1 or higher is required.</item>
            <item>Buggy drivers: especially 'first day support' drivers often show bugs with newer OpenGL functionality</item>
            <item>Deactivated drivers: mobile devices sometimes deactivate GPU rendering for energy savings</item>
            <item>Virtual machines and remote desktop connections do often provide limited access to graphics hardware only. This may leads to OpenGL contexts of 
            lower versions than neccessary and/or to the use of software implementations for OpenGL which may cause common problems with ILNumerics drawing controls. </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:ILNumerics.Settings.IsHosted">
            <summary>
            Disable automatic DesignMode determination (true). By default (false), ILNumerics determines DesignMode automatically.  
            </summary>
            <remarks>
            <para>By default IsHosted is false. This makes ILNumerics assume, that the library runs in the context of a regular application. At design time, 
            limited functionality is provided by the drawing controls only. OpenGL contexts are not created and replaced by GDI controls. At design 
            time, no scene is displayed. At runtime, the drawing controls are functioning in the regular way.</para>
            <para>The determination of design mode is done by taking all references of the entry assembly into account. If the entry assembly references the ILNumerics dll, 
            no design mode is assumed. If ILNumerics is not among the referenced libraries of the entry assembly, ILNumerics is expected to be executed in the context of a desinger.</para>
            <para>For situations, where ILNumerics is intended to be loaded dynamically at runtime - without any reference to it existing in the entry assembly - this switch can be set to true. 
            This will cause ILNumerics to use another method to determine if it was loaded in a designer context.</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.Settings.AllowInArrayAssignments">
            <summary>
            Performance switch, dis-/allow direct assignments to input parameters - brings more efficient 
            memory management, default: true (safer, less efficient)
            </summary>
            <remarks>
            <para>If this switch is set to 'false', you promise not to assign any values to input parameters 
            of type <c>ILInArray</c>, <c>ILInCell</c> or <c>ILInLogical</c>. This allows ILNumerics for more efficent 
            memory management, decreases the overall memory footprint of the application and enables certain 
            array operations to be automatically computed in-place. Depending on the specific algorithm
            the performance profit may range from 1% up to even about 30%.</para>
            This switch should be set for the whole application globally. It is not recommended to change the state of 
            this switch once the application runs.
            <para>Since this switch targets the full application, all functions and modules involved must also follow 
            that contract! For all builtin functions of ILNumerics, compliance with this rule is garanteed. This means, if you are 
            not using any 3rd party algorithms and are able to make sure your own functions follow that scheme as well, it is safe 
            to set this switch to <c>false</c> and profit from faster execution times.</para>
            <para>See the <a href="http://ilnumerics.net/$PerfMemoryOpt.html">Optimizing Performance</a> article in the online documentation.</para></remarks>
        </member>
        <member name="P:ILNumerics.Settings.OpenGL31_FIX_GL_CLIPVERTEX">
            <summary>
            Work around OpenGL driver issues regarding GL_ClipDistance; set to true on problems on older GL 3.1 hardware (like GT 3XXM series); default: auto
            </summary>
            <remarks>On GL version 3.1 contexts, if the linking of affected shaders fails, the switch is automatically set to true.</remarks>
        </member>
        <member name="P:ILNumerics.Settings.CreateRowVectorsByDefault">
            <summary>
            Control layout of vectors when not specified explicitly.
            <list type="bullet">
            <item>
            <term>true</term>
            <description>When a vector is created without exlicitely specifying its shape, create a row vector</description>
            </item>
            <item>
            <term>false (default)</term>
            <description>When a vector is created without exlicitely specifying its shape, create a column vector</description>
            </item></list>
            </summary>
            <remarks>This setting affects the way ILNumerics handles the default shape for vectors created. One example is <see cref="M:ILNumerics.ILMath.array``1(``0[])"/>, 
            where only the number of elements is given - but no size is specified. By default, ILNumerics will interpret the elements as targeting the <b>first</b> 
            dimension, ie. dimension #0. This will create a column vector. Setting this switch to 'true' will make ILNumerics to create a row vector in 
            such situations instead.</remarks>
        </member>
        <member name="P:ILNumerics.Settings.MemoryPoolProfileMaxLength">
            <summary>
            Upper limit of the range of array length to gather profiler information for
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MemoryPoolProfileMinLength">
            <summary>
            Lower limit of the range of array length to gather profiler information for
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MemoryPoolProfileFileName">
            <summary>
            If set to any non empty value, this setting triggers the memory pool profiler
            </summary>
            <remarks>Profiling the memory pool gives insights into those functions, which potentially 
            cause memory leaks in your application. It writes extensive stack trace information into the 
            logfile determined by this setting. It will contain the stack trace of any function, requesting 
            memory from the pool, which is never given back to the pool. Use this information in order to find and 
            correct those places - and increase stability and performance of your application. However, 
            make sure, this switch is cleared (or renamed) for production systems, since running the profiler 
            will diminish performance significantly.</remarks>
        </member>
        <member name="P:ILNumerics.Settings.NativeDependenciesAbsolutePath">
            <summary>
            The absolute directory where ILNumerics should look for native dependencies (LAPACK, HDF5 etc.); default: empty string 
            </summary>
            <remarks><para>By default (i.e.: empty string) ILNumerics will automatically determine the include path for native dependencies on startup. 
            In order to do so, the bitrate (Environment.Is64BitProcess) is examined and depending on its value one of 'bin32' or 'bin64' is 
            added to the beginning of the current PATH environment variable.</para>
            <para>In order to overwrite this behavior, one may set the absolut path to be included here. Note, this will prevent the 
            automatic (bitrate dependend) behaviour! When configuring the NativeDependenciesAbsolutePath the user must keep the 
            current bitrate into account and is responsible for placing the right binary distribution files into that folder. </para></remarks>
        </member>
        <member name="P:ILNumerics.Settings.MeasurePerformanceAtRuntime">
            <summary>
            Gives the current setting for the reporting of runtime performance measures to the windows performance monitor (perfmon) (readonly)
            </summary>
            <remarks>Activating this switch requires administrative rights on each system the application is run - at least for the first time! This is 
            necessary in order to register the performance counters to the system. Afterwards, the application does not require administrative rights anymore.
            <para>Measuring the performance at runtime does not produce a substantial impact on the performance of your algorithm. However, due to the need for elevated rights 
            the feature is disabled by default. In order to enable it, a configuration variable named "ILNMeasurePerformanceAtRuntime" needs to be set in your 
            application configuration file.</para></remarks>
        </member>
        <member name="P:ILNumerics.Settings.ManagedMultiplyBlockSize">
            <summary>
            Block size used for blocked managed matrix multiply, default: 150
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.ManagedMultiplyMaxElementSize">
            <summary>
            Threshold on number of elements in either input matrix below which matrix multiplication is done managed only, default: 200
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MinimumQuicksortLength">
            <summary>
            Determine the minimum length for arrays to be sorted via Quicksort algorithm, smaller arrays are sorted via insertion sort
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MaxNumberThreads">
            <summary>
            Maximum number of threads for parallel execution of internal functions in ILNumerics
            </summary>
            <remarks>
            <para>In order to maximize execution speed of numerical algorithms, the value of <c>MaxNumberThreads</c> should be equal to the number 
            of <b>real</b> processor cores on the system. For processors utilizing <a href="http://en.wikipedia.org/wiki/Hyper-threading">Hyper-threading</a> the number on virtual cores 
            may be higher. However, since those virtual cores share certain ressources for execution, parallel utiliziation can not efficently be done with them. In this cases, the number of 'cores' 
            appearing e.g. in the windows task manager is misleading and the true number of independent cores should be used for <c>MaxNumberThreads</c> instead. Consult your proccessor vendor in order to find out, how many 
            independant cores your system utilizes.</para>
            <para>Since the number of independent cores is not reliably determined by .NET, ILNumerics defaults to 2 cores on all multicore machines. Therefore, this setting should be <a href="http://ilnumerics.net/$Configuration.html">set manually</a> for 
            better processor utilization on multicore machines.</para>
            <para>If your algorithm uses custom parallel execution models, it may 
            be necessary to set this value to '1'. ILNumerics will run single threaded than - leaving you the option to configure 
            the execution on parallel threads on your own.</para>
            <para>The setting of this value also effects the corresponding value of any unmanaged optimized support library (e.g. MKL) internally used by ILNumerics.</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.Settings.MaxNumberThreadsConfigured">
            <summary>
            Determine, if the current setting of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/> is the result of a custom configuration
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MinParallelElement3Count">
            <summary>
            Threshold used to determine, if computations of O(n^3) built-in-functions are done in parallel on multicore machines
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MinParallelElement2Count">
            <summary>
            Threshold used to determine, if computations of O(n^2) built-in-functions are done in parallel on multicore machines
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MinParallelElement1Count">
            <summary>
            Threshold used to determine, if computations of O(n) built-in-functions are done in parallel on multicore machines
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth">
            <summary>
            Maximal recursion depth the quicksort can go. default: 100 (for array length up to 2^100)
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.LogicalArrayToBoolConversion">
            <summary>
            Controls implicit conversions from logical arrays to System.Boolean
            </summary>
            <remarks>This setting specifies, how logical arrays are converted to System.Boolean. Those 
            conversions are important, in order to simplify expressions like 
            <code>if (A &gt; B) { ... }</code> on arrays A and B. 
            <para>Here, the comparison <code>A &gt; B</code> creates a logical array of the same size than A and B. The logical array contains
            the result of the elementwise 'greater than' comparison. This setting here controls, how that logical is converted
            to a System.Boolean, in order to evaluate the 'if' condition. </para>
            <para>The default is <c>LogicalConversionMode.NonScalarThrowsException</c>, which would cause an exception to be thrown in 
            the example above. Only scalar logical arrays can be used in such implicit conversions than.</para>
            <para>In order to further simplify the syntax, the <c>LogicalConversionMode.ImplicitAllAll</c> setting can be used. The above expression
            would evaluate to true, if <b>all</b> elements of B are greater than corresponding elements of A. This settings therefore 
            eases the syntax for most situations. However, since most comparison operators comply to the underlying <b>all</b> rule, 
            the '!=' (not equal to) operator does not - at least to the extend of common intuition. In an expression: 
            <code>if (A != B) { ... }</code> one would intuitively expect to execute the code block, if <b>at least one element</b> of A does not equal the corresponding element
            of B. However, due to the <b>all</b> rule, this is not the case! In fact, the code would be executed only, if <b>all</b> elements would 
            evaluate to true. I.e. if no single pair of corresponding elements in A and B are equal. In order to 
            get the intuitively expected behavior, one would override this by:
            <code>if (ILMath.any(A != B)) { ... } </code> 
            Since it may cause hard to find bugs, this setting should be used with care.</para></remarks>
        </member>
        <member name="P:ILNumerics.Settings.UseThreadAffinity">
            <summary>
            Determine, if main and worker threads should bind to constant cpus or not. The default is not to bind.
            </summary>
            <remarks>It usually is more efficient, to leave control of cpu binding to the runtime. However, if in certain situations, more control is required, this flag can 
            be used to make ILNumerics worker threads be affine to corresponding (native) threads.</remarks>
        </member>
        <member name="T:ILNumerics.ILSize">
            <summary>
            ILSize - dimensions for array objects (immutable)
            </summary>
            <remarks>The class internally manages the dimensions of ILNumerics arrays. 
            The class is immutable. Therefore, once created, it informs the user 
            about all dimension related properties, but cannot get altered.</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.#ctor(System.Int32[])">
            <summary>
            Create new ILSize 
            </summary>
            <param name="dims">variable length dimensions specifier</param>
            <remarks>Trailing singleton dimensions of dims will be kept.</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.#ctor(ILNumerics.ILBaseArray[])">
            <summary>
            Create new size descriptor from given data
            </summary>
            <param name="size">Size description</param>
        </member>
        <member name="M:ILNumerics.ILSize.#ctor(System.Boolean,System.Int32[])">
            <summary>
            Create new size descriptor
            </summary>
            <param name="trimSingletons">true: trailing singleton 
            dimensions will be trimmed, false: keep trailing singleton dimensions</param>
            <param name="size">Size description</param>
        </member>
        <member name="M:ILNumerics.ILSize.WorkingDimension">
            <summary>
            Find default dimension to work on
            </summary>
            <returns>Index of first non singleton dimension (i.e. dimension that is not 1); 0, if this array is a scalar.</returns>
        </member>
        <member name="M:ILNumerics.ILSize.SequentialIndexDistance(System.Int32)">
            <summary>
            Storage distance of elements in dimension dim
            </summary>
            <param name="dim">0-based index of dimension to query the element distance for</param>
            <returns>Storage distance of elements between adjacent elements of dimension dim
            </returns>
            <remarks>If dimension index dim is larger than the number of 
            dimensions of this array, the number of elements will 
            be returned (trailing singleton dimensions).</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.GetSequentialIndexDistances(System.Int32)">
            <summary>
            Distances between adjacent elements for all dimensions
            </summary>
            <param name="minLength">minimum length of array to be 
            returned. If this is larger than the number of dimensions 
            in this size descriptor, the array will have minLength elements, 
            with elements outside this dimensions repeating the value 
            of the last dimension. The length of the array returned will 
            be equal or greater than max(minLength,NumberOfDimensions).</param>
            <remarks>This is provided for performance reasons and should be 
            used internally only. It enables developer of index access routines 
            to cache the elements distances directly inside their functions 
            without having to query the info on every index access.
            <para>Keep in mind, only the distances for the number of my 
            dimensions are returned. Higher dimensions must be set to 
            NumberOfElements if needed. This is different than querying 
            the distances by SequentialIndexDistance(int), which will assume 
            and return trailing dimensions to be 1.</para>
            <para>IMPORTANT: ALTERING THE ARRAY RETURNED IS NOT ALLOWED AND 
            MAY LEAD TO SERIOUS INSTABILITY AND UNWANTED SIDE EFFECTS!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILSize.ToIntArray">
            <summary>
            Transfer my dimensions to integer array 
            </summary>
            <returns>Integer array containing a copy of all dimensions length</returns>
        </member>
        <member name="M:ILNumerics.ILSize.ToIntArray(System.Int32)">
            <summary>
            Transfer my dimensions to integer array 
            </summary>
            <param name="length">Minimum length of output array. If length 
            is larger than my dimensions, trailing ones will be added.</param>
            <returns>Integer array containing a copy of dimensions length. 
            Trailing elements outside my dims will be one.</returns>
        </member>
        <member name="M:ILNumerics.ILSize.ToIntArrayEx(System.Int32)">
            <summary>
            return dimension vector, fixed length, for subarray operations
            </summary>
            <param name="length"></param>
            <returns>dimension vector, corresponds to reshaped or unlimited dimensions</returns>
        </member>
        <member name="M:ILNumerics.ILSize.IndexFromArray(System.Int32[])">
            <summary>
            Transform indices from int[] System.Array into sequential index of underlying 1dim array 
            </summary>
            <param name="idx">int array of nrDims length, min length: 1, all indices must fit into my dimensions</param>
            <returns>Index pointing to element defined by 'idx'</returns>
        </member>
        <member name="M:ILNumerics.ILSize.IndexFromArray(System.Boolean@,System.Int32[]@,System.Int32[])">
            <summary>
            Transform dimension position into sequential index, gather expand 
            information
            </summary>
            <param name="idx">int array of arbitrary length</param>
            <param name="MustExpand">[output] true, if the indices 
            given address an element outside of 
            this dimensions size. In this case, the output parameter 
            'Dimensions' carry the sizes 
            of new dimensions needed. False otherwise</param>
            <param name="dimensions">sizes of dimension if expansion is needed. 
            Must be predefined to length of max(idx.Length,m_nrDims) at least</param>
            <returns>Index number pointing to the value's position in 
            sequential storage.</returns>
            <remarks>no checks are made for idx to fit inside dimensions! 
            This functions is used for left side assignments. Therefore it 
            computes the destination index also if it lays outside 
            the array bounds.</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.IndexFromArray(System.Int32[],System.Int32)">
            <summary>
            Unshift dimensions of indices from int[] Array 
            and translate to index for sequential storage access 
            in my dimensions </summary>
            <param name="idx">int array of the same length as 
            the number of dimensions of this storage. Indices must 
            lay within my dimensions.</param>
            <param name="unshift">Number of dimensions to unshift 
            idx before computing index</param>
            <returns>Index number pointing to the value's position 
            in sequential storage.</returns>
            <remarks>If idx contains elements (indices) larger than 
            my dimension bounds, an exception will be thrown. If unshift 
            is 0, the length of idx may be smaller than the length of 
            my dimensions. However, with unshift &gt; 0 the result 
            is undefined.</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.GetShifted(System.Int32)">
            <summary>
            Return shifted version
            </summary>
            <param name="shift">Number of dimensions to shift. The value
            will be considered modules the number of dimensions of 
            this size descriptor.</param>
            <returns>Shifted version of this size descriptor object.</returns>
        </member>
        <member name="M:ILNumerics.ILSize.GetReshapedSize(System.Int32)">
            <summary>
            Create dimension sizes for reshaping index adressing
            </summary>
            <param name="dimCount">Needed number of destination array dimensions</param>
            <returns>Dimension sizes, cutted trailing dimensions are multiplied to last dimension returned.</returns>
        </member>
        <member name="M:ILNumerics.ILSize.IsSameSize(ILNumerics.ILSize)">
            <summary>
            Compares the size of this dimension to another dimension object. 
            </summary>
            <param name="dim2">size descriptor to compare this to.</param>
            <returns>Returns true if the sizes are the same, else returns false. 
            The comparison is made by recognizing singleton dimensions. Therefore 
            only non singleton dimensions are compared in the order of their 
            appearance. </returns>
            <remarks>The function returns true, if the squeezed dimensions of 
            both size descriptors match.</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.IsSameShape(ILNumerics.ILSize)">
            <summary>
            Compares the shape of this dimension to another dimension object 
            </summary>
            <param name="dim2">size descriptor to compare this to.</param>
            <returns>Returns true if the shapes are the same, else returns false. </returns>
            <remarks>This function is more strict than IsSameSize. In order 
            for two dimensions to have the same shape, ALL dimensions must match - 
            even singleton dimensions.</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.GetSqueezed">
            <summary>
            [deprecated] Create copy of this size descriptor having all singleton 
            dimensions removed.
            </summary>
            <returns>a squeezed copy</returns>
            <remarks>This function is deprecated. Use the ILSize.Squeeze()
            memeber instead. </remarks>
        </member>
        <member name="M:ILNumerics.ILSize.Squeeze">
            <summary>
            Create and return copy without singleton dimensions
            </summary>
            <returns>Copy of this size descriptor having all singleton dimensions removed.</returns>
            <remarks> This function does not alter this object (since ILSize is 
            immutable).
            <para>All arrays in ILNumerics have at least 2 dimensions. 
            Therefore all but the first two singleton dimensions can be removed.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILSize.Trim">
            <summary>
            Return size descriptor, having trailing singleton dimensions removed
            </summary>
            <returns>Copy without trailing singleton dimensions</returns>
            <remarks>This object will NOT be altered. As usual for all ILArrays, 
            the result wil have at least 2 dimensions.</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.ToString">
            <summary>
            Pretty print dimensions in the format "[a,b,c]"
            </summary>
            <returns>Dimensions as String</returns>
        </member>
        <member name="M:ILNumerics.ILSize.GetHashCode">
            <summary>
            Generate hash code based on the dimension information 
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:ILNumerics.ILSize.Equals(System.Object)">
            <summary>
            Checks for equaltiy of this dimensions to another dimensions object
            </summary>
            <param name="obj">Dimensions object to compare this instance with</param>
            <returns>true, if both dimensions have the same <b>shape</b></returns>
            <remarks>This is equivalent to <c>IsSameShape((ILSize)obj)</c>.</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.op_Inequality(ILNumerics.ILSize,ILNumerics.ILSize)">
            <summary>
            'Not equal' operator on two instances of <see cref="T:ILNumerics.ILSize"/>
            </summary>
            <param name="s1">first size object</param>
            <param name="s2">second size object</param>
            <returns>true, if both instances do not have the same <b>shape</b></returns>
            <remarks>The operator is an alias for <code>!ILSize.Equals()</code>
            <para>If either one of <paramref name="s1"/> or <paramref name="s2"/> is null, the operator returns false.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILSize.op_Equality(ILNumerics.ILSize,ILNumerics.ILSize)">
            <summary>
            'Equal' operator on two instances of <see cref="T:ILNumerics.ILSize"/>
            </summary>
            <param name="s1">first size object</param>
            <param name="s2">second size object</param>
            <returns>true, if both instances have the same <b>shape</b></returns>
            <remarks>The operator is an alias for <code>ILSize.Equals()</code>.
            <para>If either one of <paramref name="s1"/> or <paramref name="s2"/> is null, the operator returns false.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILSize.Empty00">
            <summary>
            An size descriptor of size 0x0
            </summary>
        </member>
        <member name="P:ILNumerics.ILSize.Scalar1_1">
            <summary>
            An size descriptor of size 1x1
            </summary>
        </member>
        <member name="P:ILNumerics.ILSize.Column2_1">
            <summary>
            An size descriptor of size 2x1
            </summary>
        </member>
        <member name="P:ILNumerics.ILSize.Column3_1">
            <summary>
            An size descriptor of size 3x1
            </summary>
        </member>
        <member name="P:ILNumerics.ILSize.NumberOfDimensions">
            <summary>Get number of dimensions.</summary>
        </member>
        <member name="P:ILNumerics.ILSize.NonSingletonDimensions">
            <summary>
            Number of non singleton dimensions of the array
            </summary>
            <remarks>Non singleton dimensions are dimensions which length is larger than 1. 
            Empty dimensions (length = 0) will not be taken into account.</remarks>
        </member>
        <member name="P:ILNumerics.ILSize.NumberOfElements">
            <summary>
            Number of elements in the array
            </summary>
        </member>
        <member name="P:ILNumerics.ILSize.Longest">
            <summary>
            Length of the longest dimension
            </summary>
        </member>
        <member name="P:ILNumerics.ILSize.Item(System.Int32)">
            <summary>
            Get length for dimension specified (Readonly)
            </summary>
            <param name="idx">Index of dimension</param>
            <returns>Length of dimension specified by idx</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If idx is negative</exception>
            <remarks><para>For idx corresponds to an existing dimension, 
            the length of that dimension is returned. If idx is larger than 
            the number of dimensions 1 is returned. </para>
            </remarks>
        </member>
        <member name="T:ILNumerics.Native.IILFFT">
            <summary>
            Interface for all FFT methods supported
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackward(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackward(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs backward n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackward1D(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs backward 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackward1D(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward 1-dimensional fft 
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs backward n-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward n-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym1D(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs backward 1-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym1D(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward 1-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FreePlans">
            <summary>
            Clear all currently cached plans
            </summary>
        </member>
        <member name="P:ILNumerics.Native.IILFFT.CachePlans">
            <summary>
            true, if the implementation caches plans between subsequent calls
            </summary>
        </member>
        <member name="P:ILNumerics.Native.IILFFT.SpeedyHermitian">
            <summary>
            true, if the implementation efficiently transforms from/to hermitian sequences (hermitian symmetry). 
            </summary>
            <remarks>If this property returns 'true', the implementation brings increased performance. 
            If not, the symmetry methods will bring no performance advantage over the 1D transforms. </remarks>
        </member>
        <member name="T:ILNumerics.Native.ILACMLFFT">
            <summary>
            Wrapper for FFT interface using ACML ver. 3.6
            </summary>
        </member>
        <member name="T:ILNumerics.Native.ILFFTW3FFT">
            <summary>
            Wrapper for FFT interface using FFTW3 libs
            </summary>
        </member>
        <member name="T:ILNumerics.Native.ILFFTW3FFT.fftw_iodim">
            <summary>
            This struct is used to define (n-dimensional) transform sizes
            </summary>
            <remarks>This struct is only user in C-API. It is NOT used for the Fortran interface (i.e. it's not used in here)!!! </remarks>
        </member>
        <member name="F:ILNumerics.Native.ILFFTW3FFT.fftw_iodim.n">
            <summary>
            length of dimension
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILFFTW3FFT.fftw_iodim.iS">
            <summary>
            input stride
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILFFTW3FFT.fftw_iodim.oS">
            <summary>
            output stride
            </summary>
        </member>
        <member name="T:ILNumerics.Native.MKLParameter">
            <summary>
            MKL configuration parameters (constant definitions)
            </summary>
        </member>
        <member name="T:ILNumerics.Native.MKLValues">
            <summary>
            MKL configuration values (constant definitions) 
            </summary>
        </member>
        <member name="T:ILNumerics.Native.MKLImports">
            <summary>
            import functions (pinvoke)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.MKLImports.DftiComputeForward(System.IntPtr,System.Double[],System.Double[])">
            DFTI native DftiComputeForward declaration 
        </member>
        <member name="M:ILNumerics.Native.MKLImports.DftiComputeBackward(System.IntPtr,System.Double[],System.Double[])">
            DFTI native DftiComputeBackward declaration 
        </member>
        <member name="T:ILNumerics.Native.ILMKLFFT">
            <summary>
            Wrapper for FFT interface using MKL 10_03
            </summary>
        </member>
        <member name="T:ILNumerics.Native.IILLapack">
            <summary>
            Interface to all LAPACK/BLAS functions available
            </summary>
            <remarks>Each native module must implement this interface explicitly. Calls 
            to native functions are made virtual by calling functions of this interface.
            Therefore the user can transparently call any function regardless of the 
            plattform the assymbly (currently) runs on. The native modules implementing
            this interface take care of the details of implementation. 
            <para>Usually users of the library will not have to handle with this interface. 
            Its functions will be used from inside built in functions and are therefore wrapped 
            (mainly from inside <see cref="T:ILNumerics.ILMath">ILNumerics.ILMath</see>).</para>
            <para>Every LAPACK/BLAS function is explicitly implemented for any type supported.
            e.g. IILLapack includes four functions doing general matrix multiply: dgemm, zgemm, cgemm and sgemm - 
            for all four floating point datatypes supported from the LAPACK package.</para>
            <para>LAPACK is an open source linear algebra functions package optimized for 
            use together with highly natively optimized BLAS functions. A LAPACK guide is 
            available in the internet: <see href="http://www.netlib.org/lapack">www.netlib.org</see>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
            <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Single,System.Single[],System.Int32)">
            <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex[],System.Int32)">
            <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
            <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgesdd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgesdd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgesdd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgesdd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgesvd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgesvd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dpotrf(System.Char,System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.spotrf(System.Char,System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cpotrf(System.Char,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zpotrf(System.Char,System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dpotri(System.Char,System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.spotri(System.Char,System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cpotri(System.Char,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zpotri(System.Char,System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dpotrs(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.spotrs(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cpotrs(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zpotrs(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgetrf(System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgetrf(System.Int32,System.Int32,System.Single[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgetrf(System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgetrf(System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgetri(System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgetri(System.Int32,System.Single[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgetri(System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgetri(System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dorgqr(System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sorgqr(System.Int32,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cungqr(System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zungqr(System.Int32,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgeqrf(System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgeqrf(System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgeqrf(System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgeqrf(System.Int32,System.Int32,ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgeqp3(System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Double[],System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgeqp3(System.Int32,System.Int32,System.Single[],System.Int32,System.Int32[],System.Single[],System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgeqp3(System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32[],ILNumerics.fcomplex[],System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgeqp3(System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],ILNumerics.complex[],System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dormqr(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Int32@)">
            <summary>
            multipliation for general matrix with QR decomposition factor
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sormqr(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Int32@)">
            <summary>
            multipliation for general matrix with QR decomposition factor
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dtrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.strtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.ctrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.ztrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgetrs(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Double[],System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgetrs(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Int32[],System.Single[],System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgetrs(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32[],ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgetrs(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="T:ILNumerics.Native.ILACML4_1">
            <summary>
            LAPACK implementation for AMD processors
            </summary>
            <remarks>By using this module, you will have to make sure,
            you placed all runtime binaries for AMD's performance library 
            into the binary output dir accessable for ILNumerics assemblies. 
            Those modules must be donwloaded seperately, since it is not 
            permitted to distribute them among with LGPL code. However, 
            developing and redistributing of products with ACML is possible though. 
            AMD currently does not charge money for a redistributable 
            license, given that one signs a license agreement with AMD 
            individually.</remarks>
        </member>
        <member name="T:ILNumerics.Native.ILLapackGenLinux">
            <summary>
            Generic LAPACK implementation, unsupported processor types
            </summary>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
            <summary>
            Implements wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.sgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Single,System.Single[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.cgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.sgesvd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.cgesvd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="T:ILNumerics.Native.ILLapackMKL10_0">
            <summary>
            Generic LAPACK implementation, unsupported processor types
            </summary>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.FreeBuffers">
            <summary>
            Free all buffers from the MKL Fast Memory Management. Use sparingly and carefully! 
            </summary>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.sgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Single,System.Single[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.cgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.sgesvd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.cgesvd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="T:ILNumerics.Storage.ILCellStorage">
            <summary>
            The class realizes an internal storage wrapper for cell arrays. It takes care of value semantics for reference types. 
            </summary>
        </member>
        <member name="T:ILNumerics.Storage.ILDenseStorage`1">
            <summary>
            The class realizes an internal storage wrapper. It stores the internal data array
            and the dimension specifications for both: ILRetArray and ILDenseStorage (reference and solid). 
            </summary>
        </member>
        <member name="T:ILNumerics.Storage.ILStorage">
            <summary>
            Background storage object used internally.
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILStorage.m_size">
            <summary>
            size of this storage
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILStorage.Size">
            <summary>
            Size of the storage
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILStorage`1.GetValueTyped(System.Int32[])">
            <summary>
            Get single value from this storage.
            </summary>
            <param name="idx">Integer array holding the dimension specifier</param>
            <returns>Element at the position pointed to by idx.</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILStorage`1.SetValueTyped(`0,System.Int32[])">
            <summary>
            Set value of element at the specified position.
            </summary>
            <param name="value">new value</param>
            <param name="idx">position of the element to be altered</param>
        </member>
        <member name="F:ILNumerics.Storage.ILDenseStorage`1.m_data">
            <summary> 
            Internal storage object. Contains the final System.Array storage and a reference counter.
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetLimits(`0@,`0@)">
            <summary>
            Get minimum and maximum value of all elements - if these exist.
            </summary>
            <param name="minValue">Output: minimum value.</param>
            <param name="maxValue">Output: maximum value.</param>
            <returns>True if the limits exists and could be computed, false otherwise.</returns>
            <remarks>Empty arrays will return false. The output parameter will be default(type).</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetLimits(`0@,`0@,System.Boolean)">
            <summary>
            Get minimum and maximum value of all elements - if existing
            </summary>
            <param name="minValue">Output: minimum value.</param>
            <param name="maxValue">Output: maximum value.</param>
            <param name="includeInfNaNs">true: recognize Inf, NaN values; false: ignore those values</param>
            <returns>True if the limits exists and could be computed, false otherwise.</returns>
            <remarks>Empty arrays will return false. The output parameter will be default(ElementType) then.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.ToString">
            <summary>
            Write information about the ILDenseStorage to string.
            </summary>
            <returns>String containing general information about the current instance of 
            ILDenseStorage and the formatted elements' values.</returns>
            <remarks>If the number of elements exceeds a certain amount, the display will be abreviated.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.ValuesToString(System.Int32)">
            <summary>
            print formated values to string
            </summary>
            <param name="maxLength">Maximum number of characters per line. 0: no limit</param>
            <returns>StringBuilder object filled with formated values.</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Equals(System.Object)">
            <summary>
            Check if the content of this array equals the content of obj.
            </summary>
            <param name="obj">storage containing the values with which to compare this array.</param>
            <returns>True if all elements contained in obj are equal to the 
            elements of this array, false otherwise.</returns>
            <remarks>This method compares the object references of corresponding elements. 
            The size and type of both arrays must match. Otherwise false will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Equals(ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Test if this dense storage equals another dense storage.
            </summary>
            <param name="A">storage to compare this storage with</param>
            <returns>True if all elements and dimension sizes match, false otherwise.</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetHashCode">
            <summary>
            generate a hash code based on the current arrays values
            </summary>
            <returns>hash code</returns>
            <remarks>The hashcode is generated by taking the values currently stored in the array into account.
            Therefore, the function must iterate over all elements in the array - which makes it somehow a expensive 
            operation. Take this into account, if you consider using large arrays in collections like dictionaries 
            or hashtables, which make great use of hash codes.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.Storage.ILRange,ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Alter values specified by range.
            </summary>
            <param name="range">ILRange specifying the dimensions/indices to be altered.</param>
            <param name="values">new values</param>
            <remarks>
            The values pointed to by range will be replaced with the values 
            found in 'values'. Important: the range cannot specify indices outside of my dimensions! 
            Therefore, the storage must have been expanded in advance, if needed!</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.ILBaseArray{System.Double},ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.ILBaseArray{System.Int64},ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.ILBaseArray{System.Int32},ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.ILBaseArray{System.Int16},ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.ILBaseArray{System.Single},ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.ShiftDimensions(System.Int32)">
            <summary>
            Create referencing or solid array from this array, with shifted dimensions.
            </summary>
            <param name="shift">Number of dimensions to shift the array.</param>
            <returns>Shifted ILDenseStorage of the same type.</returns>
            <remarks><para>Shift is done 'to the left'.</para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Reshape(ILNumerics.ILSize)">
            <summary>
            reshape <b>this</b> storage
            </summary>
            <param name="newDimensions">new dimensions of the storage.</param>
            <remarks><para>This storage will be changed! The operation is cheap, since the 
            number of elements (and their values) do not change. The same countable array
            is used in conjunction with a new dimension specifier. </para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 'newDimension'
            do not match the number of elements in this storage.</exception>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Reshape(System.Int32[])">
            <summary>
            reshape <b>this</b> storage
            </summary>
            <param name="dims">new dimension length of the storage.</param>
            <remarks><para>This storage will be changed! The operation is cheap, since the 
            number of elements (and their values) do not change. The same underlying storage 
            is used in conjunction with the new dimension specifier.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 'newDimension'
            do not match the number of elements in this storage.</exception>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Concat(ILNumerics.Storage.ILDenseStorage{`0},System.Int32)">
            <summary>
            concatenate this storage 
            </summary>
            <param name="A">n dimensional storage</param>
            <param name="dim">Index of dimension along which to concatenate the arrays.
            If dim is larger than the number of dimensions of one of the arrays
            its value will be used in modulus.</param>
            <returns>Array having the size of both input arrays laid beside one 
            another along the <paramref name="dim"/>'s-dimension</returns>
            <remarks>The array returned will be a copy of both arrays involved. None 
            of the input arrays will be altered.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Repmat(System.Int32[])">
            <summary>
            Replicate this storage to create a larger array.
            </summary>
            <param name="sizes">Sizes description. This may be a 
            list or an array of integer values. If the number of elements in <paramref name="sizes"/> is 
            less the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimensions of this array, the result 
            will have its number of dimensions extended accordingly. </param>
            <returns>array which is made out of multiple copies of this array along 
            specified dimensions, according to <paramref name="sizes"/>.</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Remove(System.Int32,ILNumerics.Data.ILIntList)">
            <summary>
            Remove individual parts of a dimension from <b>this</b> storage
            </summary>
            <param name="dimension">index of the dimension, where <c>indices</c> are to be removed</param>
            <param name="indices">indices to be removed from <paramref name="dimension"/>, -1 for "wipe" (make this an empty storage)</param>
            <remarks>The function directly operates on <b>this</b> storage! After the function returns, 
            this storage may have its dimensions changed!</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.OnSerialize(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Prepare for serialization.
            </summary>
            <param name="context">Streaming Context - provided by the formatter.</param>
            <remarks>nothing to do here</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.OnDeserialized(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Post operations aftre deserializing is finished.
            </summary>
            <param name="context">Streaming context provided by the formatter.</param>
            <remarks>nothing to do here</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetValue(System.Int32[])">
            <summary>
            Get single value from this storage.
            </summary>
            <param name="idx">Integer array holding the dimension specifier</param>
            <returns>Element at the position pointed to by idx.</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetValueTyped(System.Int32[])">
            <summary>
            Get single value from this storage.
            </summary>
            <param name="idx">Integer array holding the dimension specifier</param>
            <returns>Element at the position pointed to by idx.</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetValueSeq(System.Int32,System.Int32[]@)">
            <summary>
            Get single value from this storage by a single sequential access.
            </summary>
            <param name="idx">Integer array holding the dimension specifier 
            pointing to the value.</param>
            <param name="dims">Out value: return position mapped to dimensions.</param>
            <returns>Object in the position pointed to by idx.</returns>
            <remarks>dims is the final position into the array for the sequential index specification <c>idx</c>.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetValue(System.Object,System.Int32[])">
            <summary>
            Set single value to element at the specified index.
            </summary>
            <param name="value">New value.</param>
            <param name="idx">Index of the element to be altered.</param>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetValueTyped(`0,System.Int32[])">
            <summary>
            Set value of element at the specified position.
            </summary>
            <param name="value">new value</param>
            <param name="idx">position of the element to be altered</param>
            <remarks><para>This function does support automatic expansion of the array
            if indices lay outside the dimension limits of the array. However, because 
            of ambiguity reasons this is not reliable supported for vector sized arrays.</para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.getBaseIndex(System.Int32[])">
            <summary>
            [depricated] Convert index array into sequential index for storage access.
            </summary>
            <param name="idx">int array with dimension specification.</param>
            <returns>Index of requested value inside the solid storage. This 
            value can directly be used to query the corresponding value via GetArrayForRead()[return_value].
            </returns>
            <remarks><b>This function is deprecated! Use <see cref="M:ILNumerics.ILSize.IndexFromArray(System.Int32[])"/> instead!</b><br/>
            If the length of idx is smaler than the number of dimensions 
            of this storage, the trailing dimensions will be replaced with "0". I.e 
            the first index of each non specified dimension will be used. 
            If length of idx is larger than the dimensions of this storage, the behavior
            is undefined. Therefore this function should be enclosed in try, catch blocks 
            to handle this case!</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.getBaseIndex(System.Boolean@,System.Int32[]@,System.Int32[])">
            <summary>
            [depricated] Convert index array into sequential index for storage access. Ommit any bound checking. 
            </summary>
            <param name="idx">int array with dimensions specification.</param>
            <param name="MustExpand">Output parameter. On return determine, if the index 
            specification points outside of the dimensions of this ILDenseStorage and the array 
            must be expanded before accessing elements on that position.</param>
            <param name="dimensions">if the array was found to be expanded, this are the 
            needed dimension sizes for the new array. The sizes are computed from the range 
            specification given.</param>
            <returns>Index of requested value inside the solid storage. This 
            value may directly be used to query the value via m_data[return_value].
            The value returned is valid for solid storages as well as for reference 
            storages.
            </returns>
            <remarks>
            <para>idx must be not null and must contain at least one element.</para>
            <para>If the length of idx is smaler than the number of dimensions 
            of this storage, the trailing dimensions will be replaced with "0". I.e 
            the first index of each non specified dimensions will be used. 
            If length of idx is larger than the dimensions of this storage, the index of 
            the expanded array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.ExportValues(`0[]@)">
            <summary>
            Copy values of all elements into System.Array.
            </summary>
            <param name="result">System.Array, holding all element values of this ILDenseStorage.</param>
            <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            its leading elements will be overwritten when function returns. If 'result' is null or has too few elements, 
            it will be recreated from the ILNumerics memory pool.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetArrayForWrite">
            <summary>
            Get direct reference to inner System.Array storage for <b>write access</b>
            </summary>
            <returns>reference to inner System.Array</returns>
            <remarks>Altering this array can be done directly. If necessary, the array is detached before 
            returned. Watch the column order format of storages in ILNumerics! Keep in minds, the length 
            of the array may exceeds the number of elements.
            <para>Accessing the inner system array directly should be left to ILNumerics experts only! 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T>! (You have been warned!)</para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetArrayForRead">
            <summary>
            Get direct reference to inner System.Array storage for <b>read access</b>
            </summary>
            <returns>reference to inner System.Array for reading</returns>
            <remarks>This method is provided for experts only! Altering elements of this 
            array may cause the data to be invalidated or corrupted! Use this array only for reading! Note 
            the ILNumerics array storage format (column major). Keep in mind, the length 
            of the array may exceeds the number of elements! 
            <para>Accessing the inner system array directly should be left to ILNumerics experts only! 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T>! (You have been warned!)</para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Clone">
            <summary>
            Create lazy,shallow copy of this array 
            </summary>
            <returns>ILDenseStorage as copy of this storage.</returns>
            <remarks>The ILDenseStorage object returned will be of the same size and type than this object.
            <para>The copy is done lazy. This means, the new storage will at first share the memory 
            with that storage. This will take almost no memory / processor time. As soon as attempts 
            are made to <b>alter</b> the new storage, it will be detached from this storage and use own memeory.</para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetEnumerator">
            <summary>
            enumerator returning elements as ElementType
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.ExtractRemovalParameter(ILNumerics.ILBaseArray[],System.Int32@,ILNumerics.Data.ILIntList@,ILNumerics.ILSize@)">
            <summary>
            helper function to gather some parameters for partial dimension removal 
            </summary>
            <param name="rng">object with index specifications. May be of 
            type ILBaseArray[] with numeric arrays or a string array according 
            to the format of <see cref="T:ILNumerics.Storage.ILRange"/>. 
            </param>
            <param name="dimensionIdx">Out parameter: index of dimension the indices to be removed lie in.</param>
            <param name="indices">Indices to be removed.</param>
            <param name="dimensions">Dimension structure, can be used to reshape the storage <b>before</b> the removal</param>
            <remarks>If range comprises a range dimension specification which is smaller than 
            the actual number of dimension of this storage, the storage must be reshaped in advance of the removal. 
            This reshaping proccess will <b>not</b> be done inside this function! However 
            the <c>dimension</c> value returned reflects the size of the storage before removing and therefore
            can be utilized for reshaping the storage.</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If:<list type="bullet">
            <item>The length of range exceeds the dimensions of this storage.</item>
            <item>More than one or less than one dimension of <c>range</c> was not null.</item>
            <item>The type of range was invalid, or</item>
            <item>Range is of type <see cref="T:ILNumerics.ILBaseArray"/>, but the element type is not numeric</item>
            </list></exception>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.ExpandArray(ILNumerics.Storage.ILLeftSideRange)">
            <summary>
            Expanded <b>this</b> storage for index addressing outside of my dimensions
            </summary>
            <param name="range">range specification with size for destination array</param>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.ExpandArray(System.Int32[])">
            <summary>
            Expand <b>this</b> storage for index addressing outside of my dimensions
            </summary>
            <param name="indices">sizes of dimensions for the new storage</param>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.copyUpperTriangle(System.Int32)">
            <summary>
            Copy upper triangular part of this array into new solid array.
            </summary>
            <param name="n">Length of first dimension of destination array.</param>
            <returns>Solid array of size [n x {ThisColumnCount})].</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.copyLowerTriangle">
            <summary>
            Copy lower triangular part of this array into new solid array.
            </summary>
            <returns>Solid array of same size than this array.</returns>
            <remarks>If this is not a 2D array, only the first dimension is referenced.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.#ctor(`0[],ILNumerics.ILSize)">
            <summary>
            create new dense storage
            </summary>
            <param name="system_array">countable array</param>
            <param name="dimensions">dimensions</param>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Dispose(System.Boolean)">
            <summary>
            dispose this storage
            </summary>
            <remarks><para>Calling Dispose should be the last method called for an ILDenseStorage.</para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Detach">
            <summary>
            detach this storage: copy its countable array if necessary
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray from this array
            </summary>
            <param name="range"> arrays specifying the ranges to create subarray from</param>
            <returns>subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateRangedSubarray(ILNumerics.ILBaseArray{ILNumerics.Misc.ILRegularRange})">
            <summary>
            subarray from single dim, single range
            </summary>
            <returns>subarray (column vector)</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageSequential(ILNumerics.ILBaseArray{System.Linq.Expressions.Expression})">
            <summary>
            create new subarray storage, sequentially addressed elements
            </summary>
            <param name="indices">sequential indices, arbitrary size</param>
            <returns>new storage, type of this storage, size and shape of indices</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageSequential(ILNumerics.ILBaseArray{System.Double})">
            <summary>
            create new subarray storage, sequentially addressed elements
            </summary>
            <param name="indices">sequential indices, arbitrary size</param>
            <returns>new storage, type of this storage, size and shape of indices</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageSequential(ILNumerics.ILBaseArray{System.Int64})">
            <summary>
            create new subarray storage, sequentially addressed elements
            </summary>
            <param name="indices">sequential indices, arbitrary size</param>
            <returns>new storage, type of this storage, size and shape of indices</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageSequential(ILNumerics.ILBaseArray{System.Int32})">
            <summary>
            create new subarray storage, sequentially addressed elements
            </summary>
            <param name="indices">sequential indices, arbitrary size</param>
            <returns>new storage, type of this storage, size and shape of indices</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageSequential(ILNumerics.ILBaseArray{System.Single})">
            <summary>
            create new subarray storage, sequentially addressed elements
            </summary>
            <param name="indices">sequential indices, arbitrary size</param>
            <returns>new storage, type of this storage, size and shape of indices</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageFull">
            <summary>
            create column vector of all this array elements
            </summary>
            <returns>new storage, type of this storage, size and shape of indices</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorage(ILNumerics.Storage.ILRange)">
            <summary>
            create subarray from ILDenseStorage 
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateShiftedStorage(System.Int32)">
            <summary>
            create new storage, shift dimensions 
            </summary>
            <param name="shift">number of dimensions to shift</param>
            <returns>shifted storage </returns>
        </member>
        <member name="P:ILNumerics.Storage.ILDenseStorage`1.ReferenceCount">
            <summary>
            number of storages referencing the current data array
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILDenseStorage`1.IsDisposed">
            <summary>
            Determine, if this storage has already been disposed.
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.#ctor(ILNumerics.Storage.ILStorage[],ILNumerics.ILSize)">
            <summary>
            create new cell storage
            </summary>
            <param name="system_array">countable array</param>
            <param name="dimensions">dimensions</param>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.SetValueTyped(ILNumerics.Storage.ILStorage,System.Int32[])">
            <summary>
            replace array at specified location
            </summary>
            <param name="value">new scalar value for element</param>
            <param name="indices">indices of element to be altered, supports 'deep indexing'</param>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.GetValueTyped(System.Int32[])">
            <summary>
            get element from this cell storage
            </summary>
            <param name="indices">indices of element</param>
            <returns>element </returns>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.IsTypeOf``1(ILNumerics.ILBaseArray[])">
            <summary>
            test if an element of the cell is an array of the given element type
            </summary>
            <typeparam name="T">the array element type to check the cell element against</typeparam>
            <param name="position">position of the cell element to be tested</param>
            <returns>true if the element found at the given position is an array of the element type <typeparamref name="T"/>, false otherwise</returns>
            <remarks>The method is helpful in order to investigate the contents of a cell array. If you are not sure about the 
            types of elements in the cell, this function can be used to make sure, elements are of the expected type before retrieving them as such.
            <para>In most situations, elements of a cell are stored arrays of a distinct element type. That element type is given to IsTypeOf as 
            typeparameter <typeparamref name="T"/>. That means, in order to find out, if the first cell element stores an array of int (<c>ILArray&lt;int></c>), 
            one may use <c>cell.IsTypeOf&lt;int>(0)</c></para>
            <para>In order to test, if a cell element is of cell type, one can provide the type <c>ILCell</c> as type parameter: 
            <c>cell.IsTypeOf&lt;ILCell>(0)</c>. Note the different semantic when checking for cell elements of type cell. Here we do not test for the 
            element type but for the array type itself, ie. <c>ILCell</c>. The reason of this is: the type of elements of <c>ILCell</c> is 
            an implementation detail and therefore hidden to the user.</para>
            </remarks>
            <example>
            <para>In the following example a ILCell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
            <code>ILCell cell = ILMath.cell(new ILSize(3, 2) 
                                 , "first element"
                                 , 2.0
                                 , ILMath.cell(Math.PI, 100f)
                                 , ILMath.create&lt;short>(1, 2, 3, 4, 5, 6)
                                 , new double[] {-1.4, -1.5, -1.6});
            </code>
            The cell is now: 
            <code>ILCell [3,2]
                     &lt;String>      first element  &lt;Int16> [2,3,4,5,6] 
                     &lt;Double>          2          ILCell [1,3]           
                     ILCell [2,1]                                    (null)	
            </code>
            We test the element type of every element in the cell: 
            <code>
            Console.Out.WriteLine("cell[0,0] is of type 'string': {0}", cell.IsTypeOf&lt;string>(0));
            Console.Out.WriteLine("cell[0,0] is of type 'double': {0}", cell.IsTypeOf&lt;double>(0));
                                                 
            Console.Out.WriteLine("cell[1,0] is of type 'double': {0}", cell.IsTypeOf&lt;double>(1));
            Console.Out.WriteLine("cell[2,0] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell>(2));
                                                                                    
            Console.Out.WriteLine("cell[0,1] is of type 'short': {0}", cell.IsTypeOf&lt;short>(0, 1));
            Console.Out.WriteLine("cell[1,1] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell>(1, 1));
            Console.Out.WriteLine("cell[2,1] is of type 'double': {0}", cell.IsTypeOf&lt;double>(2, 1));
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'ILCell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'ILCell': True
            cell[2,1] is element type 'double': False  // element is null, IsTypeOf&lt;> never gives true
            </code></example>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.GetValue(System.Int32[])">
            <summary>
            gives clone of value addressed, supports deep index addressing
            </summary>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.GetValue``1(System.Int32[])">
            <summary>
            get single element from cell storage, predefined element type 
            </summary>
            <typeparam name="T">predefined type</typeparam>
            <param name="indices">location of element to return</param>
            <returns>element</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the element found is not of the specified type</exception>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.SetRange(ILNumerics.ILBaseArray{System.Double},ILNumerics.Storage.ILDenseStorage{ILNumerics.Storage.ILStorage})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.SetRange(ILNumerics.ILBaseArray{System.Int64},ILNumerics.Storage.ILDenseStorage{ILNumerics.Storage.ILStorage})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.SetRange(ILNumerics.ILBaseArray{System.Int32},ILNumerics.Storage.ILDenseStorage{ILNumerics.Storage.ILStorage})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.SetRange(ILNumerics.ILBaseArray{System.Int16},ILNumerics.Storage.ILDenseStorage{ILNumerics.Storage.ILStorage})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.SetRange(ILNumerics.ILBaseArray{System.Single},ILNumerics.Storage.ILDenseStorage{ILNumerics.Storage.ILStorage})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.Detach">
            <summary>
            detach this storage: copy its countable array if needed
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.DeepReferenceElements">
            <summary>
            walk all elements of this cell and recursively replace them with clones of themself 
            </summary>
            <remarks>Due to the cloning mechanism of ILNumerics, the full clone 
            will be cheap by using lazy copies of the data. Cloned elements will automatically be detached on write access.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILCountableArray`1.#ctor(System.Int32)">
            <summary>
            create new countable array by size
            </summary>
            <param name="length"></param>
            <remarks>The memory for the newly created array is requested from memory pool. All elements of the array 
            are initialized with default(ElementType).</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILCountableArray`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            create new countable array by size
            </summary>
            <param name="length"></param>
            <remarks>The memory for the newly created array is requested from memory pool. Depending on the value of 
            'clear', the elements of the array are NOT initialized and therefore may contain garbage data!.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILCountableArray`1.#ctor(`0[],System.Int32)">
            <summary>
            create new countable array, provide system array
            </summary>
            <param name="data">system array to be used as storage array directly</param>
            <param name="length">minimum lenght of array needed</param>
        </member>
        <member name="M:ILNumerics.Storage.ILCountableArray`1.IncreaseReference">
            <summary>
            increase reference counter 
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILCountableArray`1.DecreaseReference">
            <summary>
            decrease reference counter
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILCountableArray`1.Dispose">
            <summary>
            Dispose off this array: register it in pool
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILCountableArray`1.CreateCopy">
            <summary>
            return (solid) copy of this countable array
            </summary>
            <returns>newly created array</returns>
        </member>
        <member name="P:ILNumerics.Storage.ILCountableArray`1.Data">
            <summary>
            Access to the internal system array
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILCountableArray`1.Length">
            <summary>
            minimal length of the system array to be used for computations
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILCountableArray`1.ReferenceCount">
            <summary>
            number of storages referencing to this array
            </summary>
            <remarks>In order to in-/decrease the reference counter, use 
            the <see cref="M:ILNumerics.Storage.ILCountableArray`1.IncreaseReference"/>
            and <see cref="M:ILNumerics.Storage.ILCountableArray`1.DecreaseReference"/> functions.</remarks>
        </member>
        <member name="T:ILNumerics.Storage.ILRange">
            <summary>
            base class for ranges, used to define subarray ranges
            </summary>
            <description>ILRange is used to define those parts of indices of an array,
            which are to be extracted into a new subarray. 
            The class (and derived classes) parse indices given for each dimension and expand them into a 2-dimensional 
            integer array, needed for fast element traversal.
            <para>The class is internally used only and not intended to be used from outside ILNumerics.</para></description>
        </member>
        <member name="F:ILNumerics.Storage.ILRange.m_range">
            <summary>
            hold ranges as 2 dimensional System.Array
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.Map(System.Int32[],System.Int32[]@)">
            <summary>
            Evaluates (maps) index array on my range. 
            </summary>
            <param name="idx">int array indexing location inside this range</param>
            <param name="retIdx">(output) also return the result into array given</param>
            <returns>Mapped int[] array. It can be used for direct addressing the physical storage object.</returns>
            <remarks>retIdx must be at least of length m_nrDims. No check is made for this assumption!</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.ParseDimension(System.String,System.Int32)">
            <summary>
            parse single dimension specifier from string
            </summary>
            <param name="indices">valid index specification</param>
            <param name="dimlen">number of elements in dimension to be parsed</param>
            <returns>array with indices defined in 'indices'</returns>
            <remarks>the indices are parsed the way needed for sequential addressing. This means: 
            full dimensions address the whole array. Full dimensions are transformed into negative 
            placeholder indices nevertheless! SetRange must handle that accordingly.</remarks>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.RangeArray">
            <summary>
            for performance reasons: give reference to internal array
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.Item(System.Int32)">
            <summary>
            Index access for ILRange objects. Set/returns Index array for specified dimension.
            </summary>
            <remarks>A reference to the internal object will be returned directly! (performance)</remarks>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.Item(System.Int32,System.Int32)">
            <summary>
            Index access for ILRange objects. returns the destIndex destination dimension for dimension specifyied by dimNr.
            </summary>
            <remarks>The access is readonly! No checks are made, if the requested indices exist.</remarks>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.Size">
            <summary>
            Create trimmed size descriptor from indices in ILRange object
            </summary>
            <returns>new size descriptor with the neccessary size to define 
            an array as defined by all indices in this range</returns>
        </member>
        <member name="F:ILNumerics.Storage.ILLeftSideRange.m_expandDimensions">
            <summary>
            sizes of dimensions to be expanded
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILLeftSideRange.m_expanding">
            <summary>
            internal field, stores expanding flag
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILLeftSideRange.Expanding">
            <summary>
            true for left side ranges, if at least one dimension must be expanded
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILLeftSideRange.ExpandDimensions">
            <summary>
            array with sizes of dimensions to be expanded
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILLogicalStorage.NumberNonZero">
            <summary>
            cached number of non-zero elements in this logical storage
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILRightSideRange.#ctor(ILNumerics.ILSize,System.Int32[])">
            <summary>
            rempat consctructor - for performance reasons 
            </summary>
            <param name="dimension">source array dimensions</param>
            <param name="range">destination array repmattings </param>
        </member>
    </members>
</doc>
